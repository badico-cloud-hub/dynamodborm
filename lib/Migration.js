module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(332);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends2 = __webpack_require__(2);

	var _extends3 = _interopRequireDefault(_extends2);

	var _objectWithoutProperties2 = __webpack_require__(41);

	var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

	var _classCallCheck2 = __webpack_require__(42);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(43);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _regenerator = __webpack_require__(47);

	var _regenerator2 = _interopRequireDefault(_regenerator);

	var _toConsumableArray2 = __webpack_require__(50);

	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

	var _asyncToGenerator2 = __webpack_require__(72);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var getMappedItems = function () {
	  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(iterator) {
	    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	    var _ref2, done, value;

	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return iterator.next();

	          case 2:
	            _ref2 = _context.sent;
	            done = _ref2.done;
	            value = _ref2.value;

	            if (done) {
	              _context.next = 7;
	              break;
	            }

	            return _context.abrupt('return', getMappedItems(iterator, [].concat((0, _toConsumableArray3.default)(data), [value])));

	          case 7:
	            return _context.abrupt('return', data);

	          case 8:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));

	  return function getMappedItems(_x) {
	    return _ref.apply(this, arguments);
	  };
	}();

	var _dynamodbDataMapper = __webpack_require__(95);

	var _dynamodb = __webpack_require__(157);

	var _dynamodb2 = _interopRequireDefault(_dynamodb);

	var _DynamoDBORMError = __webpack_require__(305);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Connection = function () {
	  function Connection(_ref3, options) {
	    var region = _ref3.region;
	    (0, _classCallCheck3.default)(this, Connection);

	    this.options = options || { onMissing: 'skip'

	      /**
	       * DBLOCALregion: 'localhost',
	       * endpoint: 'http://localhost:8000'
	      */
	    };if (process.env['DBLOCAL']) {
	      this.client = new _dynamodb2.default({
	        region: 'localhost',
	        endpoint: process.env['DBLOCAL']
	      });
	    } else {
	      this.client = new _dynamodb2.default({ region: region || 'us-east-1' });
	    }
	    this.mapper = new _dynamodbDataMapper.DataMapper({ client: this.client });
	  }

	  (0, _createClass3.default)(Connection, [{
	    key: 'query',
	    value: function () {
	      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(DomainClass, keys, _ref5) {
	        var index = _ref5.index,
	            filter = _ref5.filter,
	            options = (0, _objectWithoutProperties3.default)(_ref5, ['index', 'filter']);
	        var params;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.prev = 0;
	                params = (0, _extends3.default)({}, options);

	                if (filter) {
	                  Object.assign(params, { filter: filter });
	                }

	                if (index) {
	                  Object.assign(params, { indexName: index });
	                }

	                return _context2.abrupt('return', getMappedItems(this.mapper.query(DomainClass, keys, params)));

	              case 7:
	                _context2.prev = 7;
	                _context2.t0 = _context2['catch'](0);
	                throw new _DynamoDBORMError.DynamoDBORMError({
	                  error: _context2.t0,
	                  method: 'query',
	                  className: 'Connection',
	                  args: [DomainClass, keys, (0, _extends3.default)({ index: index, filter: filter }, options)]
	                }, 'ConnectionError');

	              case 10:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[0, 7]]);
	      }));

	      function query(_x3, _x4, _x5) {
	        return _ref4.apply(this, arguments);
	      }

	      return query;
	    }()
	  }, {
	    key: 'delete',
	    value: function () {
	      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(item) {
	        return _regenerator2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                _context3.prev = 0;
	                return _context3.abrupt('return', this.mapper.delete({ item: item }));

	              case 4:
	                _context3.prev = 4;
	                _context3.t0 = _context3['catch'](0);
	                throw new _DynamoDBORMError.DynamoDBORMError({
	                  error: _context3.t0,
	                  method: 'delete',
	                  className: 'Connection',
	                  args: [item]
	                }, 'ConnectionError');

	              case 7:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this, [[0, 4]]);
	      }));

	      function _delete(_x6) {
	        return _ref6.apply(this, arguments);
	      }

	      return _delete;
	    }()
	  }, {
	    key: 'get',
	    value: function () {
	      var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(DomainClass, _ref8) {
	        var index = _ref8.index,
	            keys = (0, _objectWithoutProperties3.default)(_ref8, ['index']);
	        var list;
	        return _regenerator2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                _context4.prev = 0;

	                if (!index) {
	                  _context4.next = 8;
	                  break;
	                }

	                _context4.next = 4;
	                return getMappedItems(this.mapper.query(DomainClass, keys, { indexName: index }));

	              case 4:
	                list = _context4.sent;

	                if (!(list.length > 1)) {
	                  _context4.next = 7;
	                  break;
	                }

	                throw new Error('Not unique item');

	              case 7:
	                return _context4.abrupt('return', list[0]);

	              case 8:
	                _context4.next = 10;
	                return getMappedItems(this.mapper.query(DomainClass, keys));

	              case 10:
	                return _context4.abrupt('return', _context4.sent[0]);

	              case 13:
	                _context4.prev = 13;
	                _context4.t0 = _context4['catch'](0);
	                throw new _DynamoDBORMError.DynamoDBORMError({
	                  error: _context4.t0,
	                  method: 'get',
	                  className: 'Connection',
	                  args: [DomainClass, (0, _extends3.default)({ index: index }, keys)]
	                }, 'ConnectionError');

	              case 16:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this, [[0, 13]]);
	      }));

	      function get(_x7, _x8) {
	        return _ref7.apply(this, arguments);
	      }

	      return get;
	    }()
	  }, {
	    key: 'update',
	    value: function () {
	      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(item) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	        return _regenerator2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                _context5.prev = 0;
	                return _context5.abrupt('return', this.mapper.update({ item: item }, (0, _extends3.default)({}, this.options, options)));

	              case 4:
	                _context5.prev = 4;
	                _context5.t0 = _context5['catch'](0);
	                throw new _DynamoDBORMError.DynamoDBORMError({
	                  error: _context5.t0,
	                  method: 'update',
	                  className: 'Connection',
	                  args: [DomainClass, options]
	                }, 'ConnectionError');

	              case 7:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this, [[0, 4]]);
	      }));

	      function update(_x9) {
	        return _ref9.apply(this, arguments);
	      }

	      return update;
	    }()
	  }, {
	    key: 'scan',
	    value: function () {
	      var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(DomainClass, options) {
	        return _regenerator2.default.wrap(function _callee6$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                _context6.prev = 0;
	                return _context6.abrupt('return', getMappedItems(this.mapper.scan(DomainClass, options)));

	              case 4:
	                _context6.prev = 4;
	                _context6.t0 = _context6['catch'](0);
	                throw new _DynamoDBORMError.DynamoDBORMError({
	                  error: _context6.t0,
	                  method: 'scan',
	                  className: 'Connection',
	                  args: [DomainClass, options]
	                }, 'ConnectionError');

	              case 7:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee6, this, [[0, 4]]);
	      }));

	      function scan(_x11, _x12) {
	        return _ref10.apply(this, arguments);
	      }

	      return scan;
	    }()
	  }]);
	  return Connection;
	}();

	exports.default = Connection;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _assign = __webpack_require__(3);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(4), __esModule: true };

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = __webpack_require__(8).Object.assign;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(6);

	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(22) });


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7);
	var core = __webpack_require__(8);
	var ctx = __webpack_require__(9);
	var hide = __webpack_require__(11);
	var has = __webpack_require__(21);
	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && has(exports, key)) continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	var core = module.exports = { version: '2.5.7' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(10);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(12);
	var createDesc = __webpack_require__(20);
	module.exports = __webpack_require__(16) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13);
	var IE8_DOM_DEFINE = __webpack_require__(15);
	var toPrimitive = __webpack_require__(19);
	var dP = Object.defineProperty;

	exports.f = __webpack_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function () {
	  return Object.defineProperty(__webpack_require__(18)('div'), 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(17)(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	var document = __webpack_require__(7).document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = __webpack_require__(23);
	var gOPS = __webpack_require__(38);
	var pIE = __webpack_require__(39);
	var toObject = __webpack_require__(40);
	var IObject = __webpack_require__(26);
	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(17)(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(24);
	var enumBugKeys = __webpack_require__(37);

	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var has = __webpack_require__(21);
	var toIObject = __webpack_require__(25);
	var arrayIndexOf = __webpack_require__(29)(false);
	var IE_PROTO = __webpack_require__(33)('IE_PROTO');

	module.exports = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(26);
	var defined = __webpack_require__(28);
	module.exports = function (it) {
	  return IObject(defined(it));
	};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(27);
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(25);
	var toLength = __webpack_require__(30);
	var toAbsoluteIndex = __webpack_require__(32);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(31);
	var min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(34)('keys');
	var uid = __webpack_require__(36);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var core = __webpack_require__(8);
	var global = __webpack_require__(7);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: core.version,
	  mode: __webpack_require__(35) ? 'pure' : 'global',
	  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
	});


/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = true;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');


/***/ }),
/* 38 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 39 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(28);
	module.exports = function (it) {
	  return Object(defined(it));
	};


/***/ }),
/* 41 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (obj, keys) {
	  var target = {};

	  for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;
	    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	    target[i] = obj[i];
	  }

	  return target;
	};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(44);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(45), __esModule: true };

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(46);
	var $Object = __webpack_require__(8).Object;
	module.exports = function defineProperty(it, key, desc) {
	  return $Object.defineProperty(it, key, desc);
	};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(16), 'Object', { defineProperty: __webpack_require__(12).f });


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(48);


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g = (function() { return this })() || Function("return this")();

	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;

	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;

	module.exports = __webpack_require__(49);

	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}


/***/ }),
/* 49 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	!(function(global) {
	  "use strict";

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }

	      return ContinueSentinel;
	    }
	  };
	})(
	  // In sloppy mode, unbound `this` refers to the global object, fallback to
	  // Function constructor if we're in global strict mode. That is sadly a form
	  // of indirect eval which violates Content Security Policy.
	  (function() { return this })() || Function("return this")()
	);


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _from = __webpack_require__(51);

	var _from2 = _interopRequireDefault(_from);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }

	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(52), __esModule: true };

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(53);
	__webpack_require__(65);
	module.exports = __webpack_require__(8).Array.from;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at = __webpack_require__(54)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(55)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31);
	var defined = __webpack_require__(28);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(35);
	var $export = __webpack_require__(6);
	var redefine = __webpack_require__(56);
	var hide = __webpack_require__(11);
	var Iterators = __webpack_require__(57);
	var $iterCreate = __webpack_require__(58);
	var setToStringTag = __webpack_require__(62);
	var getPrototypeOf = __webpack_require__(64);
	var ITERATOR = __webpack_require__(63)('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);


/***/ }),
/* 57 */
/***/ (function(module, exports) {

	module.exports = {};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create = __webpack_require__(59);
	var descriptor = __webpack_require__(20);
	var setToStringTag = __webpack_require__(62);
	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(63)('iterator'), function () { return this; });

	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(13);
	var dPs = __webpack_require__(60);
	var enumBugKeys = __webpack_require__(37);
	var IE_PROTO = __webpack_require__(33)('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(18)('iframe');
	  var i = enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(61).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(12);
	var anObject = __webpack_require__(13);
	var getKeys = __webpack_require__(23);

	module.exports = __webpack_require__(16) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(7).document;
	module.exports = document && document.documentElement;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f;
	var has = __webpack_require__(21);
	var TAG = __webpack_require__(63)('toStringTag');

	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var store = __webpack_require__(34)('wks');
	var uid = __webpack_require__(36);
	var Symbol = __webpack_require__(7).Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(21);
	var toObject = __webpack_require__(40);
	var IE_PROTO = __webpack_require__(33)('IE_PROTO');
	var ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ctx = __webpack_require__(9);
	var $export = __webpack_require__(6);
	var toObject = __webpack_require__(40);
	var call = __webpack_require__(66);
	var isArrayIter = __webpack_require__(67);
	var toLength = __webpack_require__(30);
	var createProperty = __webpack_require__(68);
	var getIterFn = __webpack_require__(69);

	$export($export.S + $export.F * !__webpack_require__(71)(function (iter) { Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = getIterFn(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(57);
	var ITERATOR = __webpack_require__(63)('iterator');
	var ArrayProto = Array.prototype;

	module.exports = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12);
	var createDesc = __webpack_require__(20);

	module.exports = function (object, index, value) {
	  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var classof = __webpack_require__(70);
	var ITERATOR = __webpack_require__(63)('iterator');
	var Iterators = __webpack_require__(57);
	module.exports = __webpack_require__(8).getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(27);
	var TAG = __webpack_require__(63)('toStringTag');
	// ES3 wrong here
	var ARG = cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	module.exports = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR = __webpack_require__(63)('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }

	module.exports = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _promise = __webpack_require__(73);

	var _promise2 = _interopRequireDefault(_promise);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }

	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            step("next", value);
	          }, function (err) {
	            step("throw", err);
	          });
	        }
	      }

	      return step("next");
	    });
	  };
	};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(74), __esModule: true };

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(75);
	__webpack_require__(53);
	__webpack_require__(76);
	__webpack_require__(80);
	__webpack_require__(93);
	__webpack_require__(94);
	module.exports = __webpack_require__(8).Promise;


/***/ }),
/* 75 */
/***/ (function(module, exports) {

	

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(77);
	var global = __webpack_require__(7);
	var hide = __webpack_require__(11);
	var Iterators = __webpack_require__(57);
	var TO_STRING_TAG = __webpack_require__(63)('toStringTag');

	var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
	  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
	  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
	  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
	  'TextTrackList,TouchList').split(',');

	for (var i = 0; i < DOMIterables.length; i++) {
	  var NAME = DOMIterables[i];
	  var Collection = global[NAME];
	  var proto = Collection && Collection.prototype;
	  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(78);
	var step = __webpack_require__(79);
	var Iterators = __webpack_require__(57);
	var toIObject = __webpack_require__(25);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(55)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	module.exports = function () { /* empty */ };


/***/ }),
/* 79 */
/***/ (function(module, exports) {

	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(35);
	var global = __webpack_require__(7);
	var ctx = __webpack_require__(9);
	var classof = __webpack_require__(70);
	var $export = __webpack_require__(6);
	var isObject = __webpack_require__(14);
	var aFunction = __webpack_require__(10);
	var anInstance = __webpack_require__(81);
	var forOf = __webpack_require__(82);
	var speciesConstructor = __webpack_require__(83);
	var task = __webpack_require__(84).set;
	var microtask = __webpack_require__(86)();
	var newPromiseCapabilityModule = __webpack_require__(87);
	var perform = __webpack_require__(88);
	var userAgent = __webpack_require__(89);
	var promiseResolve = __webpack_require__(90);
	var PROMISE = 'Promise';
	var TypeError = global.TypeError;
	var process = global.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = global[PROMISE];
	var isNode = classof(process) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[__webpack_require__(63)('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else if (handler = global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(global, function () {
	    var handler;
	    if (isNode) {
	      process.emit('rejectionHandled', promise);
	    } else if (handler = global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(91)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	__webpack_require__(62)($Promise, PROMISE);
	__webpack_require__(92)(PROMISE);
	Wrapper = __webpack_require__(8)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(71)(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});


/***/ }),
/* 81 */
/***/ (function(module, exports) {

	module.exports = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(9);
	var call = __webpack_require__(66);
	var isArrayIter = __webpack_require__(67);
	var anObject = __webpack_require__(13);
	var toLength = __webpack_require__(30);
	var getIterFn = __webpack_require__(69);
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
	  var f = ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = __webpack_require__(13);
	var aFunction = __webpack_require__(10);
	var SPECIES = __webpack_require__(63)('species');
	module.exports = function (O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(9);
	var invoke = __webpack_require__(85);
	var html = __webpack_require__(61);
	var cel = __webpack_require__(18);
	var global = __webpack_require__(7);
	var process = global.process;
	var setTask = global.setImmediate;
	var clearTask = global.clearImmediate;
	var MessageChannel = global.MessageChannel;
	var Dispatch = global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (__webpack_require__(27)(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	    defer = function (id) {
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in cel('script')) {
	    defer = function (id) {
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set: setTask,
	  clear: clearTask
	};


/***/ }),
/* 85 */
/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7);
	var macrotask = __webpack_require__(84).set;
	var Observer = global.MutationObserver || global.WebKitMutationObserver;
	var process = global.process;
	var Promise = global.Promise;
	var isNode = __webpack_require__(27)(process) == 'process';

	module.exports = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise && Promise.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 25.4.1.5 NewPromiseCapability(C)
	var aFunction = __webpack_require__(10);

	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}

	module.exports.f = function (C) {
	  return new PromiseCapability(C);
	};


/***/ }),
/* 88 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7);
	var navigator = global.navigator;

	module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13);
	var isObject = __webpack_require__(14);
	var newPromiseCapability = __webpack_require__(87);

	module.exports = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(11);
	module.exports = function (target, src, safe) {
	  for (var key in src) {
	    if (safe && target[key]) target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(7);
	var core = __webpack_require__(8);
	var dP = __webpack_require__(12);
	var DESCRIPTORS = __webpack_require__(16);
	var SPECIES = __webpack_require__(63)('species');

	module.exports = function (KEY) {
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-promise-finally
	'use strict';
	var $export = __webpack_require__(6);
	var core = __webpack_require__(8);
	var global = __webpack_require__(7);
	var speciesConstructor = __webpack_require__(83);
	var promiseResolve = __webpack_require__(90);

	$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = speciesConstructor(this, core.Promise || global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-promise-try
	var $export = __webpack_require__(6);
	var newPromiseCapability = __webpack_require__(87);
	var perform = __webpack_require__(88);

	$export($export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = newPromiseCapability.f(this);
	  var result = perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	tslib_1.__exportStar(__webpack_require__(97), exports);
	tslib_1.__exportStar(__webpack_require__(98), exports);
	tslib_1.__exportStar(__webpack_require__(156), exports);
	tslib_1.__exportStar(__webpack_require__(99), exports);
	tslib_1.__exportStar(__webpack_require__(135), exports);
	//# sourceMappingURL=index.js.map

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global global, define, System, Reflect, Promise */
	var __extends;
	var __assign;
	var __rest;
	var __decorate;
	var __param;
	var __metadata;
	var __awaiter;
	var __generator;
	var __exportStar;
	var __values;
	var __read;
	var __spread;
	var __await;
	var __asyncGenerator;
	var __asyncDelegator;
	var __asyncValues;
	var __makeTemplateObject;
	var __importStar;
	var __importDefault;
	(function (factory) {
	    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) { factory(createExporter(root, createExporter(exports))); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    else if (typeof module === "object" && typeof module.exports === "object") {
	        factory(createExporter(root, createExporter(module.exports)));
	    }
	    else {
	        factory(createExporter(root));
	    }
	    function createExporter(exports, previous) {
	        if (exports !== root) {
	            if (typeof Object.create === "function") {
	                Object.defineProperty(exports, "__esModule", { value: true });
	            }
	            else {
	                exports.__esModule = true;
	            }
	        }
	        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
	    }
	})
	(function (exporter) {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

	    __extends = function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };

	    __assign = Object.assign || function (t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };

	    __rest = function (s, e) {
	        var t = {};
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	            t[p] = s[p];
	        if (s != null && typeof Object.getOwnPropertySymbols === "function")
	            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
	                t[p[i]] = s[p[i]];
	        return t;
	    };

	    __decorate = function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };

	    __param = function (paramIndex, decorator) {
	        return function (target, key) { decorator(target, key, paramIndex); }
	    };

	    __metadata = function (metadataKey, metadataValue) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	    };

	    __awaiter = function (thisArg, _arguments, P, generator) {
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	        });
	    };

	    __generator = function (thisArg, body) {
	        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	        function verb(n) { return function (v) { return step([n, v]); }; }
	        function step(op) {
	            if (f) throw new TypeError("Generator is already executing.");
	            while (_) try {
	                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	                if (y = 0, t) op = [op[0] & 2, t.value];
	                switch (op[0]) {
	                    case 0: case 1: t = op; break;
	                    case 4: _.label++; return { value: op[1], done: false };
	                    case 5: _.label++; y = op[1]; op = [0]; continue;
	                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                    default:
	                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                        if (t[2]) _.ops.pop();
	                        _.trys.pop(); continue;
	                }
	                op = body.call(thisArg, _);
	            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	        }
	    };

	    __exportStar = function (m, exports) {
	        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	    };

	    __values = function (o) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
	        if (m) return m.call(o);
	        return {
	            next: function () {
	                if (o && i >= o.length) o = void 0;
	                return { value: o && o[i++], done: !o };
	            }
	        };
	    };

	    __read = function (o, n) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator];
	        if (!m) return o;
	        var i = m.call(o), r, ar = [], e;
	        try {
	            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	        }
	        catch (error) { e = { error: error }; }
	        finally {
	            try {
	                if (r && !r.done && (m = i["return"])) m.call(i);
	            }
	            finally { if (e) throw e.error; }
	        }
	        return ar;
	    };

	    __spread = function () {
	        for (var ar = [], i = 0; i < arguments.length; i++)
	            ar = ar.concat(__read(arguments[i]));
	        return ar;
	    };

	    __await = function (v) {
	        return this instanceof __await ? (this.v = v, this) : new __await(v);
	    };

	    __asyncGenerator = function (thisArg, _arguments, generator) {
	        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	        var g = generator.apply(thisArg, _arguments || []), i, q = [];
	        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
	        function fulfill(value) { resume("next", value); }
	        function reject(value) { resume("throw", value); }
	        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	    };

	    __asyncDelegator = function (o) {
	        var i, p;
	        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
	        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
	    };

	    __asyncValues = function (o) {
	        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	        var m = o[Symbol.asyncIterator], i;
	        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	    };

	    __makeTemplateObject = function (cooked, raw) {
	        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
	        return cooked;
	    };

	    __importStar = function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	        result["default"] = mod;
	        return result;
	    };

	    __importDefault = function (mod) {
	        return (mod && mod.__esModule) ? mod : { "default": mod };
	    };

	    exporter("__extends", __extends);
	    exporter("__assign", __assign);
	    exporter("__rest", __rest);
	    exporter("__decorate", __decorate);
	    exporter("__param", __param);
	    exporter("__metadata", __metadata);
	    exporter("__awaiter", __awaiter);
	    exporter("__generator", __generator);
	    exporter("__exportStar", __exportStar);
	    exporter("__values", __values);
	    exporter("__read", __read);
	    exporter("__spread", __spread);
	    exporter("__await", __await);
	    exporter("__asyncGenerator", __asyncGenerator);
	    exporter("__asyncDelegator", __asyncDelegator);
	    exporter("__asyncValues", __asyncValues);
	    exporter("__makeTemplateObject", __makeTemplateObject);
	    exporter("__importStar", __importStar);
	    exporter("__importDefault", __importDefault);
	});


/***/ }),
/* 97 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.VERSION = '0.4.0';
	exports.MAX_WRITE_BATCH_SIZE = 25;
	exports.MAX_READ_BATCH_SIZE = 100;
	//# sourceMappingURL=constants.js.map

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var constants_1 = __webpack_require__(97);
	var ItemNotFoundException_1 = __webpack_require__(99);
	var ParallelScanIterator_1 = __webpack_require__(100);
	var protocols_1 = __webpack_require__(135);
	var QueryIterator_1 = __webpack_require__(147);
	var ScanIterator_1 = __webpack_require__(149);
	var dynamodb_batch_iterator_1 = __webpack_require__(151);
	var dynamodb_data_marshaller_1 = __webpack_require__(106);
	var dynamodb_expressions_1 = __webpack_require__(113);
	__webpack_require__(102);
	/**
	 * Object mapper for domain object interaction with DynamoDB.
	 *
	 * To use, define a schema that describes how an item is represented in a
	 * DynamoDB table. This schema will be used to marshall a native JavaScript
	 * object into its desired persisted form. Attributes present on the object
	 * but not in the schema will be ignored.
	 */
	var DataMapper = /** @class */ (function () {
	    function DataMapper(_a) {
	        var client = _a.client, _b = _a.readConsistency, readConsistency = _b === void 0 ? 'eventual' : _b, _c = _a.skipVersionCheck, skipVersionCheck = _c === void 0 ? false : _c, _d = _a.tableNamePrefix, tableNamePrefix = _d === void 0 ? '' : _d;
	        client.config.customUserAgent = " dynamodb-data-mapper-js/" + constants_1.VERSION;
	        this.client = client;
	        this.readConsistency = readConsistency;
	        this.skipVersionCheck = skipVersionCheck;
	        this.tableNamePrefix = tableNamePrefix;
	    }
	    /**
	     * Deletes items from DynamoDB in batches of 25 or fewer via one or more
	     * BatchWriteItem operations. The items may be from any number of tables;
	     * tables and schemas for each item are determined using the
	     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
	     * each item supplied.
	     *
	     * This method will automatically retry any delete requests returned by
	     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
	     * employed on a per-table basis.
	     *
	     * @param items A synchronous or asynchronous iterable of items to delete.
	     */
	    DataMapper.prototype.batchDelete = function (items) {
	        return tslib_1.__asyncGenerator(this, arguments, function batchDelete_1() {
	            var e_1, _a, iter, iter_1, iter_1_1, written, e_1_1;
	            return tslib_1.__generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        iter = this.batchWrite(function mapToDelete() {
	                            return tslib_1.__asyncGenerator(this, arguments, function mapToDelete_1() {
	                                var e_2, _a, items_1, items_1_1, item, e_2_1;
	                                return tslib_1.__generator(this, function (_b) {
	                                    switch (_b.label) {
	                                        case 0:
	                                            _b.trys.push([0, 7, 8, 13]);
	                                            items_1 = tslib_1.__asyncValues(items);
	                                            _b.label = 1;
	                                        case 1: return [4 /*yield*/, tslib_1.__await(items_1.next())];
	                                        case 2:
	                                            if (!(items_1_1 = _b.sent(), !items_1_1.done)) return [3 /*break*/, 6];
	                                            item = items_1_1.value;
	                                            return [4 /*yield*/, tslib_1.__await(['delete', item])];
	                                        case 3: return [4 /*yield*/, _b.sent()];
	                                        case 4:
	                                            _b.sent();
	                                            _b.label = 5;
	                                        case 5: return [3 /*break*/, 1];
	                                        case 6: return [3 /*break*/, 13];
	                                        case 7:
	                                            e_2_1 = _b.sent();
	                                            e_2 = { error: e_2_1 };
	                                            return [3 /*break*/, 13];
	                                        case 8:
	                                            _b.trys.push([8, , 11, 12]);
	                                            if (!(items_1_1 && !items_1_1.done && (_a = items_1.return))) return [3 /*break*/, 10];
	                                            return [4 /*yield*/, tslib_1.__await(_a.call(items_1))];
	                                        case 9:
	                                            _b.sent();
	                                            _b.label = 10;
	                                        case 10: return [3 /*break*/, 12];
	                                        case 11:
	                                            if (e_2) throw e_2.error;
	                                            return [7 /*endfinally*/];
	                                        case 12: return [7 /*endfinally*/];
	                                        case 13: return [2 /*return*/];
	                                    }
	                                });
	                            });
	                        }());
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 8, 9, 14]);
	                        iter_1 = tslib_1.__asyncValues(iter);
	                        _b.label = 2;
	                    case 2: return [4 /*yield*/, tslib_1.__await(iter_1.next())];
	                    case 3:
	                        if (!(iter_1_1 = _b.sent(), !iter_1_1.done)) return [3 /*break*/, 7];
	                        written = iter_1_1.value;
	                        return [4 /*yield*/, tslib_1.__await(written[1])];
	                    case 4: return [4 /*yield*/, _b.sent()];
	                    case 5:
	                        _b.sent();
	                        _b.label = 6;
	                    case 6: return [3 /*break*/, 2];
	                    case 7: return [3 /*break*/, 14];
	                    case 8:
	                        e_1_1 = _b.sent();
	                        e_1 = { error: e_1_1 };
	                        return [3 /*break*/, 14];
	                    case 9:
	                        _b.trys.push([9, , 12, 13]);
	                        if (!(iter_1_1 && !iter_1_1.done && (_a = iter_1.return))) return [3 /*break*/, 11];
	                        return [4 /*yield*/, tslib_1.__await(_a.call(iter_1))];
	                    case 10:
	                        _b.sent();
	                        _b.label = 11;
	                    case 11: return [3 /*break*/, 13];
	                    case 12:
	                        if (e_1) throw e_1.error;
	                        return [7 /*endfinally*/];
	                    case 13: return [7 /*endfinally*/];
	                    case 14: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Retrieves items from DynamoDB in batches of 100 or fewer via one or more
	     * BatchGetItem operations. The items may be from any number of tables;
	     * tables and schemas for each item are determined using the
	     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
	     * each item supplied.
	     *
	     * This method will automatically retry any get requests returned by
	     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
	     * employed on a per-table basis.
	     *
	     * @param items A synchronous or asynchronous iterable of items to get.
	     */
	    DataMapper.prototype.batchGet = function (items, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.readConsistency, readConsistency = _c === void 0 ? this.readConsistency : _c, _d = _b.perTableOptions, perTableOptions = _d === void 0 ? {} : _d;
	        return tslib_1.__asyncGenerator(this, arguments, function batchGet_1() {
	            var e_3, _a, state, options, batch, batch_1, batch_1_1, _b, tableName, marshalled, _c, keyProperties, itemSchemata, _d, constructor, schema, e_3_1;
	            return tslib_1.__generator(this, function (_e) {
	                switch (_e.label) {
	                    case 0:
	                        state = {};
	                        options = {};
	                        batch = new dynamodb_batch_iterator_1.BatchGet(this.client, this.mapGetBatch(items, state, perTableOptions, options), {
	                            ConsistentRead: readConsistency === 'strong' ? true : undefined,
	                            PerTableOptions: options
	                        });
	                        _e.label = 1;
	                    case 1:
	                        _e.trys.push([1, 8, 9, 14]);
	                        batch_1 = tslib_1.__asyncValues(batch);
	                        _e.label = 2;
	                    case 2: return [4 /*yield*/, tslib_1.__await(batch_1.next())];
	                    case 3:
	                        if (!(batch_1_1 = _e.sent(), !batch_1_1.done)) return [3 /*break*/, 7];
	                        _b = tslib_1.__read(batch_1_1.value, 2), tableName = _b[0], marshalled = _b[1];
	                        _c = state[tableName], keyProperties = _c.keyProperties, itemSchemata = _c.itemSchemata;
	                        _d = itemSchemata[itemIdentifier(marshalled, keyProperties)], constructor = _d.constructor, schema = _d.schema;
	                        return [4 /*yield*/, tslib_1.__await(dynamodb_data_marshaller_1.unmarshallItem(schema, marshalled, constructor))];
	                    case 4: return [4 /*yield*/, _e.sent()];
	                    case 5:
	                        _e.sent();
	                        _e.label = 6;
	                    case 6: return [3 /*break*/, 2];
	                    case 7: return [3 /*break*/, 14];
	                    case 8:
	                        e_3_1 = _e.sent();
	                        e_3 = { error: e_3_1 };
	                        return [3 /*break*/, 14];
	                    case 9:
	                        _e.trys.push([9, , 12, 13]);
	                        if (!(batch_1_1 && !batch_1_1.done && (_a = batch_1.return))) return [3 /*break*/, 11];
	                        return [4 /*yield*/, tslib_1.__await(_a.call(batch_1))];
	                    case 10:
	                        _e.sent();
	                        _e.label = 11;
	                    case 11: return [3 /*break*/, 13];
	                    case 12:
	                        if (e_3) throw e_3.error;
	                        return [7 /*endfinally*/];
	                    case 13: return [7 /*endfinally*/];
	                    case 14: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Puts items into DynamoDB in batches of 25 or fewer via one or more
	     * BatchWriteItem operations. The items may be from any number of tables;
	     * tables and schemas for each item are determined using the
	     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
	     * each item supplied.
	     *
	     * This method will automatically retry any put requests returned by
	     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
	     * employed on a per-table basis.
	     *
	     * @param items A synchronous or asynchronous iterable of items to put.
	     */
	    DataMapper.prototype.batchPut = function (items) {
	        return tslib_1.__asyncGenerator(this, arguments, function batchPut_1() {
	            var e_4, _a, generator, _b, _c, written, e_4_1;
	            return tslib_1.__generator(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        generator = isIterable(items)
	                            ? function mapToPut() {
	                                var e_5, _a, items_2, items_2_1, item, e_5_1;
	                                return tslib_1.__generator(this, function (_b) {
	                                    switch (_b.label) {
	                                        case 0:
	                                            _b.trys.push([0, 5, 6, 7]);
	                                            items_2 = tslib_1.__values(items), items_2_1 = items_2.next();
	                                            _b.label = 1;
	                                        case 1:
	                                            if (!!items_2_1.done) return [3 /*break*/, 4];
	                                            item = items_2_1.value;
	                                            return [4 /*yield*/, ['put', item]];
	                                        case 2:
	                                            _b.sent();
	                                            _b.label = 3;
	                                        case 3:
	                                            items_2_1 = items_2.next();
	                                            return [3 /*break*/, 1];
	                                        case 4: return [3 /*break*/, 7];
	                                        case 5:
	                                            e_5_1 = _b.sent();
	                                            e_5 = { error: e_5_1 };
	                                            return [3 /*break*/, 7];
	                                        case 6:
	                                            try {
	                                                if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);
	                                            }
	                                            finally { if (e_5) throw e_5.error; }
	                                            return [7 /*endfinally*/];
	                                        case 7: return [2 /*return*/];
	                                    }
	                                });
	                            }()
	                            : function mapToPut() {
	                                return tslib_1.__asyncGenerator(this, arguments, function mapToPut_1() {
	                                    var e_6, _a, items_3, items_3_1, item, e_6_1;
	                                    return tslib_1.__generator(this, function (_b) {
	                                        switch (_b.label) {
	                                            case 0:
	                                                _b.trys.push([0, 7, 8, 13]);
	                                                items_3 = tslib_1.__asyncValues(items);
	                                                _b.label = 1;
	                                            case 1: return [4 /*yield*/, tslib_1.__await(items_3.next())];
	                                            case 2:
	                                                if (!(items_3_1 = _b.sent(), !items_3_1.done)) return [3 /*break*/, 6];
	                                                item = items_3_1.value;
	                                                return [4 /*yield*/, tslib_1.__await(['put', item])];
	                                            case 3: return [4 /*yield*/, _b.sent()];
	                                            case 4:
	                                                _b.sent();
	                                                _b.label = 5;
	                                            case 5: return [3 /*break*/, 1];
	                                            case 6: return [3 /*break*/, 13];
	                                            case 7:
	                                                e_6_1 = _b.sent();
	                                                e_6 = { error: e_6_1 };
	                                                return [3 /*break*/, 13];
	                                            case 8:
	                                                _b.trys.push([8, , 11, 12]);
	                                                if (!(items_3_1 && !items_3_1.done && (_a = items_3.return))) return [3 /*break*/, 10];
	                                                return [4 /*yield*/, tslib_1.__await(_a.call(items_3))];
	                                            case 9:
	                                                _b.sent();
	                                                _b.label = 10;
	                                            case 10: return [3 /*break*/, 12];
	                                            case 11:
	                                                if (e_6) throw e_6.error;
	                                                return [7 /*endfinally*/];
	                                            case 12: return [7 /*endfinally*/];
	                                            case 13: return [2 /*return*/];
	                                        }
	                                    });
	                                });
	                            }();
	                        _d.label = 1;
	                    case 1:
	                        _d.trys.push([1, 8, 9, 14]);
	                        _b = tslib_1.__asyncValues(this.batchWrite(generator));
	                        _d.label = 2;
	                    case 2: return [4 /*yield*/, tslib_1.__await(_b.next())];
	                    case 3:
	                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 7];
	                        written = _c.value;
	                        return [4 /*yield*/, tslib_1.__await(written[1])];
	                    case 4: return [4 /*yield*/, _d.sent()];
	                    case 5:
	                        _d.sent();
	                        _d.label = 6;
	                    case 6: return [3 /*break*/, 2];
	                    case 7: return [3 /*break*/, 14];
	                    case 8:
	                        e_4_1 = _d.sent();
	                        e_4 = { error: e_4_1 };
	                        return [3 /*break*/, 14];
	                    case 9:
	                        _d.trys.push([9, , 12, 13]);
	                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 11];
	                        return [4 /*yield*/, tslib_1.__await(_a.call(_b))];
	                    case 10:
	                        _d.sent();
	                        _d.label = 11;
	                    case 11: return [3 /*break*/, 13];
	                    case 12:
	                        if (e_4) throw e_4.error;
	                        return [7 /*endfinally*/];
	                    case 13: return [7 /*endfinally*/];
	                    case 14: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Puts or deletes items from DynamoDB in batches of 25 or fewer via one or
	     * more BatchWriteItem operations. The items may belong to any number of
	     * tables; tables and schemas for each item are determined using the
	     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
	     * each item supplied.
	     *
	     * This method will automatically retry any write requests returned by
	     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
	     * employed on a per-table basis.
	     *
	     * @param items A synchronous or asynchronous iterable of tuples of the
	     * string 'put'|'delete' and the item on which to perform the specified
	     * write action.
	     */
	    DataMapper.prototype.batchWrite = function (items) {
	        return tslib_1.__asyncGenerator(this, arguments, function batchWrite_1() {
	            var e_7, _a, state, batch, batch_2, batch_2_1, _b, tableName, _c, DeleteRequest, PutRequest, _d, keyProperties, itemSchemata, attributes, _e, constructor, schema, e_7_1;
	            return tslib_1.__generator(this, function (_f) {
	                switch (_f.label) {
	                    case 0:
	                        state = {};
	                        batch = new dynamodb_batch_iterator_1.BatchWrite(this.client, this.mapWriteBatch(items, state));
	                        _f.label = 1;
	                    case 1:
	                        _f.trys.push([1, 8, 9, 14]);
	                        batch_2 = tslib_1.__asyncValues(batch);
	                        _f.label = 2;
	                    case 2: return [4 /*yield*/, tslib_1.__await(batch_2.next())];
	                    case 3:
	                        if (!(batch_2_1 = _f.sent(), !batch_2_1.done)) return [3 /*break*/, 7];
	                        _b = tslib_1.__read(batch_2_1.value, 2), tableName = _b[0], _c = _b[1], DeleteRequest = _c.DeleteRequest, PutRequest = _c.PutRequest;
	                        _d = state[tableName], keyProperties = _d.keyProperties, itemSchemata = _d.itemSchemata;
	                        attributes = PutRequest
	                            ? PutRequest.Item
	                            : (DeleteRequest || { Key: {} }).Key;
	                        _e = itemSchemata[itemIdentifier(attributes, keyProperties)], constructor = _e.constructor, schema = _e.schema;
	                        return [4 /*yield*/, tslib_1.__await([
	                                PutRequest ? 'put' : 'delete',
	                                dynamodb_data_marshaller_1.unmarshallItem(schema, attributes, constructor)
	                            ])];
	                    case 4: return [4 /*yield*/, _f.sent()];
	                    case 5:
	                        _f.sent();
	                        _f.label = 6;
	                    case 6: return [3 /*break*/, 2];
	                    case 7: return [3 /*break*/, 14];
	                    case 8:
	                        e_7_1 = _f.sent();
	                        e_7 = { error: e_7_1 };
	                        return [3 /*break*/, 14];
	                    case 9:
	                        _f.trys.push([9, , 12, 13]);
	                        if (!(batch_2_1 && !batch_2_1.done && (_a = batch_2.return))) return [3 /*break*/, 11];
	                        return [4 /*yield*/, tslib_1.__await(_a.call(batch_2))];
	                    case 10:
	                        _f.sent();
	                        _f.label = 11;
	                    case 11: return [3 /*break*/, 13];
	                    case 12:
	                        if (e_7) throw e_7.error;
	                        return [7 /*endfinally*/];
	                    case 13: return [7 /*endfinally*/];
	                    case 14: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Perform a CreateTable operation using the schema accessible via the
	     * {DynamoDbSchema} property and the table name accessible via the
	     * {DynamoDbTable} property on the prototype of the constructor supplied.
	     *
	     * The promise returned by this method will not resolve until the table is
	     * active and ready for use.
	     *
	     * @param valueConstructor  The constructor used for values in the table.
	     * @param options           Options to configure the CreateTable operation
	     */
	    DataMapper.prototype.createTable = function (valueConstructor, _a) {
	        var readCapacityUnits = _a.readCapacityUnits, _b = _a.streamViewType, streamViewType = _b === void 0 ? 'NONE' : _b, writeCapacityUnits = _a.writeCapacityUnits, _c = _a.indexOptions, indexOptions = _c === void 0 ? {} : _c;
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var schema, _d, attributes, indexKeys, tableKeys, TableName, _e, TableStatus;
	            return tslib_1.__generator(this, function (_f) {
	                switch (_f.label) {
	                    case 0:
	                        schema = protocols_1.getSchema(valueConstructor.prototype);
	                        _d = dynamodb_data_marshaller_1.keysFromSchema(schema), attributes = _d.attributes, indexKeys = _d.indexKeys, tableKeys = _d.tableKeys;
	                        TableName = this.getTableName(valueConstructor.prototype);
	                        return [4 /*yield*/, this.client.createTable(tslib_1.__assign({}, indexDefinitions(indexKeys, indexOptions, schema), { TableName: TableName, ProvisionedThroughput: {
	                                    ReadCapacityUnits: readCapacityUnits,
	                                    WriteCapacityUnits: writeCapacityUnits,
	                                }, AttributeDefinitions: attributeDefinitionList(attributes), KeySchema: keyTypesToElementList(tableKeys), StreamSpecification: streamViewType === 'NONE'
	                                    ? { StreamEnabled: false }
	                                    : { StreamEnabled: true, StreamViewType: streamViewType } })).promise()];
	                    case 1:
	                        _e = (_f.sent()).TableDescription, TableStatus = (_e === void 0 ? { TableStatus: 'CREATING' } : _e).TableStatus;
	                        if (!(TableStatus !== 'ACTIVE')) return [3 /*break*/, 3];
	                        return [4 /*yield*/, this.client.waitFor('tableExists', { TableName: TableName }).promise()];
	                    case 2:
	                        _f.sent();
	                        _f.label = 3;
	                    case 3: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    DataMapper.prototype.delete = function (itemOrParameters, options) {
	        if (options === void 0) { options = {}; }
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var e_8, _a, item, condition, _b, returnValues, _c, skipVersionCheck, schema, req, _d, _e, prop, inputMember, fieldSchema, versionCondition, attributes, Attributes;
	            return tslib_1.__generator(this, function (_f) {
	                switch (_f.label) {
	                    case 0:
	                        if ('item' in itemOrParameters &&
	                            itemOrParameters.item[protocols_1.DynamoDbTable]) {
	                            item = itemOrParameters.item;
	                            options = itemOrParameters;
	                        }
	                        else {
	                            item = itemOrParameters;
	                        }
	                        condition = options.condition, _b = options.returnValues, returnValues = _b === void 0 ? 'ALL_OLD' : _b, _c = options.skipVersionCheck, skipVersionCheck = _c === void 0 ? this.skipVersionCheck : _c;
	                        schema = protocols_1.getSchema(item);
	                        req = {
	                            TableName: this.getTableName(item),
	                            Key: dynamodb_data_marshaller_1.marshallKey(schema, item),
	                            ReturnValues: returnValues,
	                        };
	                        if (!skipVersionCheck) {
	                            try {
	                                for (_d = tslib_1.__values(Object.keys(schema)), _e = _d.next(); !_e.done; _e = _d.next()) {
	                                    prop = _e.value;
	                                    inputMember = item[prop];
	                                    fieldSchema = schema[prop];
	                                    if (isVersionAttribute(fieldSchema) && inputMember !== undefined) {
	                                        versionCondition = handleVersionAttribute(prop, inputMember).condition;
	                                        condition = condition
	                                            ? { type: 'And', conditions: [condition, versionCondition] }
	                                            : versionCondition;
	                                    }
	                                }
	                            }
	                            catch (e_8_1) { e_8 = { error: e_8_1 }; }
	                            finally {
	                                try {
	                                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
	                                }
	                                finally { if (e_8) throw e_8.error; }
	                            }
	                        }
	                        if (condition) {
	                            attributes = new dynamodb_expressions_1.ExpressionAttributes();
	                            req.ConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(condition, schema, attributes).expression;
	                            if (Object.keys(attributes.names).length > 0) {
	                                req.ExpressionAttributeNames = attributes.names;
	                            }
	                            if (Object.keys(attributes.values).length > 0) {
	                                req.ExpressionAttributeValues = attributes.values;
	                            }
	                        }
	                        return [4 /*yield*/, this.client.deleteItem(req).promise()];
	                    case 1:
	                        Attributes = (_f.sent()).Attributes;
	                        if (Attributes) {
	                            return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, Attributes, item.constructor)];
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Perform a DeleteTable operation using the schema accessible via the
	     * {DynamoDbSchema} property and the table name accessible via the
	     * {DynamoDbTable} property on the prototype of the constructor supplied.
	     *
	     * The promise returned by this method will not resolve until the table is
	     * deleted and can no longer be used.
	     *
	     * @param valueConstructor  The constructor used for values in the table.
	     */
	    DataMapper.prototype.deleteTable = function (valueConstructor) {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var TableName;
	            return tslib_1.__generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        TableName = this.getTableName(valueConstructor.prototype);
	                        return [4 /*yield*/, this.client.deleteTable({ TableName: TableName }).promise()];
	                    case 1:
	                        _a.sent();
	                        return [4 /*yield*/, this.client.waitFor('tableNotExists', { TableName: TableName }).promise()];
	                    case 2:
	                        _a.sent();
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * If the table does not already exist, perform a CreateTable operation
	     * using the schema accessible via the {DynamoDbSchema} property and the
	     * table name accessible via the {DynamoDbTable} property on the prototype
	     * of the constructor supplied.
	     *
	     * The promise returned by this method will not resolve until the table is
	     * active and ready for use.
	     *
	     * @param valueConstructor  The constructor used for values in the table.
	     * @param options           Options to configure the CreateTable operation
	     */
	    DataMapper.prototype.ensureTableExists = function (valueConstructor, options) {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var TableName, _a, TableStatus, err_1;
	            return tslib_1.__generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        TableName = this.getTableName(valueConstructor.prototype);
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 5, , 9]);
	                        return [4 /*yield*/, this.client.describeTable({ TableName: TableName }).promise()];
	                    case 2:
	                        _a = (_b.sent()).Table, TableStatus = (_a === void 0 ? { TableStatus: 'CREATING' } : _a).TableStatus;
	                        if (!(TableStatus !== 'ACTIVE')) return [3 /*break*/, 4];
	                        return [4 /*yield*/, this.client.waitFor('tableExists', { TableName: TableName }).promise()];
	                    case 3:
	                        _b.sent();
	                        _b.label = 4;
	                    case 4: return [3 /*break*/, 9];
	                    case 5:
	                        err_1 = _b.sent();
	                        if (!(err_1.name === 'ResourceNotFoundException')) return [3 /*break*/, 7];
	                        return [4 /*yield*/, this.createTable(valueConstructor, options)];
	                    case 6:
	                        _b.sent();
	                        return [3 /*break*/, 8];
	                    case 7: throw err_1;
	                    case 8: return [3 /*break*/, 9];
	                    case 9: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * If the table exists, perform a DeleteTable operation using the schema
	     * accessible via the {DynamoDbSchema} property and the table name
	     * accessible via the {DynamoDbTable} property on the prototype of the
	     * constructor supplied.
	     *
	     * The promise returned by this method will not resolve until the table is
	     * deleted and can no longer be used.
	     *
	     * @param valueConstructor  The constructor used for values in the table.
	     */
	    DataMapper.prototype.ensureTableNotExists = function (valueConstructor) {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var TableName, _a, status, err_2;
	            return tslib_1.__generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        TableName = this.getTableName(valueConstructor.prototype);
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 8, , 9]);
	                        return [4 /*yield*/, this.client.describeTable({ TableName: TableName }).promise()];
	                    case 2:
	                        _a = (_b.sent()).Table, status = (_a === void 0 ? { TableStatus: 'CREATING' } : _a).TableStatus;
	                        if (!(status === 'DELETING')) return [3 /*break*/, 4];
	                        return [4 /*yield*/, this.client.waitFor('tableNotExists', { TableName: TableName })
	                                .promise()];
	                    case 3:
	                        _b.sent();
	                        return [2 /*return*/];
	                    case 4:
	                        if (!(status === 'CREATING' || status === 'UPDATING')) return [3 /*break*/, 6];
	                        return [4 /*yield*/, this.client.waitFor('tableExists', { TableName: TableName })
	                                .promise()];
	                    case 5:
	                        _b.sent();
	                        _b.label = 6;
	                    case 6: return [4 /*yield*/, this.deleteTable(valueConstructor)];
	                    case 7:
	                        _b.sent();
	                        return [3 /*break*/, 9];
	                    case 8:
	                        err_2 = _b.sent();
	                        if (err_2.name !== 'ResourceNotFoundException') {
	                            throw err_2;
	                        }
	                        return [3 /*break*/, 9];
	                    case 9: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    DataMapper.prototype.get = function (itemOrParameters, options) {
	        if (options === void 0) { options = {}; }
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var item, projection, _a, readConsistency, schema, req, attributes, Item;
	            return tslib_1.__generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        if ('item' in itemOrParameters &&
	                            itemOrParameters.item[protocols_1.DynamoDbTable]) {
	                            item = itemOrParameters.item;
	                            options = itemOrParameters;
	                        }
	                        else {
	                            item = itemOrParameters;
	                        }
	                        projection = options.projection, _a = options.readConsistency, readConsistency = _a === void 0 ? this.readConsistency : _a;
	                        schema = protocols_1.getSchema(item);
	                        req = {
	                            TableName: this.getTableName(item),
	                            Key: dynamodb_data_marshaller_1.marshallKey(schema, item)
	                        };
	                        if (readConsistency === 'strong') {
	                            req.ConsistentRead = true;
	                        }
	                        if (projection) {
	                            attributes = new dynamodb_expressions_1.ExpressionAttributes();
	                            req.ProjectionExpression = dynamodb_expressions_1.serializeProjectionExpression(projection.map(function (propName) { return dynamodb_data_marshaller_1.toSchemaName(propName, schema); }), attributes);
	                            if (Object.keys(attributes.names).length > 0) {
	                                req.ExpressionAttributeNames = attributes.names;
	                            }
	                        }
	                        return [4 /*yield*/, this.client.getItem(req).promise()];
	                    case 1:
	                        Item = (_b.sent()).Item;
	                        if (Item) {
	                            return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, Item, item.constructor)];
	                        }
	                        throw new ItemNotFoundException_1.ItemNotFoundException(req);
	                }
	            });
	        });
	    };
	    DataMapper.prototype.parallelScan = function (ctorOrParams, segments, options) {
	        if (options === void 0) { options = {}; }
	        var valueConstructor;
	        if (typeof segments !== 'number') {
	            valueConstructor = ctorOrParams.valueConstructor;
	            segments = ctorOrParams.segments;
	            options = ctorOrParams;
	        }
	        else {
	            valueConstructor = ctorOrParams;
	        }
	        return new ParallelScanIterator_1.ParallelScanIterator(this.client, valueConstructor, segments, tslib_1.__assign({ readConsistency: this.readConsistency }, options, { tableNamePrefix: this.tableNamePrefix }));
	    };
	    DataMapper.prototype.put = function (itemOrParameters, options) {
	        if (options === void 0) { options = {}; }
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var e_9, _a, item, condition, _b, skipVersionCheck, schema, req, _c, _d, key, inputMember, fieldSchema, _e, attributeName, versionCond, attributes;
	            return tslib_1.__generator(this, function (_f) {
	                switch (_f.label) {
	                    case 0:
	                        if ('item' in itemOrParameters &&
	                            itemOrParameters.item[protocols_1.DynamoDbTable]) {
	                            item = itemOrParameters.item;
	                            options = itemOrParameters;
	                        }
	                        else {
	                            item = itemOrParameters;
	                        }
	                        condition = options.condition, _b = options.skipVersionCheck, skipVersionCheck = _b === void 0 ? this.skipVersionCheck : _b;
	                        schema = protocols_1.getSchema(item);
	                        req = {
	                            TableName: this.getTableName(item),
	                            Item: dynamodb_data_marshaller_1.marshallItem(schema, item),
	                        };
	                        if (!skipVersionCheck) {
	                            try {
	                                for (_c = tslib_1.__values(Object.keys(schema)), _d = _c.next(); !_d.done; _d = _c.next()) {
	                                    key = _d.value;
	                                    inputMember = item[key];
	                                    fieldSchema = schema[key];
	                                    _e = fieldSchema.attributeName, attributeName = _e === void 0 ? key : _e;
	                                    if (isVersionAttribute(fieldSchema)) {
	                                        versionCond = handleVersionAttribute(key, inputMember).condition;
	                                        if (req.Item[attributeName]) {
	                                            req.Item[attributeName].N = (Number(req.Item[attributeName].N) + 1).toString();
	                                        }
	                                        else {
	                                            req.Item[attributeName] = { N: "0" };
	                                        }
	                                        condition = condition
	                                            ? { type: 'And', conditions: [condition, versionCond] }
	                                            : versionCond;
	                                    }
	                                }
	                            }
	                            catch (e_9_1) { e_9 = { error: e_9_1 }; }
	                            finally {
	                                try {
	                                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                                }
	                                finally { if (e_9) throw e_9.error; }
	                            }
	                        }
	                        if (condition) {
	                            attributes = new dynamodb_expressions_1.ExpressionAttributes();
	                            req.ConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(condition, schema, attributes).expression;
	                            if (Object.keys(attributes.names).length > 0) {
	                                req.ExpressionAttributeNames = attributes.names;
	                            }
	                            if (Object.keys(attributes.values).length > 0) {
	                                req.ExpressionAttributeValues = attributes.values;
	                            }
	                        }
	                        return [4 /*yield*/, this.client.putItem(req).promise()];
	                    case 1:
	                        _f.sent();
	                        return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, req.Item, item.constructor)];
	                }
	            });
	        });
	    };
	    DataMapper.prototype.query = function (valueConstructorOrParameters, keyCondition, options) {
	        if (options === void 0) { options = {}; }
	        var valueConstructor;
	        if (!keyCondition) {
	            valueConstructor = valueConstructorOrParameters.valueConstructor;
	            keyCondition = valueConstructorOrParameters.keyCondition;
	            options = valueConstructorOrParameters;
	        }
	        else {
	            valueConstructor = valueConstructorOrParameters;
	        }
	        return new QueryIterator_1.QueryIterator(this.client, valueConstructor, keyCondition, tslib_1.__assign({ readConsistency: this.readConsistency }, options, { tableNamePrefix: this.tableNamePrefix }));
	    };
	    DataMapper.prototype.scan = function (ctorOrParams, options) {
	        if (options === void 0) { options = {}; }
	        var valueConstructor;
	        if ('valueConstructor' in ctorOrParams &&
	            ctorOrParams.valueConstructor.prototype &&
	            ctorOrParams.valueConstructor.prototype[protocols_1.DynamoDbTable]) {
	            valueConstructor = ctorOrParams.valueConstructor;
	            options = ctorOrParams;
	        }
	        else {
	            valueConstructor = ctorOrParams;
	        }
	        return new ScanIterator_1.ScanIterator(this.client, valueConstructor, tslib_1.__assign({ readConsistency: this.readConsistency }, options, { tableNamePrefix: this.tableNamePrefix }));
	    };
	    DataMapper.prototype.update = function (itemOrParameters, options) {
	        if (options === void 0) { options = {}; }
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var e_10, _a, item, condition, _b, onMissing, _c, skipVersionCheck, schema, expr, itemKey, _d, _e, key, inputMember, fieldSchema, _f, versionCond, value, marshalled;
	            return tslib_1.__generator(this, function (_g) {
	                if ('item' in itemOrParameters &&
	                    itemOrParameters.item[protocols_1.DynamoDbTable]) {
	                    item = itemOrParameters.item;
	                    options = itemOrParameters;
	                }
	                else {
	                    item = itemOrParameters;
	                }
	                condition = options.condition, _b = options.onMissing, onMissing = _b === void 0 ? 'remove' : _b, _c = options.skipVersionCheck, skipVersionCheck = _c === void 0 ? this.skipVersionCheck : _c;
	                schema = protocols_1.getSchema(item);
	                expr = new dynamodb_expressions_1.UpdateExpression();
	                itemKey = {};
	                try {
	                    for (_d = tslib_1.__values(Object.keys(schema)), _e = _d.next(); !_e.done; _e = _d.next()) {
	                        key = _e.value;
	                        inputMember = item[key];
	                        fieldSchema = schema[key];
	                        if (dynamodb_data_marshaller_1.isKey(fieldSchema)) {
	                            itemKey[key] = inputMember;
	                        }
	                        else if (isVersionAttribute(fieldSchema)) {
	                            _f = handleVersionAttribute(key, inputMember), versionCond = _f.condition, value = _f.value;
	                            expr.set(key, value);
	                            if (!skipVersionCheck) {
	                                condition = condition
	                                    ? { type: 'And', conditions: [condition, versionCond] }
	                                    : versionCond;
	                            }
	                        }
	                        else if (inputMember === undefined) {
	                            if (onMissing === 'remove') {
	                                expr.remove(key);
	                            }
	                        }
	                        else {
	                            marshalled = dynamodb_data_marshaller_1.marshallValue(fieldSchema, inputMember);
	                            if (marshalled) {
	                                expr.set(key, new dynamodb_expressions_1.AttributeValue(marshalled));
	                            }
	                        }
	                    }
	                }
	                catch (e_10_1) { e_10 = { error: e_10_1 }; }
	                finally {
	                    try {
	                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
	                    }
	                    finally { if (e_10) throw e_10.error; }
	                }
	                return [2 /*return*/, this.doExecuteUpdateExpression(expr, itemKey, protocols_1.getSchema(item), protocols_1.getTableName(item), item.constructor, { condition: condition })];
	            });
	        });
	    };
	    /**
	     * Execute a custom update expression using the schema and table name
	     * defined on the provided `valueConstructor`.
	     *
	     * This method does not support automatic version checking, as the current
	     * state of a table's version attribute cannot be inferred from an update
	     * expression object. To perform a version check manually, add a condition
	     * expression:
	     *
	     * ```typescript
	     *  const currentVersion = 1;
	     *  updateExpression.set('nameOfVersionAttribute', currentVersion + 1);
	     *  const condition = {
	     *      type: 'Equals',
	     *      subject: 'nameOfVersionAttribute',
	     *      object: currentVersion
	     *  };
	     *
	     *  const updated = await mapper.executeUpdateExpression(
	     *      updateExpression,
	     *      itemKey,
	     *      constructor,
	     *      {condition}
	     *  );
	     * ```
	     *
	     * **NB:** Property names and attribute paths in the update expression
	     * should reflect the names used in the schema.
	     *
	     * @param expression        The update expression to execute.
	     * @param key               The full key to identify the object being
	     *                          updated.
	     * @param valueConstructor  The constructor with which to map the result to
	     *                          a domain object.
	     * @param options           Options with which to customize the UpdateItem
	     *                          request.
	     *
	     * @returns The updated item.
	     */
	    DataMapper.prototype.executeUpdateExpression = function (expression, key, valueConstructor, options) {
	        if (options === void 0) { options = {}; }
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            return tslib_1.__generator(this, function (_a) {
	                return [2 /*return*/, this.doExecuteUpdateExpression(expression, key, protocols_1.getSchema(valueConstructor.prototype), protocols_1.getTableName(valueConstructor.prototype), valueConstructor, options)];
	            });
	        });
	    };
	    DataMapper.prototype.doExecuteUpdateExpression = function (expression, key, schema, tableName, valueConstructor, options) {
	        if (options === void 0) { options = {}; }
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var req, attributes, rawResponse;
	            return tslib_1.__generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        req = {
	                            TableName: this.tableNamePrefix + tableName,
	                            ReturnValues: 'ALL_NEW',
	                            Key: dynamodb_data_marshaller_1.marshallKey(schema, key),
	                        };
	                        attributes = new dynamodb_expressions_1.ExpressionAttributes();
	                        if (options.condition) {
	                            req.ConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(options.condition, schema, attributes).expression;
	                        }
	                        req.UpdateExpression = dynamodb_data_marshaller_1.marshallUpdateExpression(expression, schema, attributes).expression;
	                        if (Object.keys(attributes.names).length > 0) {
	                            req.ExpressionAttributeNames = attributes.names;
	                        }
	                        if (Object.keys(attributes.values).length > 0) {
	                            req.ExpressionAttributeValues = attributes.values;
	                        }
	                        return [4 /*yield*/, this.client.updateItem(req).promise()];
	                    case 1:
	                        rawResponse = _a.sent();
	                        if (rawResponse.Attributes) {
	                            return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, rawResponse.Attributes, valueConstructor)];
	                        }
	                        // this branch should not be reached when interacting with DynamoDB, as
	                        // the ReturnValues parameter is hardcoded to 'ALL_NEW' above. It is,
	                        // however, allowed by the service model and may therefore occur in
	                        // certain unforeseen conditions; to be safe, this case should be
	                        // converted into an error unless a compelling reason to return
	                        // undefined or an empty object presents itself.
	                        throw new Error('Update operation completed successfully, but the updated value was not returned');
	                }
	            });
	        });
	    };
	    DataMapper.prototype.getTableName = function (item) {
	        return protocols_1.getTableName(item, this.tableNamePrefix);
	    };
	    DataMapper.prototype.mapGetBatch = function (items, state, options, convertedOptions) {
	        return tslib_1.__asyncGenerator(this, arguments, function mapGetBatch_1() {
	            var e_11, _a, items_4, items_4_1, item, unprefixed, tableName, schema, _b, keyProperties, itemSchemata, marshalled, e_11_1;
	            return tslib_1.__generator(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        _c.trys.push([0, 7, 8, 13]);
	                        items_4 = tslib_1.__asyncValues(items);
	                        _c.label = 1;
	                    case 1: return [4 /*yield*/, tslib_1.__await(items_4.next())];
	                    case 2:
	                        if (!(items_4_1 = _c.sent(), !items_4_1.done)) return [3 /*break*/, 6];
	                        item = items_4_1.value;
	                        unprefixed = protocols_1.getTableName(item);
	                        tableName = this.tableNamePrefix + unprefixed;
	                        schema = protocols_1.getSchema(item);
	                        if (unprefixed in options && !(tableName in convertedOptions)) {
	                            convertedOptions[tableName] = convertBatchGetOptions(options[unprefixed], schema);
	                        }
	                        if (!(tableName in state)) {
	                            state[tableName] = {
	                                keyProperties: getKeyProperties(schema),
	                                itemSchemata: {}
	                            };
	                        }
	                        _b = state[tableName], keyProperties = _b.keyProperties, itemSchemata = _b.itemSchemata;
	                        marshalled = dynamodb_data_marshaller_1.marshallKey(schema, item);
	                        itemSchemata[itemIdentifier(marshalled, keyProperties)] = {
	                            constructor: item.constructor,
	                            schema: schema,
	                        };
	                        return [4 /*yield*/, tslib_1.__await([tableName, marshalled])];
	                    case 3: return [4 /*yield*/, _c.sent()];
	                    case 4:
	                        _c.sent();
	                        _c.label = 5;
	                    case 5: return [3 /*break*/, 1];
	                    case 6: return [3 /*break*/, 13];
	                    case 7:
	                        e_11_1 = _c.sent();
	                        e_11 = { error: e_11_1 };
	                        return [3 /*break*/, 13];
	                    case 8:
	                        _c.trys.push([8, , 11, 12]);
	                        if (!(items_4_1 && !items_4_1.done && (_a = items_4.return))) return [3 /*break*/, 10];
	                        return [4 /*yield*/, tslib_1.__await(_a.call(items_4))];
	                    case 9:
	                        _c.sent();
	                        _c.label = 10;
	                    case 10: return [3 /*break*/, 12];
	                    case 11:
	                        if (e_11) throw e_11.error;
	                        return [7 /*endfinally*/];
	                    case 12: return [7 /*endfinally*/];
	                    case 13: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    DataMapper.prototype.mapWriteBatch = function (items, state) {
	        return tslib_1.__asyncGenerator(this, arguments, function mapWriteBatch_1() {
	            var e_12, _a, items_5, items_5_1, _b, type, item, unprefixed, tableName, schema, _c, keyProperties, itemSchemata, attributes, marshalled, e_12_1;
	            return tslib_1.__generator(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        _d.trys.push([0, 7, 8, 13]);
	                        items_5 = tslib_1.__asyncValues(items);
	                        _d.label = 1;
	                    case 1: return [4 /*yield*/, tslib_1.__await(items_5.next())];
	                    case 2:
	                        if (!(items_5_1 = _d.sent(), !items_5_1.done)) return [3 /*break*/, 6];
	                        _b = tslib_1.__read(items_5_1.value, 2), type = _b[0], item = _b[1];
	                        unprefixed = protocols_1.getTableName(item);
	                        tableName = this.tableNamePrefix + unprefixed;
	                        schema = protocols_1.getSchema(item);
	                        if (!(tableName in state)) {
	                            state[tableName] = {
	                                keyProperties: getKeyProperties(schema),
	                                itemSchemata: {}
	                            };
	                        }
	                        _c = state[tableName], keyProperties = _c.keyProperties, itemSchemata = _c.itemSchemata;
	                        attributes = type === 'delete'
	                            ? dynamodb_data_marshaller_1.marshallKey(schema, item)
	                            : dynamodb_data_marshaller_1.marshallItem(schema, item);
	                        marshalled = type === 'delete'
	                            ? { DeleteRequest: { Key: attributes } }
	                            : { PutRequest: { Item: attributes } };
	                        itemSchemata[itemIdentifier(attributes, keyProperties)] = {
	                            constructor: item.constructor,
	                            schema: schema,
	                        };
	                        return [4 /*yield*/, tslib_1.__await([tableName, marshalled])];
	                    case 3: return [4 /*yield*/, _d.sent()];
	                    case 4:
	                        _d.sent();
	                        _d.label = 5;
	                    case 5: return [3 /*break*/, 1];
	                    case 6: return [3 /*break*/, 13];
	                    case 7:
	                        e_12_1 = _d.sent();
	                        e_12 = { error: e_12_1 };
	                        return [3 /*break*/, 13];
	                    case 8:
	                        _d.trys.push([8, , 11, 12]);
	                        if (!(items_5_1 && !items_5_1.done && (_a = items_5.return))) return [3 /*break*/, 10];
	                        return [4 /*yield*/, tslib_1.__await(_a.call(items_5))];
	                    case 9:
	                        _d.sent();
	                        _d.label = 10;
	                    case 10: return [3 /*break*/, 12];
	                    case 11:
	                        if (e_12) throw e_12.error;
	                        return [7 /*endfinally*/];
	                    case 12: return [7 /*endfinally*/];
	                    case 13: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    return DataMapper;
	}());
	exports.DataMapper = DataMapper;
	function attributeDefinitionList(attributes) {
	    return Object.keys(attributes).map(function (name) { return ({
	        AttributeName: name,
	        AttributeType: attributes[name]
	    }); });
	}
	function convertBatchGetOptions(options, itemSchema) {
	    var out = {};
	    if (options.readConsistency === 'strong') {
	        out.ConsistentRead = true;
	    }
	    if (options.projection) {
	        var attributes = new dynamodb_expressions_1.ExpressionAttributes();
	        out.ProjectionExpression = dynamodb_expressions_1.serializeProjectionExpression(options.projection.map(function (propName) { return dynamodb_data_marshaller_1.toSchemaName(propName, options.projectionSchema || itemSchema); }), attributes);
	        out.ExpressionAttributeNames = attributes.names;
	    }
	    return out;
	}
	function getKeyProperties(schema) {
	    var e_13, _a;
	    var keys = [];
	    try {
	        for (var _b = tslib_1.__values(Object.keys(schema).sort()), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var property = _c.value;
	            var fieldSchema = schema[property];
	            if (dynamodb_data_marshaller_1.isKey(fieldSchema)) {
	                keys.push(fieldSchema.attributeName || property);
	            }
	        }
	    }
	    catch (e_13_1) { e_13 = { error: e_13_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_13) throw e_13.error; }
	    }
	    return keys;
	}
	function handleVersionAttribute(attributeName, inputMember) {
	    var condition;
	    var value;
	    if (inputMember === undefined) {
	        condition = new dynamodb_expressions_1.FunctionExpression('attribute_not_exists', new dynamodb_expressions_1.AttributePath([
	            { type: 'AttributeName', name: attributeName }
	        ]));
	        value = new dynamodb_expressions_1.AttributeValue({ N: "0" });
	    }
	    else {
	        condition = {
	            type: 'Equals',
	            subject: attributeName,
	            object: inputMember,
	        };
	        value = new dynamodb_expressions_1.MathematicalExpression(new dynamodb_expressions_1.AttributePath(attributeName), '+', 1);
	    }
	    return { condition: condition, value: value };
	}
	function indexDefinitions(keys, options, schema) {
	    var e_14, _a;
	    var globalIndices = [];
	    var localIndices = [];
	    try {
	        for (var _b = tslib_1.__values(Object.keys(keys)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var IndexName = _c.value;
	            var KeySchema = keyTypesToElementList(keys[IndexName]);
	            var indexOptions = options[IndexName];
	            if (!indexOptions) {
	                throw new Error("No options provided for " + IndexName + " index");
	            }
	            var indexInfo = {
	                IndexName: IndexName,
	                KeySchema: KeySchema,
	                Projection: indexProjection(schema, indexOptions.projection),
	            };
	            if (indexOptions.type === 'local') {
	                localIndices.push(indexInfo);
	            }
	            else {
	                globalIndices.push(tslib_1.__assign({}, indexInfo, { ProvisionedThroughput: {
	                        ReadCapacityUnits: indexOptions.readCapacityUnits,
	                        WriteCapacityUnits: indexOptions.writeCapacityUnits,
	                    } }));
	            }
	        }
	    }
	    catch (e_14_1) { e_14 = { error: e_14_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_14) throw e_14.error; }
	    }
	    return {
	        GlobalSecondaryIndexes: globalIndices.length ? globalIndices : void 0,
	        LocalSecondaryIndexes: localIndices.length ? localIndices : void 0,
	    };
	}
	function indexProjection(schema, projection) {
	    if (typeof projection === 'string') {
	        return {
	            ProjectionType: projection === 'all' ? 'ALL' : 'KEYS_ONLY',
	        };
	    }
	    return {
	        ProjectionType: 'INCLUDE',
	        NonKeyAttributes: projection.map(function (propName) { return dynamodb_data_marshaller_1.getSchemaName(propName, schema); })
	    };
	}
	function isIterable(arg) {
	    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
	}
	function isVersionAttribute(fieldSchema) {
	    return fieldSchema.type === 'Number'
	        && Boolean(fieldSchema.versionAttribute);
	}
	function itemIdentifier(marshalled, keyProperties) {
	    var e_15, _a;
	    var keyAttributes = [];
	    try {
	        for (var keyProperties_1 = tslib_1.__values(keyProperties), keyProperties_1_1 = keyProperties_1.next(); !keyProperties_1_1.done; keyProperties_1_1 = keyProperties_1.next()) {
	            var key = keyProperties_1_1.value;
	            var value = marshalled[key];
	            key + "=" + (value.B || value.N || value.S);
	        }
	    }
	    catch (e_15_1) { e_15 = { error: e_15_1 }; }
	    finally {
	        try {
	            if (keyProperties_1_1 && !keyProperties_1_1.done && (_a = keyProperties_1.return)) _a.call(keyProperties_1);
	        }
	        finally { if (e_15) throw e_15.error; }
	    }
	    return keyAttributes.join(':');
	}
	function keyTypesToElementList(keys) {
	    return Object.keys(keys).map(function (name) { return ({
	        AttributeName: name,
	        KeyType: keys[name]
	    }); });
	}
	//# sourceMappingURL=DataMapper.js.map

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	/**
	 * An exception thrown when an item was sought with a DynamoDB::GetItem
	 * request and not found. Includes the original request sent as
	 * `itemSought`.
	 */
	var ItemNotFoundException = /** @class */ (function (_super) {
	    tslib_1.__extends(ItemNotFoundException, _super);
	    function ItemNotFoundException(itemSought, message) {
	        if (message === void 0) { message = defaultErrorMessage(itemSought); }
	        var _this = _super.call(this, message) || this;
	        _this.itemSought = itemSought;
	        _this.name = 'ItemNotFoundException';
	        return _this;
	    }
	    return ItemNotFoundException;
	}(Error));
	exports.ItemNotFoundException = ItemNotFoundException;
	function defaultErrorMessage(itemSought) {
	    return "No item with the key " + JSON.stringify(itemSought.Key) + " found in the " + itemSought.TableName + " table.";
	}
	//# sourceMappingURL=ItemNotFoundException.js.map

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var Iterator_1 = __webpack_require__(101);
	var ParallelScanPaginator_1 = __webpack_require__(103);
	/**
	 * Iterates over each item returned by a parallel DynamoDB scan until no more
	 * pages are available.
	 */
	var ParallelScanIterator = /** @class */ (function (_super) {
	    tslib_1.__extends(ParallelScanIterator, _super);
	    function ParallelScanIterator(client, itemConstructor, segments, options) {
	        if (options === void 0) { options = {}; }
	        return _super.call(this, new ParallelScanPaginator_1.ParallelScanPaginator(client, itemConstructor, segments, options)) || this;
	    }
	    return ParallelScanIterator;
	}(Iterator_1.Iterator));
	exports.ParallelScanIterator = ParallelScanIterator;
	//# sourceMappingURL=ParallelScanIterator.js.map

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	__webpack_require__(102);
	var Iterator = /** @class */ (function () {
	    function Iterator(paginator) {
	        this.paginator = paginator;
	        this._count = 0;
	        this.lastResolved = Promise.resolve();
	        this.pending = [];
	    }
	    /**
	     * @inheritDoc
	     */
	    Iterator.prototype[Symbol.asyncIterator] = function () {
	        return this;
	    };
	    /**
	     * @inheritDoc
	     */
	    Iterator.prototype.next = function () {
	        var _this = this;
	        this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
	        return this.lastResolved;
	    };
	    /**
	     * Detaches the underlying paginator from this iterator and returns it. The
	     * paginator will yield arrays of unmarshalled items, with each yielded
	     * array corresponding to a single call to the underlying API. As with the
	     * underlying API, pages may contain a variable number of items or no items,
	     * in which case an empty array will be yielded.
	     *
	     * Calling this method will disable further iteration.
	     */
	    Iterator.prototype.pages = function () {
	        // Prevent the iterator from being used further and squelch any uncaught
	        // promise rejection warnings
	        this.lastResolved = Promise.reject(new Error('The underlying paginator has been detached from this iterator.'));
	        this.lastResolved.catch(function () { });
	        return this.paginator;
	    };
	    /**
	     * @inheritDoc
	     */
	    Iterator.prototype.return = function () {
	        // Prevent any further use of this iterator
	        this.lastResolved = Promise.reject(new Error('Iteration has been manually interrupted and may not be resumed'));
	        this.lastResolved.catch(function () { });
	        // Empty the pending queue to free up memory
	        this.pending.length = 0;
	        return this.paginator.return();
	    };
	    Object.defineProperty(Iterator.prototype, "consumedCapacity", {
	        /**
	         * Retrieve the reported capacity consumed by this iterator. Will be
	         * undefined unless returned consumed capacity is requested.
	         */
	        get: function () {
	            return this.paginator.consumedCapacity;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Iterator.prototype, "count", {
	        /**
	         * Retrieve the number of items yielded thus far by this iterator.
	         */
	        get: function () {
	            return this._count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Iterator.prototype, "scannedCount", {
	        /**
	         * Retrieve the number of items scanned thus far during the execution of
	         * this iterator. This number should be the same as {@link count} unless a
	         * filter expression was used.
	         */
	        get: function () {
	            return this.paginator.scannedCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Iterator.prototype.getNext = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var _this = this;
	            return tslib_1.__generator(this, function (_a) {
	                if (this.pending.length > 0) {
	                    this.lastYielded = this.pending.shift();
	                    this._count++;
	                    return [2 /*return*/, {
	                            done: false,
	                            value: this.lastYielded
	                        }];
	                }
	                return [2 /*return*/, this.paginator.next().then(function (_a) {
	                        var _b = _a.value, value = _b === void 0 ? [] : _b, done = _a.done;
	                        var _c;
	                        if (!done) {
	                            (_c = _this.pending).push.apply(_c, tslib_1.__spread(value));
	                            return _this.getNext();
	                        }
	                        _this.lastYielded = undefined;
	                        return { done: true };
	                    })];
	            });
	        });
	    };
	    return Iterator;
	}());
	exports.Iterator = Iterator;
	//# sourceMappingURL=Iterator.js.map

/***/ }),
/* 102 */
/***/ (function(module, exports) {

	"use strict";
	/**
	 * Provides a simple polyfill for runtime environments that provide a Symbol
	 * implementation but do not have Symbol.asyncIterator available by default.
	 */
	if (Symbol && !Symbol.asyncIterator) {
	    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
	}
	//# sourceMappingURL=asyncIteratorSymbolPolyfill.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var buildScanInput_1 = __webpack_require__(104);
	var Paginator_1 = __webpack_require__(136);
	var protocols_1 = __webpack_require__(135);
	var dynamodb_query_iterator_1 = __webpack_require__(137);
	var dynamodb_data_marshaller_1 = __webpack_require__(106);
	/**
	 * Iterates over each page of items returned by a parallel DynamoDB scan until
	 * no more pages are available.
	 */
	var ParallelScanPaginator = /** @class */ (function (_super) {
	    tslib_1.__extends(ParallelScanPaginator, _super);
	    function ParallelScanPaginator(client, itemConstructor, segments, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        var schema = protocols_1.getSchema(itemConstructor.prototype);
	        var input = tslib_1.__assign({}, buildScanInput_1.buildScanInput(itemConstructor, options), { TotalSegments: segments, ExclusiveStartKey: undefined, Segment: undefined });
	        var scanState;
	        if (options.scanState) {
	            scanState = options.scanState.map(function (_a) {
	                var initialized = _a.initialized, lastKey = _a.lastEvaluatedKey;
	                return ({
	                    initialized: initialized,
	                    LastEvaluatedKey: lastKey
	                        ? dynamodb_data_marshaller_1.marshallKey(schema, lastKey, options.indexName)
	                        : undefined
	                });
	            });
	        }
	        var paginator = new dynamodb_query_iterator_1.ParallelScanPaginator(client, input, scanState);
	        _this = _super.call(this, paginator, itemConstructor) || this;
	        _this._paginator = paginator;
	        _this._ctor = itemConstructor;
	        _this._schema = schema;
	        return _this;
	    }
	    Object.defineProperty(ParallelScanPaginator.prototype, "lastEvaluatedKey", {
	        /**
	         * The `lastEvaluatedKey` attribute is not available on parallel scans. Use
	         * {@link scanState} instead.
	         */
	        get: function () {
	            return undefined;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParallelScanPaginator.prototype, "scanState", {
	        /**
	         * A snapshot of the current state of a parallel scan. May be used to resume
	         * a parallel scan with a separate paginator.
	         */
	        get: function () {
	            var _this = this;
	            return this._paginator.scanState.map(function (_a) {
	                var initialized = _a.initialized, LastEvaluatedKey = _a.LastEvaluatedKey;
	                return ({
	                    initialized: initialized,
	                    lastEvaluatedKey: LastEvaluatedKey
	                        ? dynamodb_data_marshaller_1.unmarshallItem(_this._schema, LastEvaluatedKey, _this._ctor)
	                        : undefined
	                });
	            });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ParallelScanPaginator;
	}(Paginator_1.Paginator));
	exports.ParallelScanPaginator = ParallelScanPaginator;
	//# sourceMappingURL=ParallelScanPaginator.js.map

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var marshallStartKey_1 = __webpack_require__(105);
	var protocols_1 = __webpack_require__(135);
	var dynamodb_data_marshaller_1 = __webpack_require__(106);
	var dynamodb_expressions_1 = __webpack_require__(113);
	/**
	 * @internal
	 */
	function buildScanInput(valueConstructor, options) {
	    if (options === void 0) { options = {}; }
	    var filter = options.filter, indexName = options.indexName, pageSize = options.pageSize, projection = options.projection, readConsistency = options.readConsistency, segment = options.segment, startKey = options.startKey, prefix = options.tableNamePrefix, totalSegments = options.totalSegments;
	    var req = {
	        TableName: protocols_1.getTableName(valueConstructor.prototype, prefix),
	        Limit: pageSize,
	        IndexName: indexName,
	        Segment: segment,
	        TotalSegments: totalSegments,
	    };
	    if (readConsistency === 'strong') {
	        req.ConsistentRead = true;
	    }
	    var schema = protocols_1.getSchema(valueConstructor.prototype);
	    var attributes = new dynamodb_expressions_1.ExpressionAttributes();
	    if (filter) {
	        req.FilterExpression = dynamodb_data_marshaller_1.marshallConditionExpression(filter, schema, attributes).expression;
	    }
	    if (projection) {
	        req.ProjectionExpression = dynamodb_data_marshaller_1.marshallProjectionExpression(projection, schema, attributes).expression;
	    }
	    if (Object.keys(attributes.names).length > 0) {
	        req.ExpressionAttributeNames = attributes.names;
	    }
	    if (Object.keys(attributes.values).length > 0) {
	        req.ExpressionAttributeValues = attributes.values;
	    }
	    if (startKey) {
	        req.ExclusiveStartKey = marshallStartKey_1.marshallStartKey(schema, startKey);
	    }
	    return req;
	}
	exports.buildScanInput = buildScanInput;
	//# sourceMappingURL=buildScanInput.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var dynamodb_data_marshaller_1 = __webpack_require__(106);
	/**
	 * @internal
	 */
	function marshallStartKey(schema, startKey) {
	    var e_1, _a;
	    var key = {};
	    try {
	        for (var _b = tslib_1.__values(Object.keys(startKey)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var propertyName = _c.value;
	            var propSchema = schema[propertyName];
	            var _d = propSchema.attributeName, attributeName = _d === void 0 ? propertyName : _d;
	            if (propSchema) {
	                key[attributeName] = dynamodb_data_marshaller_1.marshallValue(propSchema, startKey[propertyName]);
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return key;
	}
	exports.marshallStartKey = marshallStartKey;
	//# sourceMappingURL=marshallStartKey.js.map

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	tslib_1.__exportStar(__webpack_require__(107), exports);
	tslib_1.__exportStar(__webpack_require__(108), exports);
	tslib_1.__exportStar(__webpack_require__(109), exports);
	tslib_1.__exportStar(__webpack_require__(110), exports);
	tslib_1.__exportStar(__webpack_require__(111), exports);
	tslib_1.__exportStar(__webpack_require__(129), exports);
	tslib_1.__exportStar(__webpack_require__(131), exports);
	tslib_1.__exportStar(__webpack_require__(132), exports);
	tslib_1.__exportStar(__webpack_require__(133), exports);
	tslib_1.__exportStar(__webpack_require__(112), exports);
	tslib_1.__exportStar(__webpack_require__(134), exports);
	//# sourceMappingURL=index.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	/**
	 * An error thrown when a marshaller or unmarshaller cannot understand a node of
	 * the provided schema.
	 */
	var InvalidSchemaError = /** @class */ (function (_super) {
	    tslib_1.__extends(InvalidSchemaError, _super);
	    function InvalidSchemaError(node, message) {
	        var _this = _super.call(this, message) || this;
	        _this.node = node;
	        return _this;
	    }
	    return InvalidSchemaError;
	}(Error));
	exports.InvalidSchemaError = InvalidSchemaError;
	//# sourceMappingURL=InvalidSchemaError.js.map

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	/**
	 * An error thrown by the marshaller when a node of the provided input cannot be
	 * marshalled into the type specified in the schema.
	 */
	var InvalidValueError = /** @class */ (function (_super) {
	    tslib_1.__extends(InvalidValueError, _super);
	    function InvalidValueError(invalidValue, message) {
	        var _this = _super.call(this, message) || this;
	        _this.invalidValue = invalidValue;
	        return _this;
	    }
	    return InvalidValueError;
	}(Error));
	exports.InvalidValueError = InvalidValueError;
	//# sourceMappingURL=InvalidValueError.js.map

/***/ }),
/* 109 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function isKey(fieldSchema, indexName) {
	    if (fieldSchema.type === 'Binary' ||
	        fieldSchema.type === 'Custom' ||
	        fieldSchema.type === 'Date' ||
	        fieldSchema.type === 'Number' ||
	        fieldSchema.type === 'String') {
	        return indexName !== undefined
	            ? Boolean(fieldSchema.indexKeyConfigurations &&
	                fieldSchema.indexKeyConfigurations[indexName]) : Boolean(fieldSchema.keyType);
	    }
	    return false;
	}
	exports.isKey = isKey;
	//# sourceMappingURL=isKey.js.map

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	function keysFromSchema(schema) {
	    var e_1, _a, e_2, _b;
	    var attributes = {};
	    var tableKeys = {};
	    var indexKeys = {};
	    try {
	        for (var _c = tslib_1.__values(Object.keys(schema)), _d = _c.next(); !_d.done; _d = _c.next()) {
	            var propertyName = _d.value;
	            var fieldSchema = schema[propertyName];
	            if (fieldSchema.type === 'Binary' ||
	                fieldSchema.type === 'Custom' ||
	                fieldSchema.type === 'Date' ||
	                fieldSchema.type === 'Number' ||
	                fieldSchema.type === 'String') {
	                var _e = fieldSchema.attributeName, attributeName = _e === void 0 ? propertyName : _e;
	                if (fieldSchema.keyType) {
	                    attributes[attributeName] = attributeType(fieldSchema);
	                    tableKeys[attributeName] = fieldSchema.keyType;
	                }
	                if (fieldSchema.indexKeyConfigurations &&
	                    Object.keys(fieldSchema.indexKeyConfigurations).length > 0) {
	                    attributes[attributeName] = attributeType(fieldSchema);
	                    try {
	                        for (var _f = tslib_1.__values(Object.keys(fieldSchema.indexKeyConfigurations)), _g = _f.next(); !_g.done; _g = _f.next()) {
	                            var indexName = _g.value;
	                            if (!(indexName in indexKeys)) {
	                                indexKeys[indexName] = {};
	                            }
	                            indexKeys[indexName][attributeName]
	                                = fieldSchema.indexKeyConfigurations[indexName];
	                        }
	                    }
	                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                    finally {
	                        try {
	                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
	                        }
	                        finally { if (e_2) throw e_2.error; }
	                    }
	                }
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return { attributes: attributes, tableKeys: tableKeys, indexKeys: indexKeys };
	}
	exports.keysFromSchema = keysFromSchema;
	function attributeType(fieldSchema) {
	    switch (fieldSchema.type) {
	        case 'Binary':
	            return 'B';
	        case 'Custom':
	            if (!fieldSchema.attributeType) {
	                throw new Error('Invalid schema: no attribute type defined for custom field');
	            }
	            return fieldSchema.attributeType;
	        case 'Date':
	        case 'Number':
	            return 'N';
	        case 'String':
	            return 'S';
	    }
	}
	//# sourceMappingURL=keysFromSchema.js.map

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var toSchemaName_1 = __webpack_require__(112);
	var dynamodb_expressions_1 = __webpack_require__(113);
	/**
	 * Serialize a condition expression, substituting any property names for the
	 * corresponding attribute names in the provided schema.
	 *
	 * @param expression The expression object to marshall.
	 * @param schema The schema of the table to which the expression pertains.
	 * @param attributes An optional ExpressionAttributes object to synchronize
	 *                      substitutions across multiple expressions.
	 */
	function marshallConditionExpression(expression, schema, attributes) {
	    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
	    var serialized = dynamodb_expressions_1.serializeConditionExpression(normalizeConditionExpression(expression, schema), attributes);
	    return {
	        expression: serialized,
	        ExpressionAttributeNames: attributes.names,
	        ExpressionAttributeValues: attributes.values,
	    };
	}
	exports.marshallConditionExpression = marshallConditionExpression;
	/**
	 * Serialize a function expression, substituting any property names for the
	 * corresponding attribute names in the provided schema.
	 *
	 * @param expression The expression object to marshall.
	 * @param schema The schema of the table to which the expression pertains.
	 * @param attributes An optional ExpressionAttributes object to synchronize
	 *                      substitutions across multiple expressions.
	 */
	function marshallFunctionExpression(expression, schema, attributes) {
	    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
	    var serialized = normalizeFunctionExpression(expression, schema)
	        .serialize(attributes);
	    return {
	        expression: serialized,
	        ExpressionAttributeNames: attributes.names,
	        ExpressionAttributeValues: attributes.values,
	    };
	}
	exports.marshallFunctionExpression = marshallFunctionExpression;
	/**
	 * Serialize a mathematical expression, substituting any property names for the
	 * corresponding attribute names in the provided schema.
	 *
	 * @param expression The expression object to marshall.
	 * @param schema The schema of the table to which the expression pertains.
	 * @param attributes An optional ExpressionAttributes object to synchronize
	 *                      substitutions across multiple expressions.
	 */
	function marshallMathematicalExpression(expression, schema, attributes) {
	    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
	    var serialized = normalizeMathematicalExpression(expression, schema)
	        .serialize(attributes);
	    return {
	        expression: serialized,
	        ExpressionAttributeNames: attributes.names,
	        ExpressionAttributeValues: attributes.values,
	    };
	}
	exports.marshallMathematicalExpression = marshallMathematicalExpression;
	/**
	 * Serialize a projection expression, substituting any property names for the
	 * corresponding attribute names in the provided schema.
	 *
	 * @param expression The expression object to marshall.
	 * @param schema The schema of the table to which the expression pertains.
	 * @param attributes An optional ExpressionAttributes object to synchronize
	 *                      substitutions across multiple expressions.
	 */
	function marshallProjectionExpression(expression, schema, attributes) {
	    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
	    var serialized = dynamodb_expressions_1.serializeProjectionExpression(expression.map(function (el) { return toSchemaName_1.toSchemaName(el, schema); }), attributes);
	    return {
	        expression: serialized,
	        ExpressionAttributeNames: attributes.names,
	        ExpressionAttributeValues: attributes.values,
	    };
	}
	exports.marshallProjectionExpression = marshallProjectionExpression;
	/**
	 * Serialize an update expression, substituting any property names for the
	 * corresponding attribute names in the provided schema.
	 *
	 * @param expression The expression object to marshall.
	 * @param schema The schema of the table to which the expression pertains.
	 * @param attributes An optional ExpressionAttributes object to synchronize
	 *                      substitutions across multiple expressions.
	 */
	function marshallUpdateExpression(expression, schema, attributes) {
	    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
	    var serialized = normalizeUpdateExpression(expression, schema)
	        .serialize(attributes);
	    return {
	        expression: serialized,
	        ExpressionAttributeNames: attributes.names,
	        ExpressionAttributeValues: attributes.values,
	    };
	}
	exports.marshallUpdateExpression = marshallUpdateExpression;
	function normalizeConditionExpression(expression, schema) {
	    if (dynamodb_expressions_1.FunctionExpression.isFunctionExpression(expression)) {
	        return normalizeFunctionExpression(expression, schema);
	    }
	    switch (expression.type) {
	        case 'Equals':
	        case 'NotEquals':
	        case 'LessThan':
	        case 'LessThanOrEqualTo':
	        case 'GreaterThan':
	        case 'GreaterThanOrEqualTo':
	            return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema), object: normalizeIfPath(expression.object, schema) });
	        case 'Between':
	            return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema), lowerBound: normalizeIfPath(expression.lowerBound, schema), upperBound: normalizeIfPath(expression.upperBound, schema) });
	        case 'Membership':
	            return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema), values: expression.values.map(function (arg) { return normalizeIfPath(arg, schema); }) });
	        case 'Not':
	            return tslib_1.__assign({}, expression, { condition: normalizeConditionExpression(expression.condition, schema) });
	        case 'And':
	        case 'Or':
	            return tslib_1.__assign({}, expression, { conditions: expression.conditions.map(function (condition) {
	                    return normalizeConditionExpression(condition, schema);
	                }) });
	    }
	}
	function normalizeFunctionExpression(expression, schema) {
	    return new (dynamodb_expressions_1.FunctionExpression.bind.apply(dynamodb_expressions_1.FunctionExpression, tslib_1.__spread([void 0, expression.name], expression.args.map(function (arg) { return normalizeIfPath(arg, schema); }))))();
	}
	function normalizeMathematicalExpression(expression, schema) {
	    return new dynamodb_expressions_1.MathematicalExpression(dynamodb_expressions_1.AttributePath.isAttributePath(expression.lhs) || typeof expression.lhs === 'string'
	        ? toSchemaName_1.toSchemaName(expression.lhs, schema)
	        : expression.lhs, expression.operator, dynamodb_expressions_1.AttributePath.isAttributePath(expression.rhs) || typeof expression.rhs === 'string'
	        ? toSchemaName_1.toSchemaName(expression.rhs, schema)
	        : expression.rhs);
	}
	var mapsToTransform = [
	    ['toAdd', 'add'],
	    ['toDelete', 'delete'],
	    ['toSet', 'set'],
	];
	function normalizeUpdateExpression(expression, schema) {
	    var e_1, _a, e_2, _b;
	    var normalized = new dynamodb_expressions_1.UpdateExpression;
	    try {
	        for (var mapsToTransform_1 = tslib_1.__values(mapsToTransform), mapsToTransform_1_1 = mapsToTransform_1.next(); !mapsToTransform_1_1.done; mapsToTransform_1_1 = mapsToTransform_1.next()) {
	            var _c = tslib_1.__read(mapsToTransform_1_1.value, 2), dataSet = _c[0], exprMethod = _c[1];
	            try {
	                for (var _d = tslib_1.__values(expression[dataSet]), _e = _d.next(); !_e.done; _e = _d.next()) {
	                    var _f = tslib_1.__read(_e.value, 2), path = _f[0], value = _f[1];
	                    normalized[exprMethod](toSchemaName_1.toSchemaName(path, schema), value);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (mapsToTransform_1_1 && !mapsToTransform_1_1.done && (_a = mapsToTransform_1.return)) _a.call(mapsToTransform_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    expression.toRemove.forEach(function (el) { return normalized.remove(toSchemaName_1.toSchemaName(el, schema)); });
	    return normalized;
	}
	function normalizeIfPath(path, schema) {
	    if (dynamodb_expressions_1.AttributePath.isAttributePath(path)) {
	        return toSchemaName_1.toSchemaName(path, schema);
	    }
	    return path;
	}
	//# sourceMappingURL=marshallExpression.js.map

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var dynamodb_expressions_1 = __webpack_require__(113);
	function toSchemaName(path, schema) {
	    var e_1, _a;
	    if (typeof path === 'string') {
	        path = new dynamodb_expressions_1.AttributePath(path);
	    }
	    var elements = path.elements.map(function (el) { return (tslib_1.__assign({}, el)); });
	    var cursor = {
	        type: 'Document',
	        members: schema
	    };
	    try {
	        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
	            var element = elements_1_1.value;
	            if (element.type === 'AttributeName' &&
	                cursor &&
	                cursor.type === 'Document') {
	                var name = element.name;
	                element.name = getSchemaName(name, cursor.members);
	                cursor = cursor.members[name];
	            }
	            else if (element.type === 'ListIndex' &&
	                cursor &&
	                cursor.type === 'List') {
	                cursor = cursor.memberType;
	            }
	            else {
	                break;
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return new dynamodb_expressions_1.AttributePath(elements);
	}
	exports.toSchemaName = toSchemaName;
	function getSchemaName(propertyName, schema) {
	    var fieldSchema = schema[propertyName];
	    if (fieldSchema) {
	        var _a = fieldSchema.attributeName, attributeName = _a === void 0 ? propertyName : _a;
	        return attributeName;
	    }
	    return propertyName;
	}
	exports.getSchemaName = getSchemaName;
	//# sourceMappingURL=toSchemaName.js.map

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	tslib_1.__exportStar(__webpack_require__(114), exports);
	tslib_1.__exportStar(__webpack_require__(115), exports);
	tslib_1.__exportStar(__webpack_require__(116), exports);
	tslib_1.__exportStar(__webpack_require__(118), exports);
	tslib_1.__exportStar(__webpack_require__(117), exports);
	tslib_1.__exportStar(__webpack_require__(126), exports);
	tslib_1.__exportStar(__webpack_require__(127), exports);
	tslib_1.__exportStar(__webpack_require__(128), exports);
	//# sourceMappingURL=index.js.map

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var ATTRIBUTE_PATH_TAG = 'AmazonDynamoDbAttributePath';
	var EXPECTED_TAG = "[object " + ATTRIBUTE_PATH_TAG + "]";
	/**
	 * The path to an attribute of a DynamoDB item or to a property
	 * or member thereof. Supports map property access (`map.property`)
	 * and list member access (`list[1]`).
	 *
	 * Control characters that are part of the property identifier may be
	 * used when escaped with a backslash (`\`) character.
	 */
	var AttributePath = /** @class */ (function () {
	    function AttributePath(path) {
	        this[Symbol.toStringTag] = ATTRIBUTE_PATH_TAG;
	        if (typeof path === 'string') {
	            this.elements = parsePath(path);
	        }
	        else {
	            this.elements = tslib_1.__spread(path);
	        }
	    }
	    /**
	     * Determine if the provided value is an AttributePath object.
	     * Compatible with AttributePath objects generated in other iframes
	     * or Node VMs.
	     */
	    AttributePath.isAttributePath = function (arg) {
	        return arg instanceof AttributePath
	            || Object.prototype.toString.call(arg) === EXPECTED_TAG;
	    };
	    return AttributePath;
	}());
	exports.AttributePath = AttributePath;
	var LEFT_BRACKET = '[';
	var RIGHT_BRACKET = ']';
	var PATH_DELIMITER = '.';
	var ESCAPE_CHARACTER = '\\';
	function parsePath(path) {
	    var elements = [];
	    var state = 1001 /* identifier */;
	    var collected = '';
	    for (var iter = path[Symbol.iterator](), curr = iter.next(), peek = iter.next(); curr.done === false; curr = peek, peek = iter.next()) {
	        if (state === 1001 /* identifier */) {
	            switch (curr.value) {
	                case LEFT_BRACKET:
	                    state = 1002 /* listIndex */;
	                // fallthrough
	                case PATH_DELIMITER:
	                    if (collected === '') {
	                        throw new Error("Invalid control character encountered in path: " + path);
	                    }
	                    elements.push({ type: 'AttributeName', name: collected });
	                    collected = '';
	                    break;
	                case ESCAPE_CHARACTER:
	                    if (peek.value === PATH_DELIMITER ||
	                        peek.value === LEFT_BRACKET ||
	                        peek.value === ESCAPE_CHARACTER) {
	                        curr = peek;
	                        peek = iter.next();
	                    }
	                // fallthrough
	                default:
	                    collected += curr.value;
	            }
	        }
	        else if (state === 1002 /* listIndex */) {
	            switch (curr.value) {
	                case RIGHT_BRACKET:
	                    var intVal = parseInt(collected);
	                    if (!isFinite(intVal)) {
	                        throw new Error("Invalid array index (" + collected + ") encountered in path: " + path);
	                    }
	                    elements.push({ type: 'ListIndex', index: intVal });
	                    collected = '';
	                    state = 1000 /* controlCharacter */;
	                    break;
	                case '0':
	                case '1':
	                case '2':
	                case '3':
	                case '4':
	                case '5':
	                case '6':
	                case '7':
	                case '8':
	                case '9':
	                    collected += curr.value;
	                    break;
	                default:
	                    throw new Error("Invalid array index character (" + curr.value + ") encountered in path: " + path);
	            }
	        }
	        else {
	            switch (curr.value) {
	                case LEFT_BRACKET:
	                    state = 1002 /* listIndex */;
	                    break;
	                case PATH_DELIMITER:
	                    state = 1001 /* identifier */;
	                    break;
	                default:
	                    throw new Error("Bare identifier encountered between list index accesses in path: " + path);
	            }
	        }
	    }
	    if (collected.length > 0) {
	        elements.push({ type: 'AttributeName', name: collected });
	    }
	    return elements;
	}
	//# sourceMappingURL=AttributePath.js.map

/***/ }),
/* 115 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var MARSHALLED_ATTRIBUTE_VALUE_TAG = 'AmazonDynamoDbAttributeValue';
	var EXPECTED_TOSTRING = "[object " + MARSHALLED_ATTRIBUTE_VALUE_TAG + "]";
	/**
	 * An object containing an already-marshalled DynamoDB AttributeValue.
	 * Intended to allow marshalled AttributeValues to be identified as such
	 * and distinguished from maps that resemble marshalled values.
	 */
	var AttributeValue = /** @class */ (function () {
	    function AttributeValue(marshalled) {
	        this.marshalled = marshalled;
	        this[Symbol.toStringTag] = MARSHALLED_ATTRIBUTE_VALUE_TAG;
	    }
	    AttributeValue.isAttributeValue = function (arg) {
	        return arg instanceof AttributeValue
	            || Object.prototype.toString.call(arg) === EXPECTED_TOSTRING;
	    };
	    return AttributeValue;
	}());
	exports.AttributeValue = AttributeValue;
	//# sourceMappingURL=AttributeValue.js.map

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var AttributePath_1 = __webpack_require__(114);
	var FunctionExpression_1 = __webpack_require__(117);
	/**
	 * Create an expression predicate asserting that the subject is equal to the
	 * predicate.
	 */
	function equals(operand) {
	    return {
	        type: 'Equals',
	        object: operand,
	    };
	}
	exports.equals = equals;
	function notEquals(operand) {
	    return {
	        type: 'NotEquals',
	        object: operand,
	    };
	}
	exports.notEquals = notEquals;
	function lessThan(operand) {
	    return {
	        type: 'LessThan',
	        object: operand,
	    };
	}
	exports.lessThan = lessThan;
	function lessThanOrEqualTo(operand) {
	    return {
	        type: 'LessThanOrEqualTo',
	        object: operand,
	    };
	}
	exports.lessThanOrEqualTo = lessThanOrEqualTo;
	function greaterThan(operand) {
	    return {
	        type: 'GreaterThan',
	        object: operand,
	    };
	}
	exports.greaterThan = greaterThan;
	function greaterThanOrEqualTo(operand) {
	    return {
	        type: 'GreaterThanOrEqualTo',
	        object: operand,
	    };
	}
	exports.greaterThanOrEqualTo = greaterThanOrEqualTo;
	function between(lowerBound, upperBound) {
	    return {
	        type: 'Between',
	        lowerBound: lowerBound,
	        upperBound: upperBound,
	    };
	}
	exports.between = between;
	function inList() {
	    var operands = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        operands[_i] = arguments[_i];
	    }
	    return {
	        type: 'Membership',
	        values: operands,
	    };
	}
	exports.inList = inList;
	/**
	 * Evaluate whether the provided value is a condition expression predicate.
	 */
	function isConditionExpressionPredicate(arg) {
	    if (arg && typeof arg === 'object') {
	        switch (arg.type) {
	            case 'Equals':
	            case 'NotEquals':
	            case 'LessThan':
	            case 'LessThanOrEqualTo':
	            case 'GreaterThan':
	            case 'GreaterThanOrEqualTo':
	                return arg.object !== undefined;
	            case 'Between':
	                return arg.lowerBound !== undefined
	                    && arg.upperBound !== undefined;
	            case 'Membership':
	                return Array.isArray(arg.values);
	        }
	    }
	    return false;
	}
	exports.isConditionExpressionPredicate = isConditionExpressionPredicate;
	function isConditionExpressionSubject(arg) {
	    return Boolean(arg)
	        && typeof arg === 'object'
	        && (typeof arg.subject === 'string' || AttributePath_1.AttributePath.isAttributePath(arg.subject));
	}
	exports.isConditionExpressionSubject = isConditionExpressionSubject;
	/**
	 * Evaluates whether the provided value is a condition expression.
	 */
	function isConditionExpression(arg) {
	    var e_1, _a;
	    if (FunctionExpression_1.FunctionExpression.isFunctionExpression(arg)) {
	        return true;
	    }
	    if (Boolean(arg) && typeof arg === 'object') {
	        switch (arg.type) {
	            case 'Not':
	                return isConditionExpression(arg.condition);
	            case 'And':
	            case 'Or':
	                if (Array.isArray(arg.conditions)) {
	                    try {
	                        for (var _b = tslib_1.__values(arg.conditions), _c = _b.next(); !_c.done; _c = _b.next()) {
	                            var condition = _c.value;
	                            if (!isConditionExpression(condition)) {
	                                return false;
	                            }
	                        }
	                    }
	                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                    finally {
	                        try {
	                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                        }
	                        finally { if (e_1) throw e_1.error; }
	                    }
	                    return true;
	                }
	                return false;
	            default:
	                return isConditionExpressionSubject(arg)
	                    && isConditionExpressionPredicate(arg);
	        }
	    }
	    return false;
	}
	exports.isConditionExpression = isConditionExpression;
	/**
	 * Convert the provided condition expression object to a string, escaping any
	 * values and attributes to expression-safe placeholders whose expansion value
	 * will be managed by the provided ExpressionAttributes object.
	 */
	function serializeConditionExpression(condition, attributes) {
	    if (FunctionExpression_1.FunctionExpression.isFunctionExpression(condition)) {
	        return condition.serialize(attributes);
	    }
	    switch (condition.type) {
	        case 'Equals':
	            return serializeBinaryComparison(condition, attributes, '=');
	        case 'NotEquals':
	            return serializeBinaryComparison(condition, attributes, '<>');
	        case 'LessThan':
	            return serializeBinaryComparison(condition, attributes, '<');
	        case 'LessThanOrEqualTo':
	            return serializeBinaryComparison(condition, attributes, '<=');
	        case 'GreaterThan':
	            return serializeBinaryComparison(condition, attributes, '>');
	        case 'GreaterThanOrEqualTo':
	            return serializeBinaryComparison(condition, attributes, '>=');
	        case 'Between':
	            return attributes.addName(condition.subject) + " BETWEEN " + serializeOperand(condition.lowerBound, attributes) + " AND " + serializeOperand(condition.upperBound, attributes);
	        case 'Membership':
	            return attributes.addName(condition.subject) + " IN (" + condition.values.map(function (val) { return serializeOperand(val, attributes); })
	                .join(', ') + ")";
	        case 'Not':
	            return "NOT (" + serializeConditionExpression(condition.condition, attributes) + ")";
	        case 'And':
	        case 'Or':
	            if (condition.conditions.length === 1) {
	                return serializeConditionExpression(condition.conditions[0], attributes);
	            }
	            return condition.conditions
	                .map(function (cond) { return "(" + serializeConditionExpression(cond, attributes) + ")"; })
	                .join(" " + condition.type.toUpperCase() + " ");
	    }
	}
	exports.serializeConditionExpression = serializeConditionExpression;
	function serializeBinaryComparison(cond, attributes, comparator) {
	    return attributes.addName(cond.subject) + " " + comparator + " " + serializeOperand(cond.object, attributes);
	}
	function serializeOperand(operand, attributes) {
	    return AttributePath_1.AttributePath.isAttributePath(operand)
	        ? attributes.addName(operand)
	        : attributes.addValue(operand);
	}
	//# sourceMappingURL=ConditionExpression.js.map

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var AttributePath_1 = __webpack_require__(114);
	var FUNCTION_EXPRESSION_TAG = 'AmazonDynamoDbFunctionExpression';
	var EXPECTED_TOSTRING = "[object " + FUNCTION_EXPRESSION_TAG + "]";
	/**
	 * An object representing a DynamoDB function expression.
	 */
	var FunctionExpression = /** @class */ (function () {
	    function FunctionExpression(name) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        this.name = name;
	        this[Symbol.toStringTag] = FUNCTION_EXPRESSION_TAG;
	        this.args = args;
	    }
	    FunctionExpression.prototype.serialize = function (attributes) {
	        var expressionSafeArgs = this.args.map(function (arg) { return AttributePath_1.AttributePath.isAttributePath(arg)
	            ? attributes.addName(arg)
	            : attributes.addValue(arg); });
	        return this.name + "(" + expressionSafeArgs.join(', ') + ")";
	    };
	    /**
	     * Evaluate whether the provided value is a FunctionExpression object.
	     */
	    FunctionExpression.isFunctionExpression = function (arg) {
	        return arg instanceof FunctionExpression
	            || Object.prototype.toString.call(arg) === EXPECTED_TOSTRING;
	    };
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	//# sourceMappingURL=FunctionExpression.js.map

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var AttributePath_1 = __webpack_require__(114);
	var AttributeValue_1 = __webpack_require__(115);
	var dynamodb_auto_marshaller_1 = __webpack_require__(119);
	/**
	 * An object that manages expression attribute name and value substitution.
	 */
	var ExpressionAttributes = /** @class */ (function () {
	    function ExpressionAttributes() {
	        this.names = {};
	        this.values = {};
	        this.marshaller = new dynamodb_auto_marshaller_1.Marshaller();
	        this.nameMap = {};
	        this._ctr = 0;
	    }
	    /**
	     * Add an attribute path to this substitution context.
	     *
	     * @returns The substitution value to use in the expression. The same
	     * attribute name will always be converted to the same substitution value
	     * when supplied to the same ExpressionAttributes object multiple times.
	     */
	    ExpressionAttributes.prototype.addName = function (path) {
	        var e_1, _a;
	        if (AttributePath_1.AttributePath.isAttributePath(path)) {
	            var escapedPath = '';
	            try {
	                for (var _b = tslib_1.__values(path.elements), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var element = _c.value;
	                    if (element.type === 'AttributeName') {
	                        escapedPath += "." + this.addAttributeName(element.name);
	                    }
	                    else {
	                        escapedPath += "[" + element.index + "]";
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return escapedPath.substring(1);
	        }
	        return this.addName(new AttributePath_1.AttributePath(path));
	    };
	    /**
	     * Add an attribute value to this substitution context.
	     *
	     * @returns The substitution value to use in the expression.
	     */
	    ExpressionAttributes.prototype.addValue = function (value) {
	        var modeledAttrValue = AttributeValue_1.AttributeValue.isAttributeValue(value)
	            ? value.marshalled
	            : this.marshaller.marshallValue(value);
	        var substitution = ":val" + this._ctr++;
	        this.values[substitution] = modeledAttrValue;
	        return substitution;
	    };
	    ExpressionAttributes.prototype.addAttributeName = function (attributeName) {
	        if (!(attributeName in this.nameMap)) {
	            this.nameMap[attributeName] = "#attr" + this._ctr++;
	            this.names[this.nameMap[attributeName]] = attributeName;
	        }
	        return this.nameMap[attributeName];
	    };
	    return ExpressionAttributes;
	}());
	exports.ExpressionAttributes = ExpressionAttributes;
	//# sourceMappingURL=ExpressionAttributes.js.map

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	tslib_1.__exportStar(__webpack_require__(120), exports);
	tslib_1.__exportStar(__webpack_require__(122), exports);
	tslib_1.__exportStar(__webpack_require__(124), exports);
	tslib_1.__exportStar(__webpack_require__(125), exports);


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var ObjectSet_1 = __webpack_require__(121);
	/**
	 * A set of binary values represented as either ArrayBuffer objects or
	 * ArrayBufferView objects. Equality is determined by the underlying byte
	 * sequence and not by the identity or view window type of the provided value.
	 */
	var BinarySet = /** @class */ (function (_super) {
	    tslib_1.__extends(BinarySet, _super);
	    function BinarySet() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    BinarySet.prototype.delete = function (value) {
	        var valueView = getBinaryView(value);
	        var scrubbedValues = this._values.filter(function (item) {
	            return !binaryEquals(getBinaryView(item), valueView);
	        });
	        var numRemoved = this._values.length - scrubbedValues.length;
	        this._values = scrubbedValues;
	        return numRemoved > 0;
	    };
	    /**
	     * @inheritDoc
	     *
	     * Equality is determined by inspecting the bytes of the ArrayBuffer or
	     * ArrayBufferView.
	     *
	     * @example On a little-endian system, the following values would be
	     * considered equal:
	     *
	     *     new Uint32Array([0xdeadbeef]);
	     *     (new Uint32Array([0xdeadbeef])).buffer;
	     *     new Uint16Array([0xbeef, 0xdead]);
	     *     new Uint8Array([0xef, 0xbe, 0xad, 0xde]);
	     */
	    BinarySet.prototype.has = function (value) {
	        var e_1, _a;
	        var valueView = getBinaryView(value);
	        try {
	            for (var _b = tslib_1.__values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var item = _c.value;
	                if (binaryEquals(getBinaryView(item), valueView)) {
	                    return true;
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return false;
	    };
	    return BinarySet;
	}(ObjectSet_1.ObjectSet));
	exports.BinarySet = BinarySet;
	function binaryEquals(a, b) {
	    if (a.byteLength !== b.byteLength) {
	        return false;
	    }
	    for (var i = 0; i < a.byteLength; i++) {
	        if (a.getUint8(i) !== b.getUint8(i)) {
	            return false;
	        }
	    }
	    return true;
	}
	function getBinaryView(value) {
	    return ArrayBuffer.isView(value)
	        ? new DataView(value.buffer, value.byteOffset, value.byteLength)
	        : new DataView(value);
	}


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var ObjectSet = /** @class */ (function () {
	    /**
	     * Creates a new ObjectSet and optionally seeds it with values.
	     *
	     * @param iterable An optional iterable of values to add to the set.
	     */
	    function ObjectSet(iterable) {
	        var e_1, _a;
	        /**
	         * Returns the string literal 'Set' for use by Object.prototype.toString.
	         * This allows for identifying Sets without checking constructor identity.
	         */
	        this[Symbol.toStringTag] = 'Set';
	        this._values = [];
	        if (iterable) {
	            try {
	                for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
	                    var item = iterable_1_1.value;
	                    this.add(item);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	    }
	    /**
	     * Add a value to the set. If the value is already contained in the set, it
	     * will not be added a second time.
	     *
	     * @param value The value to add
	     */
	    ObjectSet.prototype.add = function (value) {
	        if (!this.has(value)) {
	            this._values.push(value);
	        }
	        return this;
	    };
	    /**
	     * Remove all values from the set.
	     */
	    ObjectSet.prototype.clear = function () {
	        this._values = [];
	    };
	    /**
	     * Returns an iterable two-member tuples for each item in the set, where
	     * the item is provided twice.
	     *
	     * Part of the ES2015 Set specification for compatibility with Map objects.
	     */
	    ObjectSet.prototype.entries = function () {
	        return this._values.map(function (value) { return [value, value]; })[Symbol.iterator]();
	    };
	    /**
	     * Invokes a callback once for each member of the set.
	     *
	     * @param callback The function to invoke with each set member
	     * @param thisArg The `this` context on which to invoke the callback
	     */
	    ObjectSet.prototype.forEach = function (callback, thisArg) {
	        var _this = this;
	        this._values.forEach(function (value, index, array) {
	            callback.call(thisArg, value, value, _this);
	        }, thisArg);
	    };
	    /**
	     * Returns an IterableIterator of each member of the set.
	     */
	    ObjectSet.prototype.keys = function () {
	        return this[Symbol.iterator]();
	    };
	    Object.defineProperty(ObjectSet.prototype, "size", {
	        /**
	         * Returns the number of members in the set.
	         */
	        get: function () {
	            return this._values.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns an IterableIterator of each member of the set.
	     */
	    ObjectSet.prototype.values = function () {
	        return this[Symbol.iterator]();
	    };
	    /**
	     * Returns an IterableIterator of each member of the set.
	     */
	    ObjectSet.prototype[Symbol.iterator] = function () {
	        return this._values[Symbol.iterator]();
	    };
	    return ObjectSet;
	}());
	exports.ObjectSet = ObjectSet;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var BinarySet_1 = __webpack_require__(120);
	var isArrayBuffer_1 = __webpack_require__(123);
	var NumberValue_1 = __webpack_require__(124);
	var NumberValueSet_1 = __webpack_require__(125);
	exports.EmptyHandlingStrategies = {
	    omit: 'omit',
	    nullify: 'nullify',
	    leave: 'leave',
	};
	exports.InvalidHandlingStrategies = {
	    /**
	     * Remove any invalid values from the serialized output.
	     */
	    omit: 'omit',
	    /**
	     * Throw an error when an unserializable value is encountered.
	     */
	    throw: 'throw',
	};
	/**
	 * A class that will convert arbitrary JavaScript data types to their most
	 * logical in the DynamoDB schema.
	 */
	var Marshaller = /** @class */ (function () {
	    function Marshaller(_a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.onEmpty, onEmpty = _c === void 0 ? 'leave' : _c, _d = _b.onInvalid, onInvalid = _d === void 0 ? 'throw' : _d, _e = _b.unwrapNumbers, unwrapNumbers = _e === void 0 ? false : _e;
	        this.onEmpty = onEmpty;
	        this.onInvalid = onInvalid;
	        this.unwrapNumbers = unwrapNumbers;
	    }
	    /**
	     * Convert a JavaScript object with string keys and arbitrary values into an
	     * object with string keys and DynamoDB AttributeValue objects as values.
	     */
	    Marshaller.prototype.marshallItem = function (item) {
	        var value = this.marshallValue(item);
	        if (!(value && value.M) && this.onInvalid === 'throw') {
	            throw new Error("Cannot serialize " + typeof item + " as an attribute map");
	        }
	        return value && value.M ? value.M : {};
	    };
	    /**
	     * Convert a JavaScript value into a DynamoDB AttributeValue or `undefined`.
	     *
	     * @throws Error if the value cannot be converted to a DynamoDB type and the
	     * marshaller has been configured to throw on invalid input.
	     */
	    Marshaller.prototype.marshallValue = function (value) {
	        switch (typeof value) {
	            case 'boolean':
	                return { BOOL: value };
	            case 'number':
	                return { N: value.toString(10) };
	            case 'object':
	                return this.marshallComplexType(value);
	            case 'string':
	                return value ? { S: value } : this.handleEmptyString(value);
	            case 'undefined':
	                return undefined;
	            case 'function':
	            case 'symbol':
	            default:
	                if (this.onInvalid === 'throw') {
	                    throw new Error("Cannot serialize values of the " + typeof value + " type");
	                }
	        }
	    };
	    /**
	     * Convert a DynamoDB operation result (an object with string keys and
	     * AttributeValue values) to an object with string keys and native
	     * JavaScript values.
	     */
	    Marshaller.prototype.unmarshallItem = function (item) {
	        return this.unmarshallValue({ M: item });
	    };
	    /**
	     * Convert a DynamoDB AttributeValue into a native JavaScript value.
	     */
	    Marshaller.prototype.unmarshallValue = function (item) {
	        var _this = this;
	        var e_1, _a, e_2, _b;
	        if (item.S !== undefined) {
	            return item.S;
	        }
	        if (item.N !== undefined) {
	            return this.unwrapNumbers
	                ? Number(item.N)
	                : new NumberValue_1.NumberValue(item.N);
	        }
	        if (item.B !== undefined) {
	            return item.B;
	        }
	        if (item.BOOL !== undefined) {
	            return item.BOOL;
	        }
	        if (item.NULL !== undefined) {
	            return null;
	        }
	        if (item.SS !== undefined) {
	            var set = new Set();
	            try {
	                for (var _c = tslib_1.__values(item.SS), _d = _c.next(); !_d.done; _d = _c.next()) {
	                    var member = _d.value;
	                    set.add(member);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return set;
	        }
	        if (item.NS !== undefined) {
	            if (this.unwrapNumbers) {
	                var set = new Set();
	                try {
	                    for (var _e = tslib_1.__values(item.NS), _f = _e.next(); !_f.done; _f = _e.next()) {
	                        var member = _f.value;
	                        set.add(Number(member));
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	                return set;
	            }
	            return new NumberValueSet_1.NumberValueSet(item.NS.map(function (numberString) { return new NumberValue_1.NumberValue(numberString); }));
	        }
	        if (item.BS !== undefined) {
	            return new BinarySet_1.BinarySet(item.BS);
	        }
	        if (item.L !== undefined) {
	            return item.L.map(this.unmarshallValue.bind(this));
	        }
	        var _g = item.M, M = _g === void 0 ? {} : _g;
	        return Object.keys(M).reduce(function (map, key) {
	            map[key] = _this.unmarshallValue(M[key]);
	            return map;
	        }, {});
	    };
	    Marshaller.prototype.marshallComplexType = function (value) {
	        if (value === null) {
	            return { NULL: true };
	        }
	        if (NumberValue_1.NumberValue.isNumberValue(value)) {
	            return { N: value.toString() };
	        }
	        if (isBinaryValue(value)) {
	            return this.marshallBinaryValue(value);
	        }
	        if (isSet(value)) {
	            return this.marshallSet(value);
	        }
	        if (isMap(value)) {
	            return this.marshallMap(value);
	        }
	        if (isIterable(value)) {
	            return this.marshallList(value);
	        }
	        return this.marshallObject(value);
	    };
	    Marshaller.prototype.marshallBinaryValue = function (binary) {
	        if (binary.byteLength > 0 || this.onEmpty === 'leave') {
	            return { B: binary };
	        }
	        if (this.onEmpty === 'nullify') {
	            return { NULL: true };
	        }
	    };
	    Marshaller.prototype.marshallList = function (list) {
	        var e_3, _a;
	        var values = [];
	        try {
	            for (var list_1 = tslib_1.__values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {
	                var value = list_1_1.value;
	                var marshalled = this.marshallValue(value);
	                if (marshalled) {
	                    values.push(marshalled);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return { L: values };
	    };
	    Marshaller.prototype.marshallMap = function (map) {
	        var e_4, _a;
	        var members = {};
	        try {
	            for (var map_1 = tslib_1.__values(map), map_1_1 = map_1.next(); !map_1_1.done; map_1_1 = map_1.next()) {
	                var _b = tslib_1.__read(map_1_1.value, 2), key = _b[0], value = _b[1];
	                if (typeof key !== 'string') {
	                    if (this.onInvalid === 'omit') {
	                        continue;
	                    }
	                    throw new Error("MapAttributeValues must have strings as keys; " + typeof key + " received instead");
	                }
	                var marshalled = this.marshallValue(value);
	                if (marshalled) {
	                    members[key] = marshalled;
	                }
	            }
	        }
	        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	        finally {
	            try {
	                if (map_1_1 && !map_1_1.done && (_a = map_1.return)) _a.call(map_1);
	            }
	            finally { if (e_4) throw e_4.error; }
	        }
	        return { M: members };
	    };
	    Marshaller.prototype.marshallObject = function (object) {
	        var _this = this;
	        return {
	            M: Object.keys(object).reduce(function (map, key) {
	                var marshalled = _this.marshallValue(object[key]);
	                if (marshalled) {
	                    map[key] = marshalled;
	                }
	                return map;
	            }, {}),
	        };
	    };
	    Marshaller.prototype.marshallSet = function (arg) {
	        switch (getSetType(arg[Symbol.iterator]().next().value)) {
	            case 'binary':
	                return this.collectSet(arg, isBinaryEmpty, 'BS', 'binary');
	            case 'number':
	                return this.collectSet(arg, isNumberEmpty, 'NS', 'number', stringifyNumber);
	            case 'string':
	                return this.collectSet(arg, isStringEmpty, 'SS', 'string');
	            case 'unknown':
	                if (this.onInvalid === 'throw') {
	                    throw new Error('Sets must be composed of strings,' +
	                        ' binary values, or numbers');
	                }
	                return undefined;
	            case 'undefined':
	                if (this.onEmpty === 'nullify') {
	                    return { NULL: true };
	                }
	        }
	    };
	    Marshaller.prototype.collectSet = function (set, isEmpty, tag, elementType, transform) {
	        var e_5, _a, _b;
	        var values = [];
	        try {
	            for (var set_1 = tslib_1.__values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {
	                var element = set_1_1.value;
	                if (getSetType(element) !== elementType) {
	                    if (this.onInvalid === 'omit') {
	                        continue;
	                    }
	                    throw new Error("Unable to serialize " + typeof element + " as a member of a " + elementType + " set");
	                }
	                if (!isEmpty(element) ||
	                    this.onEmpty === 'leave') {
	                    values.push(transform ? transform(element) : element);
	                }
	            }
	        }
	        catch (e_5_1) { e_5 = { error: e_5_1 }; }
	        finally {
	            try {
	                if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);
	            }
	            finally { if (e_5) throw e_5.error; }
	        }
	        if (values.length > 0 || this.onEmpty === 'leave') {
	            return _b = {}, _b[tag] = values, _b;
	        }
	        if (this.onEmpty === 'nullify') {
	            return { NULL: true };
	        }
	    };
	    Marshaller.prototype.handleEmptyString = function (value) {
	        switch (this.onEmpty) {
	            case 'leave':
	                return { S: value };
	            case 'nullify':
	                return { NULL: true };
	        }
	    };
	    return Marshaller;
	}());
	exports.Marshaller = Marshaller;
	function getSetType(arg) {
	    var type = typeof arg;
	    if (type === 'string' || type === 'number' || type === 'undefined') {
	        return type;
	    }
	    if (NumberValue_1.NumberValue.isNumberValue(arg)) {
	        return 'number';
	    }
	    if (ArrayBuffer.isView(arg) || isArrayBuffer_1.isArrayBuffer(arg)) {
	        return 'binary';
	    }
	    return 'unknown';
	}
	function isBinaryEmpty(arg) {
	    return arg.byteLength === 0;
	}
	function isBinaryValue(arg) {
	    return ArrayBuffer.isView(arg) || isArrayBuffer_1.isArrayBuffer(arg);
	}
	function isIterable(arg) {
	    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
	}
	function isMap(arg) {
	    return Boolean(arg)
	        && Object.prototype.toString.call(arg) === '[object Map]';
	}
	function isNumberEmpty() {
	    return false;
	}
	function isSet(arg) {
	    return Boolean(arg)
	        && Object.prototype.toString.call(arg) === '[object Set]';
	}
	function isStringEmpty(arg) {
	    return arg.length === 0;
	}
	function stringifyNumber(arg) {
	    return arg.toString();
	}


/***/ }),
/* 123 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Determines if the provided argument is an ArrayBuffer object. Compatible with
	 * ArrayBuffers created in separate iframes and VMs.
	 */
	function isArrayBuffer(arg) {
	    return (typeof ArrayBuffer === 'function' && arg instanceof ArrayBuffer) ||
	        Object.prototype.toString.call(arg) === '[object ArrayBuffer]';
	}
	exports.isArrayBuffer = isArrayBuffer;


/***/ }),
/* 124 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var NUMBER_VALUE_TAG = 'DynamoDbNumberValue';
	var EXPECTED_TAG = "[object " + NUMBER_VALUE_TAG + "]";
	/**
	 * A number that may contain greater precision than can safely be stored in
	 * JavaScript's `number` data type. Numerical values are represented internally
	 * as strings (the format used by DynamoDB's JSON-based data representation
	 * schema).
	 */
	var NumberValue = /** @class */ (function () {
	    function NumberValue(value) {
	        this[Symbol.toStringTag] = NUMBER_VALUE_TAG;
	        this.value = value.toString().trim();
	    }
	    /**
	     * Convert the value to its desired JSON representation. Called by
	     * `JSON.stringify`.
	     */
	    NumberValue.prototype.toJSON = function () {
	        return this.valueOf();
	    };
	    /**
	     * Convert the value to its desired string representation. Called
	     * automatically when objects are coerced into strings.
	     */
	    NumberValue.prototype.toString = function () {
	        return this.value;
	    };
	    /**
	     * Convert the value to its desired literal representation. Called
	     * automatically when objects appear in arithmetic expressions.
	     */
	    NumberValue.prototype.valueOf = function () {
	        return Number(this.value);
	    };
	    /**
	     * Evaluate whether the provided value is a NumberValue object.
	     */
	    NumberValue.isNumberValue = function (arg) {
	        return (typeof NumberValue === 'function' && arg instanceof NumberValue)
	            || Object.prototype.toString.call(arg) === EXPECTED_TAG;
	    };
	    return NumberValue;
	}());
	exports.NumberValue = NumberValue;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var ObjectSet_1 = __webpack_require__(121);
	var NumberValue_1 = __webpack_require__(124);
	/**
	 * A set of numeric values represented internally as NumberValue objects.
	 * Equality is determined by the string representation of the number and not by
	 * the identity or data type of the provided value.
	 */
	var NumberValueSet = /** @class */ (function (_super) {
	    tslib_1.__extends(NumberValueSet, _super);
	    function NumberValueSet() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @inheritDoc
	     *
	     * If a number or string is provided, it will be converted to a NumberValue
	     * object.
	     */
	    NumberValueSet.prototype.add = function (value) {
	        if (typeof value === 'number' || typeof value === 'string') {
	            value = new NumberValue_1.NumberValue(value);
	        }
	        _super.prototype.add.call(this, value);
	        return this;
	    };
	    NumberValueSet.prototype.delete = function (value) {
	        var valueString = value.toString();
	        var scrubbedValues = this._values
	            .filter(function (item) { return item.toString() !== valueString; });
	        var numRemoved = this._values.length - scrubbedValues.length;
	        this._values = scrubbedValues;
	        return numRemoved > 0;
	    };
	    NumberValueSet.prototype.has = function (value) {
	        var e_1, _a;
	        var valueString = value.toString();
	        try {
	            for (var _b = tslib_1.__values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var item = _c.value;
	                if (item.toString() === valueString) {
	                    return true;
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return false;
	    };
	    return NumberValueSet;
	}(ObjectSet_1.ObjectSet));
	exports.NumberValueSet = NumberValueSet;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var AttributePath_1 = __webpack_require__(114);
	var MATHEMATICAL_EXPRESSION_TAG = 'AmazonDynamoDbMathematicalExpression';
	var EXPECTED_TOSTRING = "[object " + MATHEMATICAL_EXPRESSION_TAG + "]";
	/**
	 * An object representing a DynamoDB function expression.
	 */
	var MathematicalExpression = /** @class */ (function () {
	    function MathematicalExpression(lhs, operator, rhs) {
	        this.lhs = lhs;
	        this.operator = operator;
	        this.rhs = rhs;
	        this[Symbol.toStringTag] = MATHEMATICAL_EXPRESSION_TAG;
	    }
	    MathematicalExpression.prototype.serialize = function (attributes) {
	        var safeArgs = [this.lhs, this.rhs].map(function (arg) { return AttributePath_1.AttributePath.isAttributePath(arg) || typeof arg === 'string'
	            ? attributes.addName(arg)
	            : attributes.addValue(arg); });
	        return safeArgs[0] + " " + this.operator + " " + safeArgs[1];
	    };
	    /**
	     * Evaluate whether the provided value is a MathematicalExpression object.
	     */
	    MathematicalExpression.isMathematicalExpression = function (arg) {
	        return arg instanceof MathematicalExpression
	            || Object.prototype.toString.call(arg) === EXPECTED_TOSTRING;
	    };
	    return MathematicalExpression;
	}());
	exports.MathematicalExpression = MathematicalExpression;
	//# sourceMappingURL=MathematicalExpression.js.map

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	/**
	 * Convert the supplied projection expression to the string format
	 * expected by DynamoDB, substituting all attribute paths using the
	 * provided ExpressionAttributes object.
	 */
	function serializeProjectionExpression(projection, attributes) {
	    var e_1, _a;
	    var serialized = [];
	    try {
	        for (var projection_1 = tslib_1.__values(projection), projection_1_1 = projection_1.next(); !projection_1_1.done; projection_1_1 = projection_1.next()) {
	            var projected = projection_1_1.value;
	            serialized.push(attributes.addName(projected));
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (projection_1_1 && !projection_1_1.done && (_a = projection_1.return)) _a.call(projection_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return serialized.join(', ');
	}
	exports.serializeProjectionExpression = serializeProjectionExpression;
	//# sourceMappingURL=ProjectionExpression.js.map

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var AttributePath_1 = __webpack_require__(114);
	var FunctionExpression_1 = __webpack_require__(117);
	var MathematicalExpression_1 = __webpack_require__(126);
	/**
	 * An object representing a DynamoDB update expression.
	 */
	var UpdateExpression = /** @class */ (function () {
	    function UpdateExpression() {
	        this.toAdd = new Map();
	        this.toDelete = new Map();
	        this.toRemove = new Set();
	        this.toSet = new Map();
	    }
	    /**
	     * Add a directive to the expression's `add` clause.
	     */
	    UpdateExpression.prototype.add = function (path, value) {
	        this.toAdd.set(AttributePath_1.AttributePath.isAttributePath(path) ? path : new AttributePath_1.AttributePath(path), value);
	    };
	    /**
	     * Add a directive to the expression's `delete` clause.
	     */
	    UpdateExpression.prototype.delete = function (path, value) {
	        this.toDelete.set(AttributePath_1.AttributePath.isAttributePath(path) ? path : new AttributePath_1.AttributePath(path), value);
	    };
	    /**
	     * Add a directive to the expression's `remove` clause.
	     */
	    UpdateExpression.prototype.remove = function (path) {
	        this.toRemove.add(AttributePath_1.AttributePath.isAttributePath(path) ? path : new AttributePath_1.AttributePath(path));
	    };
	    /**
	     * Add a directive to the expression's `set` clause.
	     */
	    UpdateExpression.prototype.set = function (path, value) {
	        this.toSet.set(AttributePath_1.AttributePath.isAttributePath(path) ? path : new AttributePath_1.AttributePath(path), value);
	    };
	    UpdateExpression.prototype.serialize = function (attributes) {
	        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
	        var clauses = [];
	        var phrases = [];
	        try {
	            for (var _e = tslib_1.__values([
	                [this.toAdd, 'ADD'],
	                [this.toDelete, 'DELETE'],
	            ]), _f = _e.next(); !_f.done; _f = _e.next()) {
	                var _g = tslib_1.__read(_f.value, 2), mapping = _g[0], verb = _g[1];
	                try {
	                    for (var _h = tslib_1.__values(mapping.entries()), _j = _h.next(); !_j.done; _j = _h.next()) {
	                        var _k = tslib_1.__read(_j.value, 2), key = _k[0], value = _k[1];
	                        phrases.push(attributes.addName(key) + " " + attributes.addValue(value));
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	                if (phrases.length > 0) {
	                    clauses.push(verb + " " + phrases.join(', '));
	                    phrases.length = 0;
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        try {
	            for (var _l = tslib_1.__values(this.toSet.entries()), _m = _l.next(); !_m.done; _m = _l.next()) {
	                var _o = tslib_1.__read(_m.value, 2), key = _o[0], value = _o[1];
	                phrases.push(attributes.addName(key) + " = " + (FunctionExpression_1.FunctionExpression.isFunctionExpression(value) || MathematicalExpression_1.MathematicalExpression.isMathematicalExpression(value)
	                    ? value.serialize(attributes) : attributes.addValue(value)));
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (_m && !_m.done && (_c = _l.return)) _c.call(_l);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        if (phrases.length > 0) {
	            clauses.push("SET " + phrases.join(', '));
	            phrases.length = 0;
	        }
	        try {
	            for (var _p = tslib_1.__values(this.toRemove), _q = _p.next(); !_q.done; _q = _p.next()) {
	                var keyToRemove = _q.value;
	                phrases.push(attributes.addName(keyToRemove));
	            }
	        }
	        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	        finally {
	            try {
	                if (_q && !_q.done && (_d = _p.return)) _d.call(_p);
	            }
	            finally { if (e_4) throw e_4.error; }
	        }
	        if (phrases.length > 0) {
	            clauses.push("REMOVE " + phrases.join(', '));
	            phrases.length = 0;
	        }
	        return clauses.join(' ');
	    };
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	//# sourceMappingURL=UpdateExpression.js.map

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var InvalidValueError_1 = __webpack_require__(108);
	var InvalidSchemaError_1 = __webpack_require__(107);
	var dynamodb_auto_marshaller_1 = __webpack_require__(119);
	var bytes = __webpack_require__(130);
	/**
	 * Converts a JavaScript object into a DynamoDB Item.
	 *
	 * @param schema Metadata explaining how the provided input is to be marshalled
	 * @param input JavaScript object to convert
	 */
	function marshallItem(schema, input) {
	    var e_1, _a;
	    var marshalled = {};
	    try {
	        for (var _b = tslib_1.__values(Object.keys(schema)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var key = _c.value;
	            var value = input[key];
	            var _d = schema[key].attributeName, attributeName = _d === void 0 ? key : _d;
	            var marshalledValue = marshallValue(schema[key], value);
	            if (marshalledValue) {
	                marshalled[attributeName] = marshalledValue;
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return marshalled;
	}
	exports.marshallItem = marshallItem;
	/**
	 * Converts a value into a DynamoDB AttributeValue.
	 *
	 * @param schemaType    Metadata outlining how the value is to be understood and
	 *                      converted
	 * @param input         Value to convert
	 */
	function marshallValue(schemaType, input) {
	    var e_2, _a, e_3, _b, e_4, _c, e_5, _d, e_6, _e, e_7, _f;
	    if (input === undefined) {
	        var defaultProvider = schemaType.defaultProvider;
	        if (typeof defaultProvider === 'function') {
	            input = defaultProvider();
	        }
	        else {
	            return undefined;
	        }
	    }
	    if (schemaType.type === 'Any') {
	        var _g = schemaType.onEmpty, onEmpty = _g === void 0 ? 'nullify' : _g, _h = schemaType.onInvalid, onInvalid = _h === void 0 ? 'omit' : _h, _j = schemaType.unwrapNumbers, unwrapNumbers = _j === void 0 ? false : _j;
	        var marshaller = new dynamodb_auto_marshaller_1.Marshaller({ onEmpty: onEmpty, onInvalid: onInvalid, unwrapNumbers: unwrapNumbers });
	        return marshaller.marshallValue(input);
	    }
	    if (schemaType.type === 'Binary') {
	        if (!input || input.length === 0 || input.byteLength === 0) {
	            return { NULL: true };
	        }
	        return { B: marshallBinary(input) };
	    }
	    if (schemaType.type === 'Boolean') {
	        return { BOOL: Boolean(input) };
	    }
	    if (schemaType.type === 'Custom') {
	        return schemaType.marshall(input);
	    }
	    if (schemaType.type === 'Collection') {
	        var _k = schemaType.onEmpty, onEmpty = _k === void 0 ? 'nullify' : _k, _l = schemaType.onInvalid, onInvalid = _l === void 0 ? 'omit' : _l, _m = schemaType.unwrapNumbers, unwrapNumbers = _m === void 0 ? false : _m;
	        var marshaller = new dynamodb_auto_marshaller_1.Marshaller({ onEmpty: onEmpty, onInvalid: onInvalid, unwrapNumbers: unwrapNumbers });
	        var collected = [];
	        try {
	            for (var input_1 = tslib_1.__values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
	                var element = input_1_1.value;
	                var marshalled = marshaller.marshallValue(element);
	                if (marshalled) {
	                    collected.push(marshalled);
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        return { L: collected };
	    }
	    if (schemaType.type === 'Date') {
	        var date = void 0;
	        if (typeof input === 'string') {
	            date = new Date(input);
	        }
	        else if (typeof input === 'number') {
	            date = new Date(input * 1000);
	        }
	        else if (isDate(input)) {
	            date = input;
	        }
	        else {
	            throw new InvalidValueError_1.InvalidValueError(input, 'Unable to convert value to date');
	        }
	        return { N: marshallNumber(Math.floor(date.valueOf() / 1000)) };
	    }
	    if (schemaType.type === 'Document') {
	        return { M: marshallItem(schemaType.members, input) };
	    }
	    if (schemaType.type === 'Hash') {
	        var _o = schemaType.onEmpty, onEmpty = _o === void 0 ? 'nullify' : _o, _p = schemaType.onInvalid, onInvalid = _p === void 0 ? 'omit' : _p, _q = schemaType.unwrapNumbers, unwrapNumbers = _q === void 0 ? false : _q;
	        var marshaller = new dynamodb_auto_marshaller_1.Marshaller({ onEmpty: onEmpty, onInvalid: onInvalid, unwrapNumbers: unwrapNumbers });
	        return { M: marshaller.marshallItem(input) };
	    }
	    if (schemaType.type === 'List') {
	        var elements = [];
	        try {
	            for (var input_2 = tslib_1.__values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()) {
	                var member = input_2_1.value;
	                var marshalled = marshallValue(schemaType.memberType, member);
	                if (marshalled) {
	                    elements.push(marshalled);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (input_2_1 && !input_2_1.done && (_b = input_2.return)) _b.call(input_2);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return { L: elements };
	    }
	    if (schemaType.type === 'Map') {
	        var marshalled = {};
	        if (typeof input[Symbol.iterator] === 'function') {
	            try {
	                for (var input_3 = tslib_1.__values(input), input_3_1 = input_3.next(); !input_3_1.done; input_3_1 = input_3.next()) {
	                    var _r = tslib_1.__read(input_3_1.value, 2), key = _r[0], value = _r[1];
	                    var marshalledValue = marshallValue(schemaType.memberType, value);
	                    if (marshalledValue) {
	                        marshalled[key] = marshalledValue;
	                    }
	                }
	            }
	            catch (e_4_1) { e_4 = { error: e_4_1 }; }
	            finally {
	                try {
	                    if (input_3_1 && !input_3_1.done && (_c = input_3.return)) _c.call(input_3);
	                }
	                finally { if (e_4) throw e_4.error; }
	            }
	        }
	        else if (typeof input === 'object') {
	            try {
	                for (var _s = tslib_1.__values(Object.keys(input)), _t = _s.next(); !_t.done; _t = _s.next()) {
	                    var key = _t.value;
	                    var marshalledValue = marshallValue(schemaType.memberType, input[key]);
	                    if (marshalledValue) {
	                        marshalled[key] = marshalledValue;
	                    }
	                }
	            }
	            catch (e_5_1) { e_5 = { error: e_5_1 }; }
	            finally {
	                try {
	                    if (_t && !_t.done && (_d = _s.return)) _d.call(_s);
	                }
	                finally { if (e_5) throw e_5.error; }
	            }
	        }
	        else {
	            throw new InvalidValueError_1.InvalidValueError(input, 'Unable to convert value to map');
	        }
	        return { M: marshalled };
	    }
	    if (schemaType.type === 'Null') {
	        return { NULL: true };
	    }
	    if (schemaType.type === 'Number') {
	        return { N: marshallNumber(input) };
	    }
	    if (schemaType.type === 'Set') {
	        if (schemaType.memberType === 'Binary') {
	            if (!(input instanceof dynamodb_auto_marshaller_1.BinarySet)) {
	                var set = new dynamodb_auto_marshaller_1.BinarySet();
	                try {
	                    for (var input_4 = tslib_1.__values(input), input_4_1 = input_4.next(); !input_4_1.done; input_4_1 = input_4.next()) {
	                        var item = input_4_1.value;
	                        set.add(marshallBinary(item));
	                    }
	                }
	                catch (e_6_1) { e_6 = { error: e_6_1 }; }
	                finally {
	                    try {
	                        if (input_4_1 && !input_4_1.done && (_e = input_4.return)) _e.call(input_4);
	                    }
	                    finally { if (e_6) throw e_6.error; }
	                }
	                input = set;
	            }
	            return marshallSet(input, marshallBinary, function (bin) { return bin.byteLength === 0; }, 'BS');
	        }
	        if (schemaType.memberType === 'Number') {
	            if (!(input instanceof Set)) {
	                input = new dynamodb_auto_marshaller_1.NumberValueSet(input);
	            }
	            return marshallSet(input, marshallNumber, function () { return false; }, 'NS');
	        }
	        if (schemaType.memberType === 'String') {
	            if (!(input instanceof Set)) {
	                var original = input;
	                input = new Set();
	                try {
	                    for (var original_1 = tslib_1.__values(original), original_1_1 = original_1.next(); !original_1_1.done; original_1_1 = original_1.next()) {
	                        var el = original_1_1.value;
	                        input.add(el);
	                    }
	                }
	                catch (e_7_1) { e_7 = { error: e_7_1 }; }
	                finally {
	                    try {
	                        if (original_1_1 && !original_1_1.done && (_f = original_1.return)) _f.call(original_1);
	                    }
	                    finally { if (e_7) throw e_7.error; }
	                }
	            }
	            return marshallSet(input, marshallString, function (string) { return string.length === 0; }, 'SS');
	        }
	        throw new InvalidSchemaError_1.InvalidSchemaError(schemaType, "Unrecognized set member type: " + schemaType.memberType);
	    }
	    if (schemaType.type === 'String') {
	        var string = marshallString(input);
	        if (string.length === 0) {
	            return { NULL: true };
	        }
	        return { S: string };
	    }
	    if (schemaType.type === 'Tuple') {
	        return {
	            L: schemaType.members
	                .map(function (type, index) { return marshallValue(type, input[index]); })
	                .filter(function (val) { return val !== undefined; })
	        };
	    }
	    throw new InvalidSchemaError_1.InvalidSchemaError(schemaType, 'Unrecognized schema node');
	}
	exports.marshallValue = marshallValue;
	function marshallBinary(input) {
	    if (ArrayBuffer.isView(input)) {
	        return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
	    }
	    if (isArrayBuffer(input)) {
	        return new Uint8Array(input);
	    }
	    return Uint8Array.from(bytes(input));
	}
	function marshallNumber(input) {
	    return input.toString(10);
	}
	function marshallString(input) {
	    return input.toString();
	}
	function marshallSet(value, marshaller, isEmpty, setTag) {
	    var e_8, _a, _b;
	    var collected = [];
	    try {
	        for (var value_1 = tslib_1.__values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
	            var member = value_1_1.value;
	            var marshalled = marshaller(member);
	            if (isEmpty(marshalled)) {
	                // DynamoDB sets cannot contain empty values
	                continue;
	            }
	            collected.push(marshalled);
	        }
	    }
	    catch (e_8_1) { e_8 = { error: e_8_1 }; }
	    finally {
	        try {
	            if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
	        }
	        finally { if (e_8) throw e_8.error; }
	    }
	    if (collected.length === 0) {
	        return { NULL: true };
	    }
	    return _b = {}, _b[setTag] = collected, _b;
	}
	function isArrayBuffer(arg) {
	    return typeof ArrayBuffer === 'function'
	        && (arg instanceof ArrayBuffer ||
	            Object.prototype.toString.call(arg) === '[object ArrayBuffer]');
	}
	function isDate(arg) {
	    return arg instanceof Date
	        || Object.prototype.toString.call(arg) === '[object Date]';
	}
	//# sourceMappingURL=marshallItem.js.map

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	module.exports = function (str) {
	    var bytes = [];
	    for (var i = 0; i < str.length; i++) {
	        var c = str.charCodeAt(i);
	        if (c >= 0xd800 && c <= 0xdbff && i + 1 < str.length) {
	            var cn = str.charCodeAt(i + 1);
	            if (cn >= 0xdc00 && cn <= 0xdfff) {
	                var pt = (c - 0xd800) * 0x400 + cn - 0xdc00 + 0x10000;
	                
	                bytes.push(
	                    0xf0 + Math.floor(pt / 64 / 64 / 64),
	                    0x80 + Math.floor(pt / 64 / 64) % 64,
	                    0x80 + Math.floor(pt / 64) % 64,
	                    0x80 + pt % 64
	                );
	                i += 1;
	                continue;
	            }
	        }
	        if (c >= 2048) {
	            bytes.push(
	                0xe0 + Math.floor(c / 64 / 64),
	                0x80 + Math.floor(c / 64) % 64,
	                0x80 + c % 64
	            );
	        }
	        else if (c >= 128) {
	            bytes.push(0xc0 + Math.floor(c / 64), 0x80 + c % 64);
	        }
	        else bytes.push(c);
	    }
	    return bytes;
	};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var isKey_1 = __webpack_require__(109);
	var marshallItem_1 = __webpack_require__(129);
	function marshallKey(schema, input, indexName) {
	    var e_1, _a;
	    var marshalled = {};
	    try {
	        for (var _b = tslib_1.__values(Object.keys(schema)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var propertyKey = _c.value;
	            var fieldSchema = schema[propertyKey];
	            if (isKey_1.isKey(fieldSchema, indexName)) {
	                var _d = fieldSchema.attributeName, attributeName = _d === void 0 ? propertyKey : _d;
	                var value = marshallItem_1.marshallValue(fieldSchema, input[propertyKey]);
	                if (value) {
	                    marshalled[attributeName] = value;
	                }
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return marshalled;
	}
	exports.marshallKey = marshallKey;
	//# sourceMappingURL=marshallKey.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var SchemaType_1 = __webpack_require__(133);
	/**
	 * Evaluates whether the provided argument is a Schema object
	 */
	function isSchema(arg) {
	    var e_1, _a;
	    if (!Boolean(arg) || typeof arg !== 'object') {
	        return false;
	    }
	    try {
	        for (var _b = tslib_1.__values(Object.keys(arg)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var key = _c.value;
	            if (!SchemaType_1.isSchemaType(arg[key])) {
	                return false;
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return true;
	}
	exports.isSchema = isSchema;
	//# sourceMappingURL=Schema.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	/**
	 * The enumeration of types supported by this marshaller package.
	 */
	exports.TypeTags = {
	    Any: 'Any',
	    Binary: 'Binary',
	    Boolean: 'Boolean',
	    Collection: 'Collection',
	    Custom: 'Custom',
	    Date: 'Date',
	    Document: 'Document',
	    Hash: 'Hash',
	    List: 'List',
	    Map: 'Map',
	    Null: 'Null',
	    Number: 'Number',
	    Set: 'Set',
	    String: 'String',
	    Tuple: 'Tuple',
	};
	function isBaseType(arg) {
	    return Boolean(arg) && typeof arg === 'object'
	        && typeof arg.type === 'string'
	        && arg.type in exports.TypeTags
	        && ['string', 'undefined'].indexOf(typeof arg.attributeName) > -1;
	}
	/**
	 * The types of keys a given attribute can represent.
	 */
	exports.KeyTypes = {
	    HASH: 'HASH',
	    RANGE: 'RANGE',
	};
	function isKeyableType(arg) {
	    var e_1, _a;
	    var _b = arg, keyType = _b.keyType, indexKeyConfigurations = _b.indexKeyConfigurations;
	    if (!(keyType === undefined || keyType in exports.KeyTypes)) {
	        return false;
	    }
	    var idxKeysType = typeof indexKeyConfigurations;
	    if (indexKeyConfigurations && idxKeysType === 'object') {
	        try {
	            for (var _c = tslib_1.__values(Object.keys(indexKeyConfigurations)), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var indexName = _d.value;
	                if (!(indexKeyConfigurations[indexName] in exports.KeyTypes)) {
	                    return false;
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return true;
	    }
	    return idxKeysType === 'undefined';
	}
	function isSchemaType(arg, alreadyVisited) {
	    if (alreadyVisited === void 0) { alreadyVisited = new Set(); }
	    if (isBaseType(arg)) {
	        if (alreadyVisited.has(arg)) {
	            return true;
	        }
	        alreadyVisited.add(arg);
	        switch (arg.type) {
	            case 'Binary':
	            case 'Date':
	            case 'String':
	                return isKeyableType(arg);
	            case 'Custom':
	                return isKeyableType(arg)
	                    && typeof arg.marshall === 'function'
	                    && typeof arg.unmarshall === 'function'
	                    && [
	                        void 0,
	                        'S',
	                        'N',
	                        'B',
	                    ].indexOf(arg.attributeType) > -1;
	            case 'Document':
	                return isDocumentType(arg, alreadyVisited);
	            case 'List':
	            case 'Map':
	                return isSchemaType(arg.memberType, alreadyVisited);
	            case 'Number':
	                return isKeyableType(arg) && ['boolean', 'undefined']
	                    .indexOf(typeof arg.versionAttribute) > -1;
	            case 'Tuple':
	                return isTupleType(arg, alreadyVisited);
	            default:
	                return true;
	        }
	    }
	    return false;
	}
	exports.isSchemaType = isSchemaType;
	function isDocumentType(arg, alreadyVisited) {
	    var e_2, _a;
	    var _b = arg, valueConstructor = _b.valueConstructor, members = _b.members;
	    if (!members || typeof members !== 'object') {
	        return false;
	    }
	    try {
	        for (var _c = tslib_1.__values(Object.keys(members)), _d = _c.next(); !_d.done; _d = _c.next()) {
	            var key = _d.value;
	            if (!isSchemaType(members[key], alreadyVisited)) {
	                return false;
	            }
	        }
	    }
	    catch (e_2_1) { e_2 = { error: e_2_1 }; }
	    finally {
	        try {
	            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	        }
	        finally { if (e_2) throw e_2.error; }
	    }
	    return ['function', 'undefined',].indexOf(typeof valueConstructor) > -1;
	}
	function isTupleType(arg, alreadyVisited) {
	    var e_3, _a;
	    var members = arg.members;
	    if (!Array.isArray(members)) {
	        return false;
	    }
	    try {
	        for (var members_1 = tslib_1.__values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {
	            var member = members_1_1.value;
	            if (!isSchemaType(member, alreadyVisited)) {
	                return false;
	            }
	        }
	    }
	    catch (e_3_1) { e_3 = { error: e_3_1 }; }
	    finally {
	        try {
	            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);
	        }
	        finally { if (e_3) throw e_3.error; }
	    }
	    return true;
	}
	//# sourceMappingURL=SchemaType.js.map

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var InvalidSchemaError_1 = __webpack_require__(107);
	var dynamodb_auto_marshaller_1 = __webpack_require__(119);
	/**
	 * Unmarshall a DynamoDB item into a JavaScript value.
	 *
	 * @param schema            Metadata outlining the types to be expected
	 *                          throughout the input
	 * @param input             The value to unmarshall
	 * @param valueConstructor  A zero-argument constructor used to create the
	 *                          object onto which the input should be unmarshalled
	 */
	function unmarshallItem(schema, input, valueConstructor) {
	    var e_1, _a;
	    var unmarshalled = valueConstructor
	        ? new valueConstructor()
	        : Object.create(null);
	    try {
	        for (var _b = tslib_1.__values(Object.keys(schema)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var key = _c.value;
	            var _d = schema[key].attributeName, attributeName = _d === void 0 ? key : _d;
	            if (attributeName in input) {
	                unmarshalled[key] = unmarshallValue(schema[key], input[attributeName]);
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return unmarshalled;
	}
	exports.unmarshallItem = unmarshallItem;
	function unmarshallValue(schemaType, input) {
	    switch (schemaType.type) {
	        case 'Any':
	        case 'Collection':
	        case 'Hash':
	            var autoMarshaller = new dynamodb_auto_marshaller_1.Marshaller();
	            return autoMarshaller.unmarshallValue(input);
	        case 'Binary':
	            if (input.NULL) {
	                return new Uint8Array(0);
	            }
	            return input.B;
	        case 'Boolean':
	            return input.BOOL;
	        case 'Custom':
	            return schemaType.unmarshall(input);
	        case 'Date':
	            return input.N ? new Date(Number(input.N) * 1000) : undefined;
	        case 'Document':
	            return input.M
	                ? unmarshallItem(schemaType.members, input.M, schemaType.valueConstructor) : undefined;
	        case 'List':
	            return input.L ? unmarshallList(schemaType, input.L) : undefined;
	        case 'Map':
	            return input.M ? unmarshallMap(schemaType, input.M) : undefined;
	        case 'Null':
	            return input.NULL ? null : undefined;
	        case 'Number':
	            return typeof input.N === 'string' ? Number(input.N) : undefined;
	        case 'Set':
	            switch (schemaType.memberType) {
	                case 'Binary':
	                    if (input.NULL) {
	                        return new dynamodb_auto_marshaller_1.BinarySet();
	                    }
	                    return typeof input.BS !== 'undefined'
	                        ? new dynamodb_auto_marshaller_1.BinarySet(input.BS)
	                        : undefined;
	                case 'Number':
	                    if (input.NULL) {
	                        return new Set();
	                    }
	                    return input.NS ? unmarshallNumberSet(input.NS) : undefined;
	                case 'String':
	                    if (input.NULL) {
	                        return new Set();
	                    }
	                    return input.SS ? unmarshallStringSet(input.SS) : undefined;
	                default:
	                    throw new InvalidSchemaError_1.InvalidSchemaError(schemaType, "Unrecognized set member type: " + schemaType.memberType);
	            }
	        case 'String':
	            return input.NULL ? '' : input.S;
	        case 'Tuple':
	            return input.L ? unmarshallTuple(schemaType, input.L) : undefined;
	    }
	    throw new InvalidSchemaError_1.InvalidSchemaError(schemaType, 'Unrecognized schema node');
	}
	function unmarshallList(schemaType, input) {
	    var e_2, _a;
	    var list = [];
	    try {
	        for (var input_1 = tslib_1.__values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
	            var element = input_1_1.value;
	            list.push(unmarshallValue(schemaType.memberType, element));
	        }
	    }
	    catch (e_2_1) { e_2 = { error: e_2_1 }; }
	    finally {
	        try {
	            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
	        }
	        finally { if (e_2) throw e_2.error; }
	    }
	    return list;
	}
	function unmarshallMap(schemaType, input) {
	    var e_3, _a;
	    var map = new Map();
	    try {
	        for (var _b = tslib_1.__values(Object.keys(input)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var key = _c.value;
	            map.set(key, unmarshallValue(schemaType.memberType, input[key]));
	        }
	    }
	    catch (e_3_1) { e_3 = { error: e_3_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_3) throw e_3.error; }
	    }
	    return map;
	}
	function unmarshallNumberSet(input) {
	    var e_4, _a;
	    var set = new Set();
	    try {
	        for (var input_2 = tslib_1.__values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()) {
	            var number = input_2_1.value;
	            set.add(Number(number));
	        }
	    }
	    catch (e_4_1) { e_4 = { error: e_4_1 }; }
	    finally {
	        try {
	            if (input_2_1 && !input_2_1.done && (_a = input_2.return)) _a.call(input_2);
	        }
	        finally { if (e_4) throw e_4.error; }
	    }
	    return set;
	}
	function unmarshallStringSet(input) {
	    var e_5, _a;
	    var set = new Set();
	    try {
	        for (var input_3 = tslib_1.__values(input), input_3_1 = input_3.next(); !input_3_1.done; input_3_1 = input_3.next()) {
	            var string = input_3_1.value;
	            set.add(string);
	        }
	    }
	    catch (e_5_1) { e_5 = { error: e_5_1 }; }
	    finally {
	        try {
	            if (input_3_1 && !input_3_1.done && (_a = input_3.return)) _a.call(input_3);
	        }
	        finally { if (e_5) throw e_5.error; }
	    }
	    return set;
	}
	function unmarshallTuple(schemaType, input) {
	    var members = schemaType.members;
	    var tuple = [];
	    for (var i = 0; i < members.length; i++) {
	        tuple.push(unmarshallValue(members[i], input[i]));
	    }
	    return tuple;
	}
	//# sourceMappingURL=unmarshallItem.js.map

/***/ }),
/* 135 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Table metadata is reported by items submitted to the data mapper via methods
	 * identified by symbols. This is done both to disambiguate data (which should
	 * always be identified by string keys) from metadata and also to allow an
	 * eventually integration with the First-Class Protocols proposal as described
	 * at {@link https://github.com/michaelficarra/proposal-first-class-protocols}
	 * (currently at stage 1 in the ECMAScript change acceptance process).
	 *
	 * Because the protocol proposal allows implementation to be declared
	 * dynamically at runtime (and also because TypeScript does not allow
	 * user-defined symbols to appear in type declarations), protocol adherence
	 * should be detected on objects at runtime rather than on types via static
	 * analysis.
	 */
	/**
	 * Used to designate the mapping of an object from its JavaScript form to its
	 * representation in a DynamoDB Table or nested map.
	 *
	 * @example
	 *
	 *      class FooDocument {
	 *          [DynamoDbSchema]() {
	 *              return {
	 *                  bar: {type: 'String'},
	 *                  baz: {type: 'Number'},
	 *              };
	 *          }
	 *      }
	 */
	exports.DynamoDbSchema = Symbol('DynamoDbSchema');
	function getSchema(item) {
	    if (item) {
	        var schema = item[exports.DynamoDbSchema];
	        if (schema && typeof schema === 'object') {
	            return schema;
	        }
	    }
	    throw new Error('The provided item did not adhere to the DynamoDbDocument protocol.' +
	        ' No object property was found at the `DynamoDbSchema` symbol');
	}
	exports.getSchema = getSchema;
	/**
	 * Used to designate that an object represents a row of the named DynamoDB
	 * table. Meant to be used in conjunction with {DynamoDbSchema}.
	 *
	 * @example
	 *
	 *      class FooDocument {
	 *          [DynamoDbTable]() {
	 *              return 'FooTable';
	 *          }
	 *
	 *          [DynamoDbSchema]() {
	 *              return {
	 *                  bar: {type: 'String'},
	 *                  baz: {type: 'Number'},
	 *              };
	 *          }
	 *      }
	 */
	exports.DynamoDbTable = Symbol('DynamoDbTableName');
	function getTableName(item, tableNamePrefix) {
	    if (tableNamePrefix === void 0) { tableNamePrefix = ''; }
	    if (item) {
	        var tableName = item[exports.DynamoDbTable];
	        if (typeof tableName === 'string') {
	            return tableNamePrefix + tableName;
	        }
	    }
	    throw new Error('The provided item did not adhere to the DynamoDbTable protocol. No' +
	        ' string property was found at the `DynamoDbTable` symbol');
	}
	exports.getTableName = getTableName;
	/**
	 * Used to designate which fields on an object have been changed. The method
	 * identified by this symbol should return a iterable that enumerates the fields
	 * that have been altered.
	 *
	 * @example
	 *
	 *      class FooDocument {
	 *          constructor() {
	 *              this._dirtyFields = new Set();
	 *              this._foo = '';
	 *          }
	 *
	 *          get foo() {
	 *              return this._foo;
	 *          }
	 *
	 *          set foo(value) {
	 *              this._foo = value;
	 *              this._dirtyFields.add('foo');
	 *          }
	 *
	 *          [DynamoDbDirtyFields]() {
	 *              return this._dirtyFields.values();
	 *          }
	 *      }
	 */
	exports.DynamoDbDirtyFields = Symbol('DynamoDbDirtyFields');
	//# sourceMappingURL=protocols.js.map

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var protocols_1 = __webpack_require__(135);
	var dynamodb_data_marshaller_1 = __webpack_require__(106);
	__webpack_require__(102);
	var Paginator = /** @class */ (function () {
	    function Paginator(paginator, valueConstructor) {
	        this.paginator = paginator;
	        this.valueConstructor = valueConstructor;
	        this.lastResolved = Promise.resolve();
	        this.itemSchema = protocols_1.getSchema(valueConstructor.prototype);
	    }
	    /**
	     * @inheritDoc
	     */
	    Paginator.prototype[Symbol.asyncIterator] = function () {
	        return this;
	    };
	    /**
	     * @inheritDoc
	     */
	    Paginator.prototype.next = function () {
	        var _this = this;
	        this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
	        return this.lastResolved;
	    };
	    /**
	     * @inheritDoc
	     */
	    Paginator.prototype.return = function () {
	        // Prevent any further use of this iterator
	        this.lastResolved = Promise.reject(new Error('Iteration has been manually interrupted and may not be resumed'));
	        this.lastResolved.catch(function () { });
	        return this.paginator.return();
	    };
	    Object.defineProperty(Paginator.prototype, "consumedCapacity", {
	        /**
	         * Retrieve the reported capacity consumed by this paginator. Will be
	         * undefined unless returned consumed capacity is requested.
	         */
	        get: function () {
	            return this.paginator.consumedCapacity;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Paginator.prototype, "count", {
	        /**
	         * Retrieve the number of items yielded thus far by this paginator.
	         */
	        get: function () {
	            return this.paginator.count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Paginator.prototype, "lastEvaluatedKey", {
	        /**
	         * Retrieve the last reported `LastEvaluatedKey`, unmarshalled according to
	         * the schema used by this paginator.
	         */
	        get: function () {
	            return this.lastKey;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Paginator.prototype, "scannedCount", {
	        /**
	         * Retrieve the number of items scanned thus far during the execution of
	         * this paginator. This number should be the same as {@link count} unless a
	         * filter expression was used.
	         */
	        get: function () {
	            return this.paginator.scannedCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Paginator.prototype.getNext = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var _this = this;
	            return tslib_1.__generator(this, function (_a) {
	                return [2 /*return*/, this.paginator.next().then(function (_a) {
	                        var _b = _a.value, value = _b === void 0 ? {} : _b, done = _a.done;
	                        if (!done) {
	                            _this.lastKey = value.LastEvaluatedKey && dynamodb_data_marshaller_1.unmarshallItem(_this.itemSchema, value.LastEvaluatedKey, _this.valueConstructor);
	                            return {
	                                value: (value.Items || []).map(function (item) { return dynamodb_data_marshaller_1.unmarshallItem(_this.itemSchema, item, _this.valueConstructor); }),
	                                done: false
	                            };
	                        }
	                        return { done: true };
	                    })];
	            });
	        });
	    };
	    return Paginator;
	}());
	exports.Paginator = Paginator;
	//# sourceMappingURL=Paginator.js.map

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	tslib_1.__exportStar(__webpack_require__(138), exports);
	tslib_1.__exportStar(__webpack_require__(140), exports);
	tslib_1.__exportStar(__webpack_require__(144), exports);
	tslib_1.__exportStar(__webpack_require__(145), exports);
	tslib_1.__exportStar(__webpack_require__(146), exports);
	tslib_1.__exportStar(__webpack_require__(142), exports);
	//# sourceMappingURL=index.js.map

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var ItemIterator_1 = __webpack_require__(139);
	var ParallelScanPaginator_1 = __webpack_require__(140);
	var ParallelScanIterator = /** @class */ (function (_super) {
	    tslib_1.__extends(ParallelScanIterator, _super);
	    function ParallelScanIterator(client, input, scanState) {
	        return _super.call(this, new ParallelScanPaginator_1.ParallelScanPaginator(client, input, scanState)) || this;
	    }
	    return ParallelScanIterator;
	}(ItemIterator_1.ItemIterator));
	exports.ParallelScanIterator = ParallelScanIterator;
	//# sourceMappingURL=ParallelScanIterator.js.map

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	if (Symbol && !Symbol.asyncIterator) {
	    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
	}
	var ItemIterator = /** @class */ (function () {
	    function ItemIterator(paginator) {
	        this.paginator = paginator;
	        this._iteratedCount = 0;
	        this.lastResolved = Promise.resolve();
	        this.pending = [];
	    }
	    /**
	     * @inheritDoc
	     */
	    ItemIterator.prototype[Symbol.asyncIterator] = function () {
	        return this;
	    };
	    Object.defineProperty(ItemIterator.prototype, "consumedCapacity", {
	        /**
	         * The capacity units consumed by the Scan operation. The data returned
	         * includes the total provisioned throughput consumed, along with statistics
	         * for the table and any indexes involved in the operation. ConsumedCapacity
	         * is only returned if the ReturnConsumedCapacity parameter was specified.
	         */
	        get: function () {
	            return this.paginator.consumedCapacity;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ItemIterator.prototype, "count", {
	        /**
	         * The number of items that have been iterated over.
	         */
	        get: function () {
	            return this._iteratedCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ItemIterator.prototype.next = function () {
	        var _this = this;
	        this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
	        return this.lastResolved;
	    };
	    /**
	     * Detaches the underlying paginator from this iterator and returns it. The
	     * paginator will yield arrays of unmarshalled items, with each yielded
	     * array corresponding to a single call to the underlying API. As with the
	     * underlying API, pages may contain a variable number of items or no items,
	     * in which case an empty array will be yielded.
	     *
	     * Calling this method will disable further iteration.
	     */
	    ItemIterator.prototype.pages = function () {
	        // Prevent the iterator from being used further and squelch any uncaught
	        // promise rejection warnings
	        this.lastResolved = Promise.reject(new Error('The underlying paginator has been detached from this iterator.'));
	        this.lastResolved.catch(function () { });
	        return this.paginator;
	    };
	    /**
	     * @inheritDoc
	     */
	    ItemIterator.prototype.return = function () {
	        // Prevent any further use of this iterator
	        this.lastResolved = Promise.reject(new Error('Iteration has been manually interrupted and may not be resumed'));
	        this.lastResolved.catch(function () { });
	        // Clear the pending queue to free up memory
	        this.pending.length = 0;
	        return this.paginator.return().then(doneSigil);
	    };
	    Object.defineProperty(ItemIterator.prototype, "scannedCount", {
	        /**
	         * The number of items evaluated, before any ScanFilter is applied. A high
	         * scannedCount value with few, or no, Count results indicates an
	         * inefficient Scan operation. For more information, see Count and
	         * ScannedCount in the Amazon DynamoDB Developer Guide.
	         */
	        get: function () {
	            return this.paginator.scannedCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ItemIterator.prototype.getNext = function () {
	        var _this = this;
	        if (this.pending.length > 0) {
	            this._iteratedCount++;
	            return Promise.resolve({
	                value: this.pending.shift(),
	                done: false
	            });
	        }
	        return this.paginator.next().then(function (_a) {
	            var done = _a.done, value = _a.value;
	            var _b;
	            if (done) {
	                return { done: done };
	            }
	            (_b = _this.pending).push.apply(_b, tslib_1.__spread(value.Items || []));
	            return _this.getNext();
	        });
	    };
	    return ItemIterator;
	}());
	exports.ItemIterator = ItemIterator;
	function doneSigil() {
	    return { done: true };
	}
	//# sourceMappingURL=ItemIterator.js.map

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var mergeConsumedCapacities_1 = __webpack_require__(141);
	var ScanPaginator_1 = __webpack_require__(142);
	if (Symbol && !Symbol.asyncIterator) {
	    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
	}
	var ParallelScanPaginator = /** @class */ (function () {
	    function ParallelScanPaginator(client, input, scanState) {
	        if (scanState === void 0) { scanState = nullScanState(input.TotalSegments); }
	        this.pending = [];
	        this.lastResolved = Promise.resolve();
	        var TotalSegments = input.TotalSegments;
	        if (scanState.length !== TotalSegments) {
	            throw new Error("Parallel scan state must have a length equal to the number of "
	                + ("scan segments. Expected an array of " + TotalSegments + " but")
	                + ("received an array with " + scanState.length + " elements."));
	        }
	        this.iterators = new Array(TotalSegments);
	        for (var i = 0; i < TotalSegments; i++) {
	            var iterator = new ScanPaginator_1.ScanPaginator(client, tslib_1.__assign({}, input, { Segment: i, ExclusiveStartKey: scanState[i].LastEvaluatedKey }));
	            this.iterators[i] = iterator;
	            // If the segment has not been initialized or a pagination token has
	            // been received, request the next page.
	            if (!scanState[i].initialized || scanState[i].LastEvaluatedKey) {
	                this.refillPending(iterator, i);
	            }
	        }
	        this._scanState = tslib_1.__spread(scanState);
	    }
	    /**
	     * @inheritDoc
	     */
	    ParallelScanPaginator.prototype[Symbol.asyncIterator] = function () {
	        return this;
	    };
	    Object.defineProperty(ParallelScanPaginator.prototype, "consumedCapacity", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.iterators.reduce(function (merged, paginator) { return mergeConsumedCapacities_1.mergeConsumedCapacities(merged, paginator.consumedCapacity); }, undefined);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParallelScanPaginator.prototype, "count", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.iterators.reduce(function (sum, paginator) { return sum + paginator.count; }, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParallelScanPaginator.prototype.next = function () {
	        var _this = this;
	        this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
	        return this.lastResolved;
	    };
	    ParallelScanPaginator.prototype.getNext = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var _a, iterator, _b, value, done, segment, i;
	            return tslib_1.__generator(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        if (this.pending.length === 0) {
	                            return [2 /*return*/, doneSigil()];
	                        }
	                        return [4 /*yield*/, Promise.race(this.pending.map(function (pending) { return pending.result; }))];
	                    case 1:
	                        _a = _c.sent(), iterator = _a.iterator, _b = _a.result, value = _b.value, done = _b.done, segment = _a.segment;
	                        // Update the scan state for this segment. This will either be the last
	                        // evaluated key (for an unfinished segment) or undefined (for a
	                        // completed segment).
	                        this._scanState[segment] = {
	                            initialized: true,
	                            LastEvaluatedKey: value && value.LastEvaluatedKey,
	                        };
	                        // Remove the result from the pending set.
	                        for (i = this.pending.length - 1; i >= 0; i--) {
	                            if (this.pending[i].iterator === iterator) {
	                                this.pending.splice(i, 1);
	                            }
	                        }
	                        // If the iterator is not finished, add its next result to the pending
	                        // set.
	                        if (!done) {
	                            this.refillPending(iterator, segment);
	                            return [2 /*return*/, { value: value, done: done }];
	                        }
	                        else {
	                            // If a segment has finished but there are still outstanding
	                            // requests, recur. A done sigil will be returned when the pending
	                            // queue is empty.
	                            return [2 /*return*/, this.getNext()];
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * @inheritDoc
	     */
	    ParallelScanPaginator.prototype.return = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            return tslib_1.__generator(this, function (_a) {
	                this.pending.length = 0;
	                return [2 /*return*/, Promise.all(this.iterators.map(function (iterator) { return iterator.return(); }))
	                        .then(doneSigil)];
	            });
	        });
	    };
	    Object.defineProperty(ParallelScanPaginator.prototype, "scannedCount", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.iterators.reduce(function (sum, paginator) { return sum + paginator.scannedCount; }, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParallelScanPaginator.prototype, "scanState", {
	        /**
	         * A snapshot of the current state of a parallel scan. May be used to resume
	         * a parallel scan with a separate paginator.
	         */
	        get: function () {
	            return tslib_1.__spread(this._scanState);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParallelScanPaginator.prototype.refillPending = function (iterator, segment) {
	        // Use .push to reorder segments within the array of pending results.
	        // Promise.race will iterate over the array of pending results until a
	        // resolved promise is found and therefore will naturally favor promises
	        // towards the head of the queue. Removing resolved segments and sending
	        // them to the back of the line will keep this implementation detail
	        // from creating hot and cold scan segments.
	        this.pending.push({
	            iterator: iterator,
	            result: iterator.next()
	                .then(function (result) { return ({ iterator: iterator, result: result, segment: segment }); }),
	        });
	    };
	    return ParallelScanPaginator;
	}());
	exports.ParallelScanPaginator = ParallelScanPaginator;
	function doneSigil() {
	    return { done: true };
	}
	/**
	 * `Array.prototype.fill` is not available in IE, so a loop is used instead
	 */
	function nullScanState(length) {
	    var target = new Array(length);
	    for (var i = 0; i < length; i++) {
	        target[i] = { initialized: false };
	    }
	    return target;
	}
	//# sourceMappingURL=ParallelScanPaginator.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	/**
	 * @internal
	 */
	function mergeConsumedCapacities(a, b) {
	    if (a || b) {
	        a = a || {};
	        b = b || {};
	        if ((a.TableName && b.TableName) && a.TableName !== b.TableName) {
	            throw new Error('Consumed capacity reports may only be merged if they describe the same table');
	        }
	        return {
	            TableName: a.TableName || b.TableName,
	            CapacityUnits: (a.CapacityUnits || 0) + (b.CapacityUnits || 0),
	            Table: mergeCapacities(a.Table, b.Table),
	            LocalSecondaryIndexes: mergeCapacityMaps(a.LocalSecondaryIndexes, b.LocalSecondaryIndexes),
	            GlobalSecondaryIndexes: mergeCapacityMaps(a.GlobalSecondaryIndexes, b.GlobalSecondaryIndexes),
	        };
	    }
	}
	exports.mergeConsumedCapacities = mergeConsumedCapacities;
	function mergeCapacities(a, b) {
	    if (a || b) {
	        return {
	            CapacityUnits: ((a && a.CapacityUnits) || 0) +
	                ((b && b.CapacityUnits) || 0),
	        };
	    }
	}
	function mergeCapacityMaps(a, b) {
	    var e_1, _a, e_2, _b, e_3, _c;
	    if (a || b) {
	        var out = {};
	        a = a || {};
	        b = b || {};
	        var keys = new Set();
	        try {
	            for (var _d = tslib_1.__values([a, b]), _e = _d.next(); !_e.done; _e = _d.next()) {
	                var map = _e.value;
	                try {
	                    for (var _f = tslib_1.__values(Object.keys(map)), _g = _f.next(); !_g.done; _g = _f.next()) {
	                        var indexName = _g.value;
	                        keys.add(indexName);
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        try {
	            for (var keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
	                var key = keys_1_1.value;
	                out[key] = mergeCapacities(a[key], b[key]);
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (keys_1_1 && !keys_1_1.done && (_c = keys_1.return)) _c.call(keys_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return out;
	    }
	}
	//# sourceMappingURL=mergeConsumedCapacities.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var DynamoDbPaginator_1 = __webpack_require__(143);
	var ScanPaginator = /** @class */ (function (_super) {
	    tslib_1.__extends(ScanPaginator, _super);
	    function ScanPaginator(client, input, limit) {
	        var _this = _super.call(this, limit) || this;
	        _this.client = client;
	        _this.nextRequest = tslib_1.__assign({}, input, { Limit: _this.getNextPageSize(input.Limit) });
	        return _this;
	    }
	    ScanPaginator.prototype.getNext = function () {
	        var _this = this;
	        if (this.nextRequest) {
	            return this.client.scan(tslib_1.__assign({}, this.nextRequest, { Limit: this.getNextPageSize(this.nextRequest.Limit) }))
	                .promise()
	                .then(function (output) {
	                if (_this.nextRequest && output.LastEvaluatedKey) {
	                    _this.nextRequest = tslib_1.__assign({}, _this.nextRequest, { ExclusiveStartKey: output.LastEvaluatedKey });
	                }
	                else {
	                    _this.nextRequest = undefined;
	                }
	                return Promise.resolve({
	                    value: output,
	                    done: false
	                });
	            });
	        }
	        return Promise.resolve({ done: true });
	    };
	    return ScanPaginator;
	}(DynamoDbPaginator_1.DynamoDbPaginator));
	exports.ScanPaginator = ScanPaginator;
	//# sourceMappingURL=ScanPaginator.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var mergeConsumedCapacities_1 = __webpack_require__(141);
	if (Symbol && !Symbol.asyncIterator) {
	    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
	}
	var DynamoDbPaginator = /** @class */ (function () {
	    function DynamoDbPaginator(limit) {
	        this.limit = limit;
	        this._count = 0;
	        this._scannedCount = 0;
	        this.lastResolved = Promise.resolve();
	    }
	    /**
	     * @inheritDoc
	     */
	    DynamoDbPaginator.prototype[Symbol.asyncIterator] = function () {
	        return this;
	    };
	    Object.defineProperty(DynamoDbPaginator.prototype, "consumedCapacity", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._consumedCapacity;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DynamoDbPaginator.prototype, "count", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DynamoDbPaginator.prototype, "lastEvaluatedKey", {
	        /**
	         * Get the LastEvaluatedKey of the last result page yielded by this
	         * paginator or undefined if the scan has already been exhausted.
	         */
	        get: function () {
	            return this._lastKey;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DynamoDbPaginator.prototype.next = function () {
	        var _this = this;
	        this.lastResolved = this.lastResolved.then(function () {
	            if (_this.count >= (_this.limit === undefined ? Infinity : _this.limit)) {
	                return { done: true };
	            }
	            return _this.getNext().then(function (_a) {
	                var done = _a.done, value = _a.value;
	                if (value && !done) {
	                    _this._lastKey = value.LastEvaluatedKey;
	                    _this._count += (value.Items || []).length;
	                    _this._scannedCount += (value.ScannedCount || 0);
	                    _this._consumedCapacity = mergeConsumedCapacities_1.mergeConsumedCapacities(_this._consumedCapacity, value.ConsumedCapacity);
	                }
	                return { value: value, done: done };
	            });
	        });
	        return this.lastResolved;
	    };
	    /**
	     * @inheritDoc
	     */
	    DynamoDbPaginator.prototype.return = function () {
	        // Prevent any further use of this iterator
	        this.lastResolved = Promise.reject(new Error('Iteration has been manually interrupted and may not be resumed'));
	        this.lastResolved.catch(function () { });
	        return Promise.resolve({ done: true });
	    };
	    Object.defineProperty(DynamoDbPaginator.prototype, "scannedCount", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._scannedCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DynamoDbPaginator.prototype.getNextPageSize = function (requestedPageSize) {
	        if (this.limit === undefined) {
	            return requestedPageSize;
	        }
	        return Math.min(requestedPageSize === undefined ? Infinity : requestedPageSize, this.limit - this.count);
	    };
	    return DynamoDbPaginator;
	}());
	exports.DynamoDbPaginator = DynamoDbPaginator;
	//# sourceMappingURL=DynamoDbPaginator.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var ItemIterator_1 = __webpack_require__(139);
	var QueryPaginator_1 = __webpack_require__(145);
	var QueryIterator = /** @class */ (function (_super) {
	    tslib_1.__extends(QueryIterator, _super);
	    function QueryIterator(client, input, limit) {
	        return _super.call(this, new QueryPaginator_1.QueryPaginator(client, input, limit)) || this;
	    }
	    return QueryIterator;
	}(ItemIterator_1.ItemIterator));
	exports.QueryIterator = QueryIterator;
	//# sourceMappingURL=QueryIterator.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var DynamoDbPaginator_1 = __webpack_require__(143);
	var QueryPaginator = /** @class */ (function (_super) {
	    tslib_1.__extends(QueryPaginator, _super);
	    function QueryPaginator(client, input, limit) {
	        var _this = _super.call(this, limit) || this;
	        _this.client = client;
	        _this.nextRequest = tslib_1.__assign({}, input);
	        return _this;
	    }
	    QueryPaginator.prototype.getNext = function () {
	        var _this = this;
	        if (this.nextRequest) {
	            return this.client.query(tslib_1.__assign({}, this.nextRequest, { Limit: this.getNextPageSize(this.nextRequest.Limit) }))
	                .promise()
	                .then(function (output) {
	                if (_this.nextRequest && output.LastEvaluatedKey) {
	                    _this.nextRequest = tslib_1.__assign({}, _this.nextRequest, { ExclusiveStartKey: output.LastEvaluatedKey });
	                }
	                else {
	                    _this.nextRequest = undefined;
	                }
	                return Promise.resolve({
	                    value: output,
	                    done: false
	                });
	            });
	        }
	        return Promise.resolve({ done: true });
	    };
	    return QueryPaginator;
	}(DynamoDbPaginator_1.DynamoDbPaginator));
	exports.QueryPaginator = QueryPaginator;
	//# sourceMappingURL=QueryPaginator.js.map

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var ItemIterator_1 = __webpack_require__(139);
	var ScanPaginator_1 = __webpack_require__(142);
	var ScanIterator = /** @class */ (function (_super) {
	    tslib_1.__extends(ScanIterator, _super);
	    function ScanIterator(client, input, limit) {
	        return _super.call(this, new ScanPaginator_1.ScanPaginator(client, input, limit)) || this;
	    }
	    return ScanIterator;
	}(ItemIterator_1.ItemIterator));
	exports.ScanIterator = ScanIterator;
	//# sourceMappingURL=ScanIterator.js.map

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var Iterator_1 = __webpack_require__(101);
	var QueryPaginator_1 = __webpack_require__(148);
	/**
	 * Iterates over each item returned by a DynamoDB query until no more pages are
	 * available.
	 */
	var QueryIterator = /** @class */ (function (_super) {
	    tslib_1.__extends(QueryIterator, _super);
	    function QueryIterator(client, valueConstructor, keyCondition, options) {
	        return _super.call(this, new QueryPaginator_1.QueryPaginator(client, valueConstructor, keyCondition, options)) || this;
	    }
	    return QueryIterator;
	}(Iterator_1.Iterator));
	exports.QueryIterator = QueryIterator;
	//# sourceMappingURL=QueryIterator.js.map

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var marshallStartKey_1 = __webpack_require__(105);
	var Paginator_1 = __webpack_require__(136);
	var protocols_1 = __webpack_require__(135);
	var dynamodb_query_iterator_1 = __webpack_require__(137);
	var dynamodb_data_marshaller_1 = __webpack_require__(106);
	var dynamodb_expressions_1 = __webpack_require__(113);
	/**
	 * Iterates over each page of items returned by a DynamoDB query until no more
	 * pages are available.
	 */
	var QueryPaginator = /** @class */ (function (_super) {
	    tslib_1.__extends(QueryPaginator, _super);
	    function QueryPaginator(client, valueConstructor, keyCondition, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        var itemSchema = protocols_1.getSchema(valueConstructor.prototype);
	        var filter = options.filter, indexName = options.indexName, limit = options.limit, pageSize = options.pageSize, projection = options.projection, readConsistency = options.readConsistency, scanIndexForward = options.scanIndexForward, startKey = options.startKey, prefix = options.tableNamePrefix;
	        var req = {
	            TableName: protocols_1.getTableName(valueConstructor.prototype, prefix),
	            ScanIndexForward: scanIndexForward,
	            Limit: pageSize,
	            IndexName: indexName,
	        };
	        if (readConsistency === 'strong') {
	            req.ConsistentRead = true;
	        }
	        var attributes = new dynamodb_expressions_1.ExpressionAttributes();
	        req.KeyConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(normalizeKeyCondition(keyCondition), itemSchema, attributes).expression;
	        if (filter) {
	            req.FilterExpression = dynamodb_data_marshaller_1.marshallConditionExpression(filter, itemSchema, attributes).expression;
	        }
	        if (projection) {
	            req.ProjectionExpression = dynamodb_data_marshaller_1.marshallProjectionExpression(projection, itemSchema, attributes).expression;
	        }
	        if (Object.keys(attributes.names).length > 0) {
	            req.ExpressionAttributeNames = attributes.names;
	        }
	        if (Object.keys(attributes.values).length > 0) {
	            req.ExpressionAttributeValues = attributes.values;
	        }
	        if (startKey) {
	            req.ExclusiveStartKey = marshallStartKey_1.marshallStartKey(itemSchema, startKey);
	        }
	        _this = _super.call(this, new dynamodb_query_iterator_1.QueryPaginator(client, req, limit), valueConstructor) || this;
	        return _this;
	    }
	    return QueryPaginator;
	}(Paginator_1.Paginator));
	exports.QueryPaginator = QueryPaginator;
	function normalizeKeyCondition(keyCondition) {
	    var e_1, _a;
	    if (dynamodb_expressions_1.isConditionExpression(keyCondition)) {
	        return keyCondition;
	    }
	    var conditions = [];
	    try {
	        for (var _b = tslib_1.__values(Object.keys(keyCondition)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var property = _c.value;
	            var predicate = keyCondition[property];
	            if (dynamodb_expressions_1.isConditionExpressionPredicate(predicate)) {
	                conditions.push(tslib_1.__assign({}, predicate, { subject: property }));
	            }
	            else {
	                conditions.push({
	                    type: 'Equals',
	                    subject: property,
	                    object: predicate,
	                });
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    if (conditions.length === 1) {
	        return conditions[0];
	    }
	    return { type: 'And', conditions: conditions };
	}
	//# sourceMappingURL=QueryPaginator.js.map

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var Iterator_1 = __webpack_require__(101);
	var ScanPaginator_1 = __webpack_require__(150);
	/**
	 * Iterates over each item returned by a DynamoDB scan until no more pages are
	 * available.
	 */
	var ScanIterator = /** @class */ (function (_super) {
	    tslib_1.__extends(ScanIterator, _super);
	    function ScanIterator(client, valueConstructor, options) {
	        return _super.call(this, new ScanPaginator_1.ScanPaginator(client, valueConstructor, options)) || this;
	    }
	    return ScanIterator;
	}(Iterator_1.Iterator));
	exports.ScanIterator = ScanIterator;
	//# sourceMappingURL=ScanIterator.js.map

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var buildScanInput_1 = __webpack_require__(104);
	var Paginator_1 = __webpack_require__(136);
	var dynamodb_query_iterator_1 = __webpack_require__(137);
	/**
	 * Iterates over each page of items returned by a DynamoDB scan until no more
	 * pages are available.
	 */
	var ScanPaginator = /** @class */ (function (_super) {
	    tslib_1.__extends(ScanPaginator, _super);
	    function ScanPaginator(client, itemConstructor, options) {
	        if (options === void 0) { options = {}; }
	        return _super.call(this, new dynamodb_query_iterator_1.ScanPaginator(client, buildScanInput_1.buildScanInput(itemConstructor, options), options.limit), itemConstructor) || this;
	    }
	    return ScanPaginator;
	}(Paginator_1.Paginator));
	exports.ScanPaginator = ScanPaginator;
	//# sourceMappingURL=ScanPaginator.js.map

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	tslib_1.__exportStar(__webpack_require__(152), exports);
	tslib_1.__exportStar(__webpack_require__(154), exports);
	//# sourceMappingURL=index.js.map

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var BatchOperation_1 = __webpack_require__(153);
	exports.MAX_READ_BATCH_SIZE = 100;
	/**
	 * Retrieves items from DynamoDB in batches of 100 or fewer via one or more
	 * BatchGetItem operations. The items may be from any number of tables.
	 *
	 * This method will automatically retry any get requests returned by DynamoDB as
	 * unprocessed. Exponential backoff on unprocessed items is employed on a
	 * per-table basis.
	 */
	var BatchGet = /** @class */ (function (_super) {
	    tslib_1.__extends(BatchGet, _super);
	    /**
	     * @param client    The AWS SDK client with which to communicate with
	     *                  DynamoDB.
	     * @param items     A synchronous or asynchronous iterable of tuples
	     *                  describing the reads to execute. The first member of the
	     *                  tuple should be the name of the table from which to
	     *                  read, and the second should be the marshalled key.
	     * @param options   Additional options to apply to the operations executed.
	     */
	    function BatchGet(client, items, _a) {
	        var _b = _a === void 0 ? {} : _a, ConsistentRead = _b.ConsistentRead, _c = _b.PerTableOptions, PerTableOptions = _c === void 0 ? {} : _c;
	        var _this = _super.call(this, client, items) || this;
	        _this.batchSize = exports.MAX_READ_BATCH_SIZE;
	        _this.consistentRead = ConsistentRead;
	        _this.options = PerTableOptions;
	        return _this;
	    }
	    BatchGet.prototype.doBatchRequest = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var e_1, _a, e_2, _b, e_3, _c, operationInput, batchSize, _d, tableName, item, _e, projection, consistentRead, attributeNames, _f, _g, Responses, _h, UnprocessedKeys, unprocessedTables, _j, _k, table, _l, _m, table, tableData, _o, _p, item;
	            return tslib_1.__generator(this, function (_q) {
	                switch (_q.label) {
	                    case 0:
	                        operationInput = { RequestItems: {} };
	                        batchSize = 0;
	                        while (this.toSend.length > 0) {
	                            _d = tslib_1.__read(this.toSend.shift(), 2), tableName = _d[0], item = _d[1];
	                            if (operationInput.RequestItems[tableName] === undefined) {
	                                _e = this.state[tableName], projection = _e.projection, consistentRead = _e.consistentRead, attributeNames = _e.attributeNames;
	                                operationInput.RequestItems[tableName] = {
	                                    Keys: [],
	                                    ConsistentRead: consistentRead,
	                                    ProjectionExpression: projection,
	                                    ExpressionAttributeNames: attributeNames,
	                                };
	                            }
	                            operationInput.RequestItems[tableName].Keys.push(item);
	                            if (++batchSize === this.batchSize) {
	                                break;
	                            }
	                        }
	                        return [4 /*yield*/, this.client.batchGetItem(operationInput).promise()];
	                    case 1:
	                        _f = _q.sent(), _g = _f.Responses, Responses = _g === void 0 ? {} : _g, _h = _f.UnprocessedKeys, UnprocessedKeys = _h === void 0 ? {} : _h;
	                        unprocessedTables = new Set();
	                        try {
	                            for (_j = tslib_1.__values(Object.keys(UnprocessedKeys)), _k = _j.next(); !_k.done; _k = _j.next()) {
	                                table = _k.value;
	                                unprocessedTables.add(table);
	                                this.handleThrottled(table, UnprocessedKeys[table].Keys);
	                            }
	                        }
	                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                        finally {
	                            try {
	                                if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
	                            }
	                            finally { if (e_1) throw e_1.error; }
	                        }
	                        this.movePendingToThrottled(unprocessedTables);
	                        try {
	                            for (_l = tslib_1.__values(Object.keys(Responses)), _m = _l.next(); !_m.done; _m = _l.next()) {
	                                table = _m.value;
	                                tableData = this.state[table];
	                                tableData.backoffFactor = Math.max(0, tableData.backoffFactor - 1);
	                                try {
	                                    for (_o = tslib_1.__values(Responses[table]), _p = _o.next(); !_p.done; _p = _o.next()) {
	                                        item = _p.value;
	                                        this.pending.push([table, item]);
	                                    }
	                                }
	                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
	                                finally {
	                                    try {
	                                        if (_p && !_p.done && (_c = _o.return)) _c.call(_o);
	                                    }
	                                    finally { if (e_3) throw e_3.error; }
	                                }
	                            }
	                        }
	                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                        finally {
	                            try {
	                                if (_m && !_m.done && (_b = _l.return)) _b.call(_l);
	                            }
	                            finally { if (e_2) throw e_2.error; }
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    BatchGet.prototype.getInitialTableState = function (tableName) {
	        var _a = this.options[tableName] || {}, ExpressionAttributeNames = _a.ExpressionAttributeNames, ProjectionExpression = _a.ProjectionExpression, _b = _a.ConsistentRead, ConsistentRead = _b === void 0 ? this.consistentRead : _b;
	        return tslib_1.__assign({}, _super.prototype.getInitialTableState.call(this, tableName), { attributeNames: ExpressionAttributeNames, projection: ProjectionExpression, consistentRead: ConsistentRead });
	    };
	    return BatchGet;
	}(BatchOperation_1.BatchOperation));
	exports.BatchGet = BatchGet;
	//# sourceMappingURL=BatchGet.js.map

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	if (Symbol && !Symbol.asyncIterator) {
	    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
	}
	var BatchOperation = /** @class */ (function () {
	    /**
	     * @param client    The AWS SDK client with which to communicate with
	     *                  DynamoDB.
	     * @param items     A synchronous or asynchronous iterable of tuples
	     *                  describing the operations to execute. The first member
	     *                  of the tuple should be the name of the table targeted by
	     *                  the operation.
	     */
	    function BatchOperation(client, items) {
	        this.client = client;
	        /**
	         * Items that have been retrieved and are ready to be returned.
	         */
	        this.pending = [];
	        /**
	         * A mapping of table names to table-specific operation state (e.g., the
	         * number of throttling events experienced, etc.)
	         */
	        this.state = {};
	        /**
	         * Input elements that are prepared for immediate dispatch
	         */
	        this.toSend = [];
	        this.throttled = new Set();
	        this.sourceDone = false;
	        if (isIterable(items)) {
	            this.iterator = items[Symbol.iterator]();
	        }
	        else {
	            this.iterator = items[Symbol.asyncIterator]();
	        }
	        this.sourceNext = this.iterator.next();
	    }
	    BatchOperation.prototype.next = function () {
	        var _this = this;
	        if (this.lastResolved) {
	            this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
	        }
	        else {
	            this.lastResolved = this.getNext();
	        }
	        return this.lastResolved;
	    };
	    BatchOperation.prototype[Symbol.asyncIterator] = function () {
	        return this;
	    };
	    /**
	     * Create and return the initial state object for a given DynamoDB table.
	     *
	     * @param tableName The name of the table whose initial state should be
	     *                  returned.
	     */
	    BatchOperation.prototype.getInitialTableState = function (tableName) {
	        return {
	            backoffFactor: 0,
	            name: tableName,
	        };
	    };
	    /**
	     * Accept an array of unprocessed items belonging to a single table and
	     * re-enqueue it for submission, making sure the appropriate level of
	     * backoff is applied to future operations on the same table.
	     *
	     * @param tableName     The table to which the unprocessed elements belong.
	     * @param unprocessed   Elements returned by DynamoDB as not yet processed.
	     *                      The elements should not be unmarshalled, but they
	     *                      should be reverted to the form used for elements
	     *                      that have not yet been sent.
	     */
	    BatchOperation.prototype.handleThrottled = function (tableName, unprocessed) {
	        var tableState = this.state[tableName];
	        tableState.backoffFactor++;
	        if (tableState.tableThrottling) {
	            this.throttled.delete(tableState.tableThrottling.backoffWaiter);
	            unprocessed.unshift.apply(unprocessed, tslib_1.__spread(tableState.tableThrottling.unprocessed));
	        }
	        tableState.tableThrottling = {
	            unprocessed: unprocessed,
	            backoffWaiter: new Promise(function (resolve) {
	                setTimeout(resolve, exponentialBackoff(tableState.backoffFactor), tableState);
	            })
	        };
	        this.throttled.add(tableState.tableThrottling.backoffWaiter);
	    };
	    /**
	     * Iterate over all pending writes and move those targeting throttled tables
	     * into the throttled queue.
	     *
	     * @param unprocessedTables     A set of tables for which some items were
	     *                              returned without being processed.
	     */
	    BatchOperation.prototype.movePendingToThrottled = function (unprocessedTables) {
	        for (var i = this.toSend.length - 1; i > -1; i--) {
	            var _a = tslib_1.__read(this.toSend[i], 2), table = _a[0], attributes = _a[1];
	            if (unprocessedTables.has(table)) {
	                this.state[table]
	                    .tableThrottling.unprocessed.push(attributes);
	                this.toSend.splice(i, 1);
	            }
	        }
	    };
	    BatchOperation.prototype.addToSendQueue = function (_a) {
	        var _b = tslib_1.__read(_a, 2), tableName = _b[0], attributes = _b[1];
	        if (!this.state[tableName]) {
	            this.state[tableName] = this.getInitialTableState(tableName);
	        }
	        var tableState = this.state[tableName];
	        if (tableState.tableThrottling) {
	            tableState.tableThrottling.unprocessed.push(attributes);
	        }
	        else {
	            this.toSend.push([tableName, attributes]);
	        }
	    };
	    BatchOperation.prototype.enqueueThrottled = function (table) {
	        var _a;
	        var _b = table.tableThrottling, backoffWaiter = _b.backoffWaiter, unprocessed = _b.unprocessed;
	        if (unprocessed.length > 0) {
	            (_a = this.toSend).push.apply(_a, tslib_1.__spread(unprocessed.map(function (attr) { return [table.name, attr]; })));
	        }
	        this.throttled.delete(backoffWaiter);
	        delete table.tableThrottling;
	    };
	    BatchOperation.prototype.getNext = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            return tslib_1.__generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (this.sourceDone &&
	                            this.pending.length === 0 &&
	                            this.toSend.length === 0 &&
	                            this.throttled.size === 0) {
	                            return [2 /*return*/, { done: true }];
	                        }
	                        if (this.pending.length > 0) {
	                            return [2 /*return*/, {
	                                    done: false,
	                                    value: this.pending.shift()
	                                }];
	                        }
	                        return [4 /*yield*/, this.refillPending()];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, this.getNext()];
	                }
	            });
	        });
	    };
	    BatchOperation.prototype.refillPending = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var toProcess, _a, _b;
	            return tslib_1.__generator(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        if (!(!this.sourceDone &&
	                            this.toSend.length < this.batchSize)) return [3 /*break*/, 4];
	                        if (!isIteratorResult(this.sourceNext)) return [3 /*break*/, 1];
	                        _a = this.sourceNext;
	                        return [3 /*break*/, 3];
	                    case 1: return [4 /*yield*/, Promise.race([
	                            this.sourceNext,
	                            Promise.race(this.throttled)
	                        ])];
	                    case 2:
	                        _a = _c.sent();
	                        _c.label = 3;
	                    case 3:
	                        toProcess = _a;
	                        if (isIteratorResult(toProcess)) {
	                            this.sourceDone = toProcess.done;
	                            if (!this.sourceDone) {
	                                this.addToSendQueue(toProcess.value);
	                                this.sourceNext = this.iterator.next();
	                            }
	                        }
	                        else {
	                            this.enqueueThrottled(toProcess);
	                        }
	                        return [3 /*break*/, 0];
	                    case 4:
	                        if (!(this.toSend.length < this.batchSize && this.throttled.size > 0)) return [3 /*break*/, 6];
	                        _b = this.enqueueThrottled;
	                        return [4 /*yield*/, Promise.race(this.throttled)];
	                    case 5:
	                        _b.apply(this, [_c.sent()]);
	                        return [3 /*break*/, 4];
	                    case 6:
	                        if (!(this.toSend.length > 0)) return [3 /*break*/, 8];
	                        return [4 /*yield*/, this.doBatchRequest()];
	                    case 7:
	                        _c.sent();
	                        _c.label = 8;
	                    case 8: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    return BatchOperation;
	}());
	exports.BatchOperation = BatchOperation;
	function exponentialBackoff(attempts) {
	    return Math.floor(Math.random() * Math.pow(2, attempts));
	}
	function isIterable(arg) {
	    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
	}
	function isIteratorResult(arg) {
	    return Boolean(arg) && typeof arg.done === 'boolean';
	}
	//# sourceMappingURL=BatchOperation.js.map

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var BatchOperation_1 = __webpack_require__(153);
	var itemIdentifier_1 = __webpack_require__(155);
	exports.MAX_WRITE_BATCH_SIZE = 25;
	/**
	 * Puts or deletes items from DynamoDB in batches of 25 or fewer via one or more
	 * BatchWriteItem operations. The items may belong to any number of tables.
	 *
	 * The iterable of writes to perform may be synchronous or asynchronous and is
	 * expected to yield tuples describing the writes to be performed. The first
	 * member should be the table name, and the second should be {WriteRequest}
	 * object that defines either a put request or a delete request.
	 *
	 * This method will automatically retry any write requests returned by DynamoDB
	 * as unprocessed. Exponential backoff on unprocessed items is employed on a
	 * per-table basis.
	 */
	var BatchWrite = /** @class */ (function (_super) {
	    tslib_1.__extends(BatchWrite, _super);
	    function BatchWrite() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.batchSize = exports.MAX_WRITE_BATCH_SIZE;
	        return _this;
	    }
	    BatchWrite.prototype.doBatchRequest = function () {
	        return tslib_1.__awaiter(this, void 0, void 0, function () {
	            var e_1, _a, e_2, _b, e_3, _c, e_4, _d, inFlight, operationInput, batchSize, _e, tableName, marshalled, _f, UnprocessedItems, unprocessedTables, _g, _h, table, unprocessed, _j, _k, item, identifier, i, _l, tableName, attributes, processedTables, inFlight_1, inFlight_1_1, _m, tableName, marshalled, processedTables_1, processedTables_1_1, tableName;
	            return tslib_1.__generator(this, function (_o) {
	                switch (_o.label) {
	                    case 0:
	                        inFlight = [];
	                        operationInput = { RequestItems: {} };
	                        batchSize = 0;
	                        while (this.toSend.length > 0) {
	                            _e = tslib_1.__read(this.toSend.shift(), 2), tableName = _e[0], marshalled = _e[1];
	                            inFlight.push([tableName, marshalled]);
	                            if (operationInput.RequestItems[tableName] === undefined) {
	                                operationInput.RequestItems[tableName] = [];
	                            }
	                            operationInput.RequestItems[tableName].push(marshalled);
	                            if (++batchSize === this.batchSize) {
	                                break;
	                            }
	                        }
	                        return [4 /*yield*/, this.client.batchWriteItem(operationInput).promise()];
	                    case 1:
	                        _f = (_o.sent()).UnprocessedItems, UnprocessedItems = _f === void 0 ? {} : _f;
	                        unprocessedTables = new Set();
	                        try {
	                            for (_g = tslib_1.__values(Object.keys(UnprocessedItems)), _h = _g.next(); !_h.done; _h = _g.next()) {
	                                table = _h.value;
	                                unprocessedTables.add(table);
	                                unprocessed = [];
	                                try {
	                                    for (_j = tslib_1.__values(UnprocessedItems[table]), _k = _j.next(); !_k.done; _k = _j.next()) {
	                                        item = _k.value;
	                                        if (item.DeleteRequest || item.PutRequest) {
	                                            unprocessed.push(item);
	                                            identifier = itemIdentifier_1.itemIdentifier(table, item);
	                                            for (i = inFlight.length - 1; i >= 0; i--) {
	                                                _l = tslib_1.__read(inFlight[i], 2), tableName = _l[0], attributes = _l[1];
	                                                if (tableName === table &&
	                                                    itemIdentifier_1.itemIdentifier(tableName, attributes) === identifier) {
	                                                    inFlight.splice(i, 1);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                                finally {
	                                    try {
	                                        if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
	                                    }
	                                    finally { if (e_2) throw e_2.error; }
	                                }
	                                this.handleThrottled(table, unprocessed);
	                            }
	                        }
	                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                        finally {
	                            try {
	                                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
	                            }
	                            finally { if (e_1) throw e_1.error; }
	                        }
	                        this.movePendingToThrottled(unprocessedTables);
	                        processedTables = new Set();
	                        try {
	                            for (inFlight_1 = tslib_1.__values(inFlight), inFlight_1_1 = inFlight_1.next(); !inFlight_1_1.done; inFlight_1_1 = inFlight_1.next()) {
	                                _m = tslib_1.__read(inFlight_1_1.value, 2), tableName = _m[0], marshalled = _m[1];
	                                processedTables.add(tableName);
	                                this.pending.push([tableName, marshalled]);
	                            }
	                        }
	                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	                        finally {
	                            try {
	                                if (inFlight_1_1 && !inFlight_1_1.done && (_c = inFlight_1.return)) _c.call(inFlight_1);
	                            }
	                            finally { if (e_3) throw e_3.error; }
	                        }
	                        try {
	                            for (processedTables_1 = tslib_1.__values(processedTables), processedTables_1_1 = processedTables_1.next(); !processedTables_1_1.done; processedTables_1_1 = processedTables_1.next()) {
	                                tableName = processedTables_1_1.value;
	                                this.state[tableName].backoffFactor =
	                                    Math.max(0, this.state[tableName].backoffFactor - 1);
	                            }
	                        }
	                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	                        finally {
	                            try {
	                                if (processedTables_1_1 && !processedTables_1_1.done && (_d = processedTables_1.return)) _d.call(processedTables_1);
	                            }
	                            finally { if (e_4) throw e_4.error; }
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    return BatchWrite;
	}(BatchOperation_1.BatchOperation));
	exports.BatchWrite = BatchWrite;
	//# sourceMappingURL=BatchWrite.js.map

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(96);
	var bytes = __webpack_require__(130);
	/**
	 * @internal
	 */
	function itemIdentifier(tableName, _a) {
	    var DeleteRequest = _a.DeleteRequest, PutRequest = _a.PutRequest;
	    if (DeleteRequest) {
	        return tableName + "::delete::" + serializeKeyTypeAttributes(DeleteRequest.Key);
	    }
	    else if (PutRequest) {
	        return tableName + "::put::" + serializeKeyTypeAttributes(PutRequest.Item);
	    }
	    throw new Error("Invalid write request provided");
	}
	exports.itemIdentifier = itemIdentifier;
	function serializeKeyTypeAttributes(attributes) {
	    var e_1, _a;
	    var keyTypeProperties = [];
	    try {
	        for (var _b = tslib_1.__values(Object.keys(attributes).sort()), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var property = _c.value;
	            var attribute = attributes[property];
	            if (attribute.B) {
	                keyTypeProperties.push(property + "=" + toByteArray(attribute.B));
	            }
	            else if (attribute.N) {
	                keyTypeProperties.push(property + "=" + attribute.N);
	            }
	            else if (attribute.S) {
	                keyTypeProperties.push(property + "=" + attribute.S);
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    return keyTypeProperties.join('&');
	}
	function toByteArray(value) {
	    if (ArrayBuffer.isView(value)) {
	        return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
	    }
	    if (typeof value === 'string') {
	        return Uint8Array.from(bytes(value));
	    }
	    if (isArrayBuffer(value)) {
	        return new Uint8Array(value);
	    }
	    throw new Error('Unrecognized binary type');
	}
	function isArrayBuffer(arg) {
	    return (typeof ArrayBuffer === 'function' && arg instanceof ArrayBuffer) ||
	        Object.prototype.toString.call(arg) === '[object ArrayBuffer]';
	}
	//# sourceMappingURL=itemIdentifier.js.map

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var protocols_1 = __webpack_require__(135);
	function embed(documentConstructor, _a) {
	    var _b = _a === void 0 ? {} : _a, attributeName = _b.attributeName, defaultProvider = _b.defaultProvider;
	    return {
	        type: 'Document',
	        members: documentConstructor.prototype[protocols_1.DynamoDbSchema] || {},
	        attributeName: attributeName,
	        defaultProvider: defaultProvider,
	        valueConstructor: documentConstructor
	    };
	}
	exports.embed = embed;
	//# sourceMappingURL=embed.js.map

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(158);
	var AWS = __webpack_require__(160);
	var Service = AWS.Service;
	var apiLoader = AWS.apiLoader;

	apiLoader.services['dynamodb'] = {};
	AWS.DynamoDB = Service.defineService('dynamodb', ['2011-12-05', '2012-08-10']);
	__webpack_require__(292);
	Object.defineProperty(apiLoader.services['dynamodb'], '2011-12-05', {
	  get: function get() {
	    var model = __webpack_require__(299);
	    model.paginators = __webpack_require__(300).pagination;
	    model.waiters = __webpack_require__(301).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});
	Object.defineProperty(apiLoader.services['dynamodb'], '2012-08-10', {
	  get: function get() {
	    var model = __webpack_require__(302);
	    model.paginators = __webpack_require__(303).pagination;
	    model.waiters = __webpack_require__(304).waiters;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.DynamoDB;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);

	// node.js specific modules
	util.crypto.lib = __webpack_require__(210);
	util.Buffer = __webpack_require__(213).Buffer;
	util.domain = __webpack_require__(214);
	util.stream = __webpack_require__(215);
	util.url = __webpack_require__(216);
	util.querystring = __webpack_require__(217);
	util.environment = 'nodejs';
	util.createEventStream = util.stream.Readable ?
	  __webpack_require__(218).createEventStream : __webpack_require__(227).createEventStream;
	util.realClock = __webpack_require__(229);
	util.clientSideMonitoring = {
	  Publisher: __webpack_require__(230).Publisher,
	  configProvider: __webpack_require__(233),
	}

	var AWS;

	/**
	 * @api private
	 */
	module.exports = AWS = __webpack_require__(160);

	__webpack_require__(186);
	__webpack_require__(187);
	__webpack_require__(237);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(248);

	// Load the xml2js XML parser
	AWS.XML.Parser = __webpack_require__(249);

	// Load Node HTTP client
	__webpack_require__(282);

	// Load custom credential providers
	__webpack_require__(285);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(290);
	__webpack_require__(291);

	var SharedIniFile = __webpack_require__(234);

	// Setup default chain providers
	// If this changes, please update documentation for
	// AWS.CredentialProviderChain.defaultProviders in
	// credentials/credential_provider_chain.js
	AWS.CredentialProviderChain.defaultProviders = [
	  function () { return new AWS.EnvironmentCredentials('AWS'); },
	  function () { return new AWS.EnvironmentCredentials('AMAZON'); },
	  function () { return new AWS.SharedIniFileCredentials(); },
	  function () {
	    if (AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials()) {
	      return new AWS.ECSCredentials();
	    }
	    return new AWS.EC2MetadataCredentials();
	  }
	];

	// Update configuration keys
	AWS.util.update(AWS.Config.prototype.keys, {
	  credentials: function () {
	    var credentials = null;
	    new AWS.CredentialProviderChain([
	      function () { return new AWS.EnvironmentCredentials('AWS'); },
	      function () { return new AWS.EnvironmentCredentials('AMAZON'); },
	      function () { return new AWS.SharedIniFileCredentials({ disableAssumeRole: true }); }
	    ]).resolve(function(err, creds) {
	      if (!err) credentials = creds;
	    });
	    return credentials;
	  },
	  credentialProvider: function() {
	    return new AWS.CredentialProviderChain();
	  },
	  logger: function () {
	    return process.env.AWSJS_DEBUG ? console : null;
	  },
	  region: function() {
	    var env = process.env;
	    var region = env.AWS_REGION || env.AMAZON_REGION;
	    if (env[AWS.util.configOptInEnv]) {
	      var toCheck = [
	        {filename: env[AWS.util.sharedCredentialsFileEnv]},
	        {isConfig: true, filename: env[AWS.util.sharedConfigFileEnv]}
	      ];
	      while (!region && toCheck.length) {
	        var configFile = new SharedIniFile(toCheck.shift());
	        var profile = configFile.getProfile(
	          env.AWS_PROFILE || AWS.util.defaultProfile
	        );
	        region = profile && profile.region;
	      }
	    }
	    return region;
	  }
	});

	// Reset configuration
	AWS.config = new AWS.Config();


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint guard-for-in:0 */
	var AWS;

	/**
	 * A set of utility methods for use with the AWS SDK.
	 *
	 * @!attribute abort
	 *   Return this value from an iterator function {each} or {arrayEach}
	 *   to break out of the iteration.
	 *   @example Breaking out of an iterator function
	 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
	 *       if (key == 'b') return AWS.util.abort;
	 *     });
	 *   @see each
	 *   @see arrayEach
	 * @api private
	 */
	var util = {
	  environment: 'nodejs',
	  engine: function engine() {
	    if (util.isBrowser() && typeof navigator !== 'undefined') {
	      return navigator.userAgent;
	    } else {
	      var engine = process.platform + '/' + process.version;
	      if (process.env.AWS_EXECUTION_ENV) {
	        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
	      }
	      return engine;
	    }
	  },

	  userAgent: function userAgent() {
	    var name = util.environment;
	    var agent = 'aws-sdk-' + name + '/' + __webpack_require__(160).VERSION;
	    if (name === 'nodejs') agent += ' ' + util.engine();
	    return agent;
	  },

	  isBrowser: function isBrowser() { return process && process.browser; },
	  isNode: function isNode() { return !util.isBrowser(); },
	  uriEscape: function uriEscape(string) {
	    var output = encodeURIComponent(string);
	    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

	    // AWS percent-encodes some extra non-standard characters in a URI
	    output = output.replace(/[*]/g, function(ch) {
	      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
	    });

	    return output;
	  },

	  uriEscapePath: function uriEscapePath(string) {
	    var parts = [];
	    util.arrayEach(string.split('/'), function (part) {
	      parts.push(util.uriEscape(part));
	    });
	    return parts.join('/');
	  },

	  urlParse: function urlParse(url) {
	    return util.url.parse(url);
	  },

	  urlFormat: function urlFormat(url) {
	    return util.url.format(url);
	  },

	  queryStringParse: function queryStringParse(qs) {
	    return util.querystring.parse(qs);
	  },

	  queryParamsToString: function queryParamsToString(params) {
	    var items = [];
	    var escape = util.uriEscape;
	    var sortedKeys = Object.keys(params).sort();

	    util.arrayEach(sortedKeys, function(name) {
	      var value = params[name];
	      var ename = escape(name);
	      var result = ename + '=';
	      if (Array.isArray(value)) {
	        var vals = [];
	        util.arrayEach(value, function(item) { vals.push(escape(item)); });
	        result = ename + '=' + vals.sort().join('&' + ename + '=');
	      } else if (value !== undefined && value !== null) {
	        result = ename + '=' + escape(value);
	      }
	      items.push(result);
	    });

	    return items.join('&');
	  },

	  readFileSync: function readFileSync(path) {
	    if (util.isBrowser()) return null;
	    return __webpack_require__(205).readFileSync(path, 'utf-8');
	  },

	  base64: {
	    encode: function encode64(string) {
	      if (typeof string === 'number') {
	        throw util.error(new Error('Cannot base64 encode number ' + string));
	      }
	      if (string === null || typeof string === 'undefined') {
	        return string;
	      }
	      var buf = (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ? util.Buffer.from(string) : new util.Buffer(string);
	      return buf.toString('base64');
	    },

	    decode: function decode64(string) {
	      if (typeof string === 'number') {
	        throw util.error(new Error('Cannot base64 decode number ' + string));
	      }
	      if (string === null || typeof string === 'undefined') {
	        return string;
	      }
	      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ? util.Buffer.from(string, 'base64') : new util.Buffer(string, 'base64');
	    }

	  },

	  buffer: {
	    toStream: function toStream(buffer) {
	      if (!util.Buffer.isBuffer(buffer)) buffer = new util.Buffer(buffer);

	      var readable = new (util.stream.Readable)();
	      var pos = 0;
	      readable._read = function(size) {
	        if (pos >= buffer.length) return readable.push(null);

	        var end = pos + size;
	        if (end > buffer.length) end = buffer.length;
	        readable.push(buffer.slice(pos, end));
	        pos = end;
	      };

	      return readable;
	    },

	    /**
	     * Concatenates a list of Buffer objects.
	     */
	    concat: function(buffers) {
	      var length = 0,
	          offset = 0,
	          buffer = null, i;

	      for (i = 0; i < buffers.length; i++) {
	        length += buffers[i].length;
	      }

	      buffer = new util.Buffer(length);

	      for (i = 0; i < buffers.length; i++) {
	        buffers[i].copy(buffer, offset);
	        offset += buffers[i].length;
	      }

	      return buffer;
	    }
	  },

	  string: {
	    byteLength: function byteLength(string) {
	      if (string === null || string === undefined) return 0;
	      if (typeof string === 'string') string = new util.Buffer(string);

	      if (typeof string.byteLength === 'number') {
	        return string.byteLength;
	      } else if (typeof string.length === 'number') {
	        return string.length;
	      } else if (typeof string.size === 'number') {
	        return string.size;
	      } else if (typeof string.path === 'string') {
	        return __webpack_require__(205).lstatSync(string.path).size;
	      } else {
	        throw util.error(new Error('Cannot determine length of ' + string),
	          { object: string });
	      }
	    },

	    upperFirst: function upperFirst(string) {
	      return string[0].toUpperCase() + string.substr(1);
	    },

	    lowerFirst: function lowerFirst(string) {
	      return string[0].toLowerCase() + string.substr(1);
	    }
	  },

	  ini: {
	    parse: function string(ini) {
	      var currentSection, map = {};
	      util.arrayEach(ini.split(/\r?\n/), function(line) {
	        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
	        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
	        if (section) {
	          currentSection = section[1];
	        } else if (currentSection) {
	          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
	          if (item) {
	            map[currentSection] = map[currentSection] || {};
	            map[currentSection][item[1]] = item[2];
	          }
	        }
	      });

	      return map;
	    }
	  },

	  fn: {
	    noop: function() {},

	    /**
	     * Turn a synchronous function into as "async" function by making it call
	     * a callback. The underlying function is called with all but the last argument,
	     * which is treated as the callback. The callback is passed passed a first argument
	     * of null on success to mimick standard node callbacks.
	     */
	    makeAsync: function makeAsync(fn, expectedArgs) {
	      if (expectedArgs && expectedArgs <= fn.length) {
	        return fn;
	      }

	      return function() {
	        var args = Array.prototype.slice.call(arguments, 0);
	        var callback = args.pop();
	        var result = fn.apply(null, args);
	        callback(result);
	      };
	    }
	  },

	  /**
	   * Date and time utility functions.
	   */
	  date: {

	    /**
	     * @return [Date] the current JavaScript date object. Since all
	     *   AWS services rely on this date object, you can override
	     *   this function to provide a special time value to AWS service
	     *   requests.
	     */
	    getDate: function getDate() {
	      if (!AWS) AWS = __webpack_require__(160);
	      if (AWS.config.systemClockOffset) { // use offset when non-zero
	        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
	      } else {
	        return new Date();
	      }
	    },

	    /**
	     * @return [String] the date in ISO-8601 format
	     */
	    iso8601: function iso8601(date) {
	      if (date === undefined) { date = util.date.getDate(); }
	      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
	    },

	    /**
	     * @return [String] the date in RFC 822 format
	     */
	    rfc822: function rfc822(date) {
	      if (date === undefined) { date = util.date.getDate(); }
	      return date.toUTCString();
	    },

	    /**
	     * @return [Integer] the UNIX timestamp value for the current time
	     */
	    unixTimestamp: function unixTimestamp(date) {
	      if (date === undefined) { date = util.date.getDate(); }
	      return date.getTime() / 1000;
	    },

	    /**
	     * @param [String,number,Date] date
	     * @return [Date]
	     */
	    from: function format(date) {
	      if (typeof date === 'number') {
	        return new Date(date * 1000); // unix timestamp
	      } else {
	        return new Date(date);
	      }
	    },

	    /**
	     * Given a Date or date-like value, this function formats the
	     * date into a string of the requested value.
	     * @param [String,number,Date] date
	     * @param [String] formatter Valid formats are:
	     #   * 'iso8601'
	     #   * 'rfc822'
	     #   * 'unixTimestamp'
	     * @return [String]
	     */
	    format: function format(date, formatter) {
	      if (!formatter) formatter = 'iso8601';
	      return util.date[formatter](util.date.from(date));
	    },

	    parseTimestamp: function parseTimestamp(value) {
	      if (typeof value === 'number') { // unix timestamp (number)
	        return new Date(value * 1000);
	      } else if (value.match(/^\d+$/)) { // unix timestamp
	        return new Date(value * 1000);
	      } else if (value.match(/^\d{4}/)) { // iso8601
	        return new Date(value);
	      } else if (value.match(/^\w{3},/)) { // rfc822
	        return new Date(value);
	      } else {
	        throw util.error(
	          new Error('unhandled timestamp format: ' + value),
	          {code: 'TimestampParserError'});
	      }
	    }

	  },

	  crypto: {
	    crc32Table: [
	     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
	     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
	     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
	     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
	     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
	     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
	     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
	     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
	     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
	     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
	     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
	     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
	     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
	     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
	     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
	     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
	     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
	     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
	     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
	     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
	     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
	     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
	     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
	     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
	     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
	     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
	     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
	     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
	     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
	     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
	     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
	     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
	     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
	     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
	     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
	     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
	     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
	     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
	     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
	     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
	     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
	     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
	     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
	     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
	     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
	     0x2D02EF8D],

	    crc32: function crc32(data) {
	      var tbl = util.crypto.crc32Table;
	      var crc = 0 ^ -1;

	      if (typeof data === 'string') {
	        data = new util.Buffer(data);
	      }

	      for (var i = 0; i < data.length; i++) {
	        var code = data.readUInt8(i);
	        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
	      }
	      return (crc ^ -1) >>> 0;
	    },

	    hmac: function hmac(key, string, digest, fn) {
	      if (!digest) digest = 'binary';
	      if (digest === 'buffer') { digest = undefined; }
	      if (!fn) fn = 'sha256';
	      if (typeof string === 'string') string = new util.Buffer(string);
	      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
	    },

	    md5: function md5(data, digest, callback) {
	      return util.crypto.hash('md5', data, digest, callback);
	    },

	    sha256: function sha256(data, digest, callback) {
	      return util.crypto.hash('sha256', data, digest, callback);
	    },

	    hash: function(algorithm, data, digest, callback) {
	      var hash = util.crypto.createHash(algorithm);
	      if (!digest) { digest = 'binary'; }
	      if (digest === 'buffer') { digest = undefined; }
	      if (typeof data === 'string') data = new util.Buffer(data);
	      var sliceFn = util.arraySliceFn(data);
	      var isBuffer = util.Buffer.isBuffer(data);
	      //Identifying objects with an ArrayBuffer as buffers
	      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

	      if (callback && typeof data === 'object' &&
	          typeof data.on === 'function' && !isBuffer) {
	        data.on('data', function(chunk) { hash.update(chunk); });
	        data.on('error', function(err) { callback(err); });
	        data.on('end', function() { callback(null, hash.digest(digest)); });
	      } else if (callback && sliceFn && !isBuffer &&
	                 typeof FileReader !== 'undefined') {
	        // this might be a File/Blob
	        var index = 0, size = 1024 * 512;
	        var reader = new FileReader();
	        reader.onerror = function() {
	          callback(new Error('Failed to read data.'));
	        };
	        reader.onload = function() {
	          var buf = new util.Buffer(new Uint8Array(reader.result));
	          hash.update(buf);
	          index += buf.length;
	          reader._continueReading();
	        };
	        reader._continueReading = function() {
	          if (index >= data.size) {
	            callback(null, hash.digest(digest));
	            return;
	          }

	          var back = index + size;
	          if (back > data.size) back = data.size;
	          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
	        };

	        reader._continueReading();
	      } else {
	        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
	          data = new util.Buffer(new Uint8Array(data));
	        }
	        var out = hash.update(data).digest(digest);
	        if (callback) callback(null, out);
	        return out;
	      }
	    },

	    toHex: function toHex(data) {
	      var out = [];
	      for (var i = 0; i < data.length; i++) {
	        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
	      }
	      return out.join('');
	    },

	    createHash: function createHash(algorithm) {
	      return util.crypto.lib.createHash(algorithm);
	    }

	  },

	  /** @!ignore */

	  /* Abort constant */
	  abort: {},

	  each: function each(object, iterFunction) {
	    for (var key in object) {
	      if (Object.prototype.hasOwnProperty.call(object, key)) {
	        var ret = iterFunction.call(this, key, object[key]);
	        if (ret === util.abort) break;
	      }
	    }
	  },

	  arrayEach: function arrayEach(array, iterFunction) {
	    for (var idx in array) {
	      if (Object.prototype.hasOwnProperty.call(array, idx)) {
	        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
	        if (ret === util.abort) break;
	      }
	    }
	  },

	  update: function update(obj1, obj2) {
	    util.each(obj2, function iterator(key, item) {
	      obj1[key] = item;
	    });
	    return obj1;
	  },

	  merge: function merge(obj1, obj2) {
	    return util.update(util.copy(obj1), obj2);
	  },

	  copy: function copy(object) {
	    if (object === null || object === undefined) return object;
	    var dupe = {};
	    // jshint forin:false
	    for (var key in object) {
	      dupe[key] = object[key];
	    }
	    return dupe;
	  },

	  isEmpty: function isEmpty(obj) {
	    for (var prop in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
	        return false;
	      }
	    }
	    return true;
	  },

	  arraySliceFn: function arraySliceFn(obj) {
	    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
	    return typeof fn === 'function' ? fn : null;
	  },

	  isType: function isType(obj, type) {
	    // handle cross-"frame" objects
	    if (typeof type === 'function') type = util.typeName(type);
	    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
	  },

	  typeName: function typeName(type) {
	    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
	    var str = type.toString();
	    var match = str.match(/^\s*function (.+)\(/);
	    return match ? match[1] : str;
	  },

	  error: function error(err, options) {
	    var originalError = null;
	    if (typeof err.message === 'string' && err.message !== '') {
	      if (typeof options === 'string' || (options && options.message)) {
	        originalError = util.copy(err);
	        originalError.message = err.message;
	      }
	    }
	    err.message = err.message || null;

	    if (typeof options === 'string') {
	      err.message = options;
	    } else if (typeof options === 'object' && options !== null) {
	      util.update(err, options);
	      if (options.message)
	        err.message = options.message;
	      if (options.code || options.name)
	        err.code = options.code || options.name;
	      if (options.stack)
	        err.stack = options.stack;
	    }

	    if (typeof Object.defineProperty === 'function') {
	      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
	      Object.defineProperty(err, 'message', {enumerable: true});
	    }

	    err.name = options && options.name || err.name || err.code || 'Error';
	    err.time = new Date();

	    if (originalError) err.originalError = originalError;

	    return err;
	  },

	  /**
	   * @api private
	   */
	  inherit: function inherit(klass, features) {
	    var newObject = null;
	    if (features === undefined) {
	      features = klass;
	      klass = Object;
	      newObject = {};
	    } else {
	      var ctor = function ConstructorWrapper() {};
	      ctor.prototype = klass.prototype;
	      newObject = new ctor();
	    }

	    // constructor not supplied, create pass-through ctor
	    if (features.constructor === Object) {
	      features.constructor = function() {
	        if (klass !== Object) {
	          return klass.apply(this, arguments);
	        }
	      };
	    }

	    features.constructor.prototype = newObject;
	    util.update(features.constructor.prototype, features);
	    features.constructor.__super__ = klass;
	    return features.constructor;
	  },

	  /**
	   * @api private
	   */
	  mixin: function mixin() {
	    var klass = arguments[0];
	    for (var i = 1; i < arguments.length; i++) {
	      // jshint forin:false
	      for (var prop in arguments[i].prototype) {
	        var fn = arguments[i].prototype[prop];
	        if (prop !== 'constructor') {
	          klass.prototype[prop] = fn;
	        }
	      }
	    }
	    return klass;
	  },

	  /**
	   * @api private
	   */
	  hideProperties: function hideProperties(obj, props) {
	    if (typeof Object.defineProperty !== 'function') return;

	    util.arrayEach(props, function (key) {
	      Object.defineProperty(obj, key, {
	        enumerable: false, writable: true, configurable: true });
	    });
	  },

	  /**
	   * @api private
	   */
	  property: function property(obj, name, value, enumerable, isValue) {
	    var opts = {
	      configurable: true,
	      enumerable: enumerable !== undefined ? enumerable : true
	    };
	    if (typeof value === 'function' && !isValue) {
	      opts.get = value;
	    }
	    else {
	      opts.value = value; opts.writable = true;
	    }

	    Object.defineProperty(obj, name, opts);
	  },

	  /**
	   * @api private
	   */
	  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
	    var cachedValue = null;

	    // build enumerable attribute for each value with lazy accessor.
	    util.property(obj, name, function() {
	      if (cachedValue === null) {
	        cachedValue = get();
	      }
	      return cachedValue;
	    }, enumerable);
	  },

	  /**
	   * TODO Remove in major version revision
	   * This backfill populates response data without the
	   * top-level payload name.
	   *
	   * @api private
	   */
	  hoistPayloadMember: function hoistPayloadMember(resp) {
	    var req = resp.request;
	    var operationName = req.operation;
	    var operation = req.service.api.operations[operationName];
	    var output = operation.output;
	    if (output.payload && !operation.hasEventOutput) {
	      var payloadMember = output.members[output.payload];
	      var responsePayload = resp.data[output.payload];
	      if (payloadMember.type === 'structure') {
	        util.each(responsePayload, function(key, value) {
	          util.property(resp.data, key, value, false);
	        });
	      }
	    }
	  },

	  /**
	   * Compute SHA-256 checksums of streams
	   *
	   * @api private
	   */
	  computeSha256: function computeSha256(body, done) {
	    if (util.isNode()) {
	      var Stream = util.stream.Stream;
	      var fs = __webpack_require__(205);
	      if (body instanceof Stream) {
	        if (typeof body.path === 'string') { // assume file object
	          var settings = {};
	          if (typeof body.start === 'number') {
	            settings.start = body.start;
	          }
	          if (typeof body.end === 'number') {
	            settings.end = body.end;
	          }
	          body = fs.createReadStream(body.path, settings);
	        } else { // TODO support other stream types
	          return done(new Error('Non-file stream objects are ' +
	                                'not supported with SigV4'));
	        }
	      }
	    }

	    util.crypto.sha256(body, 'hex', function(err, sha) {
	      if (err) done(err);
	      else done(null, sha);
	    });
	  },

	  /**
	   * @api private
	   */
	  isClockSkewed: function isClockSkewed(serverTime) {
	    if (serverTime) {
	      util.property(AWS.config, 'isClockSkewed',
	        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
	      return AWS.config.isClockSkewed;
	    }
	  },

	  applyClockOffset: function applyClockOffset(serverTime) {
	    if (serverTime)
	      AWS.config.systemClockOffset = serverTime - new Date().getTime();
	  },

	  /**
	   * @api private
	   */
	  extractRequestId: function extractRequestId(resp) {
	    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
	                     resp.httpResponse.headers['x-amzn-requestid'];

	    if (!requestId && resp.data && resp.data.ResponseMetadata) {
	      requestId = resp.data.ResponseMetadata.RequestId;
	    }

	    if (requestId) {
	      resp.requestId = requestId;
	    }

	    if (resp.error) {
	      resp.error.requestId = requestId;
	    }
	  },

	  /**
	   * @api private
	   */
	  addPromises: function addPromises(constructors, PromiseDependency) {
	    var deletePromises = false;
	    if (PromiseDependency === undefined && AWS && AWS.config) {
	      PromiseDependency = AWS.config.getPromisesDependency();
	    }
	    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
	      PromiseDependency = Promise;
	    }
	    if (typeof PromiseDependency !== 'function') deletePromises = true;
	    if (!Array.isArray(constructors)) constructors = [constructors];

	    for (var ind = 0; ind < constructors.length; ind++) {
	      var constructor = constructors[ind];
	      if (deletePromises) {
	        if (constructor.deletePromisesFromClass) {
	          constructor.deletePromisesFromClass();
	        }
	      } else if (constructor.addPromisesToClass) {
	        constructor.addPromisesToClass(PromiseDependency);
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
	    return function promise() {
	      var self = this;
	      return new PromiseDependency(function(resolve, reject) {
	        self[methodName](function(err, data) {
	          if (err) {
	            reject(err);
	          } else {
	            resolve(data);
	          }
	        });
	      });
	    };
	  },

	  /**
	   * @api private
	   */
	  isDualstackAvailable: function isDualstackAvailable(service) {
	    if (!service) return false;
	    var metadata = __webpack_require__(206);
	    if (typeof service !== 'string') service = service.serviceIdentifier;
	    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
	    return !!metadata[service].dualstackAvailable;
	  },

	  /**
	   * @api private
	   */
	  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions) {
	    if (!retryDelayOptions) retryDelayOptions = {};
	    var customBackoff = retryDelayOptions.customBackoff || null;
	    if (typeof customBackoff === 'function') {
	      return customBackoff(retryCount);
	    }
	    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
	    var delay = Math.random() * (Math.pow(2, retryCount) * base);
	    return delay;
	  },

	  /**
	   * @api private
	   */
	  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
	    if (!options) options = {};
	    var http = AWS.HttpClient.getInstance();
	    var httpOptions = options.httpOptions || {};
	    var retryCount = 0;

	    var errCallback = function(err) {
	      var maxRetries = options.maxRetries || 0;
	      if (err && err.code === 'TimeoutError') err.retryable = true;
	      if (err && err.retryable && retryCount < maxRetries) {
	        retryCount++;
	        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions);
	        setTimeout(sendRequest, delay + (err.retryAfter || 0));
	      } else {
	        cb(err);
	      }
	    };

	    var sendRequest = function() {
	      var data = '';
	      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
	        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
	        httpResponse.on('end', function() {
	          var statusCode = httpResponse.statusCode;
	          if (statusCode < 300) {
	            cb(null, data);
	          } else {
	            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
	            var err = util.error(new Error(),
	              { retryable: statusCode >= 500 || statusCode === 429 }
	            );
	            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
	            errCallback(err);
	          }
	        });
	      }, errCallback);
	    };

	    AWS.util.defer(sendRequest);
	  },

	  /**
	   * @api private
	   */
	  uuid: {
	    v4: function uuidV4() {
	      return __webpack_require__(207).v4();
	    }
	  },

	  /**
	   * @api private
	   */
	  convertPayloadToString: function convertPayloadToString(resp) {
	    var req = resp.request;
	    var operation = req.operation;
	    var rules = req.service.api.operations[operation].output || {};
	    if (rules.payload && resp.data[rules.payload]) {
	      resp.data[rules.payload] = resp.data[rules.payload].toString();
	    }
	  },

	  /**
	   * @api private
	   */
	  defer: function defer(callback) {
	    if (typeof process === 'object' && typeof process.nextTick === 'function') {
	      process.nextTick(callback);
	    } else if (typeof setImmediate === 'function') {
	      setImmediate(callback);
	    } else {
	      setTimeout(callback, 0);
	    }
	  },

	  /**
	   * @api private
	   */
	  defaultProfile: 'default',

	  /**
	   * @api private
	   */
	  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

	  /**
	   * @api private
	   */
	  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

	  /**
	   * @api private
	   */
	  sharedConfigFileEnv: 'AWS_CONFIG_FILE',

	  /**
	   * @api private
	   */
	  imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
	};

	/**
	 * @api private
	 */
	module.exports = util;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * The main AWS namespace
	 */
	var AWS = { util: __webpack_require__(159) };

	/**
	 * @api private
	 * @!macro [new] nobrowser
	 *   @note This feature is not supported in the browser environment of the SDK.
	 */
	var _hidden = {}; _hidden.toString(); // hack to parse macro

	/**
	 * @api private
	 */
	module.exports = AWS;

	AWS.util.update(AWS, {

	  /**
	   * @constant
	   */
	  VERSION: '2.335.0',

	  /**
	   * @api private
	   */
	  Signers: {},

	  /**
	   * @api private
	   */
	  Protocol: {
	    Json: __webpack_require__(161),
	    Query: __webpack_require__(164),
	    Rest: __webpack_require__(168),
	    RestJson: __webpack_require__(169),
	    RestXml: __webpack_require__(170)
	  },

	  /**
	   * @api private
	   */
	  XML: {
	    Builder: __webpack_require__(171),
	    Parser: null // conditionally set based on environment
	  },

	  /**
	   * @api private
	   */
	  JSON: {
	    Builder: __webpack_require__(162),
	    Parser: __webpack_require__(163)
	  },

	  /**
	   * @api private
	   */
	  Model: {
	    Api: __webpack_require__(176),
	    Operation: __webpack_require__(177),
	    Shape: __webpack_require__(166),
	    Paginator: __webpack_require__(178),
	    ResourceWaiter: __webpack_require__(179)
	  },

	  /**
	   * @api private
	   */
	  apiLoader: __webpack_require__(180)
	});
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(185);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(191);
	__webpack_require__(194);
	__webpack_require__(195);
	__webpack_require__(196);
	__webpack_require__(204);

	/**
	 * @readonly
	 * @return [AWS.SequentialExecutor] a collection of global event listeners that
	 *   are attached to every sent request.
	 * @see AWS.Request AWS.Request for a list of events to listen for
	 * @example Logging the time taken to send a request
	 *   AWS.events.on('send', function startSend(resp) {
	 *     resp.startTime = new Date().getTime();
	 *   }).on('complete', function calculateTime(resp) {
	 *     var time = (new Date().getTime() - resp.startTime) / 1000;
	 *     console.log('Request took ' + time + ' seconds');
	 *   });
	 *
	 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
	 */
	AWS.events = new AWS.SequentialExecutor();


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);
	var JsonBuilder = __webpack_require__(162);
	var JsonParser = __webpack_require__(163);

	function buildRequest(req) {
	  var httpRequest = req.httpRequest;
	  var api = req.service.api;
	  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
	  var version = api.jsonVersion || '1.0';
	  var input = api.operations[req.operation].input;
	  var builder = new JsonBuilder();

	  if (version === 1) version = '1.0';
	  httpRequest.body = builder.build(req.params || {}, input);
	  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
	  httpRequest.headers['X-Amz-Target'] = target;
	}

	function extractError(resp) {
	  var error = {};
	  var httpResponse = resp.httpResponse;

	  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
	  if (typeof error.code === 'string') {
	    error.code = error.code.split(':')[0];
	  }

	  if (httpResponse.body.length > 0) {
	    try {
	      var e = JSON.parse(httpResponse.body.toString());
	      if (e.__type || e.code) {
	        error.code = (e.__type || e.code).split('#').pop();
	      }
	      if (error.code === 'RequestEntityTooLarge') {
	        error.message = 'Request body must be less than 1 MB';
	      } else {
	        error.message = (e.message || e.Message || null);
	      }
	    } catch (e) {
	      error.statusCode = httpResponse.statusCode;
	      error.message = httpResponse.statusMessage;
	    }
	  } else {
	    error.statusCode = httpResponse.statusCode;
	    error.message = httpResponse.statusCode.toString();
	  }

	  resp.error = util.error(new Error(), error);
	}

	function extractData(resp) {
	  var body = resp.httpResponse.body.toString() || '{}';
	  if (resp.request.service.config.convertResponseTypes === false) {
	    resp.data = JSON.parse(body);
	  } else {
	    var operation = resp.request.service.api.operations[resp.request.operation];
	    var shape = operation.output || {};
	    var parser = new JsonParser();
	    resp.data = parser.parse(body, shape);
	  }
	}

	/**
	 * @api private
	 */
	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);

	function JsonBuilder() { }

	JsonBuilder.prototype.build = function(value, shape) {
	  return JSON.stringify(translate(value, shape));
	};

	function translate(value, shape) {
	  if (!shape || value === undefined || value === null) return undefined;

	  switch (shape.type) {
	    case 'structure': return translateStructure(value, shape);
	    case 'map': return translateMap(value, shape);
	    case 'list': return translateList(value, shape);
	    default: return translateScalar(value, shape);
	  }
	}

	function translateStructure(structure, shape) {
	  var struct = {};
	  util.each(structure, function(name, value) {
	    var memberShape = shape.members[name];
	    if (memberShape) {
	      if (memberShape.location !== 'body') return;
	      var locationName = memberShape.isLocationName ? memberShape.name : name;
	      var result = translate(value, memberShape);
	      if (result !== undefined) struct[locationName] = result;
	    }
	  });
	  return struct;
	}

	function translateList(list, shape) {
	  var out = [];
	  util.arrayEach(list, function(value) {
	    var result = translate(value, shape.member);
	    if (result !== undefined) out.push(result);
	  });
	  return out;
	}

	function translateMap(map, shape) {
	  var out = {};
	  util.each(map, function(key, value) {
	    var result = translate(value, shape.value);
	    if (result !== undefined) out[key] = result;
	  });
	  return out;
	}

	function translateScalar(value, shape) {
	  return shape.toWireFormat(value);
	}

	/**
	 * @api private
	 */
	module.exports = JsonBuilder;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);

	function JsonParser() { }

	JsonParser.prototype.parse = function(value, shape) {
	  return translate(JSON.parse(value), shape);
	};

	function translate(value, shape) {
	  if (!shape || value === undefined) return undefined;

	  switch (shape.type) {
	    case 'structure': return translateStructure(value, shape);
	    case 'map': return translateMap(value, shape);
	    case 'list': return translateList(value, shape);
	    default: return translateScalar(value, shape);
	  }
	}

	function translateStructure(structure, shape) {
	  if (structure == null) return undefined;

	  var struct = {};
	  var shapeMembers = shape.members;
	  util.each(shapeMembers, function(name, memberShape) {
	    var locationName = memberShape.isLocationName ? memberShape.name : name;
	    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
	      var value = structure[locationName];
	      var result = translate(value, memberShape);
	      if (result !== undefined) struct[name] = result;
	    }
	  });
	  return struct;
	}

	function translateList(list, shape) {
	  if (list == null) return undefined;

	  var out = [];
	  util.arrayEach(list, function(value) {
	    var result = translate(value, shape.member);
	    if (result === undefined) out.push(null);
	    else out.push(result);
	  });
	  return out;
	}

	function translateMap(map, shape) {
	  if (map == null) return undefined;

	  var out = {};
	  util.each(map, function(key, value) {
	    var result = translate(value, shape.value);
	    if (result === undefined) out[key] = null;
	    else out[key] = result;
	  });
	  return out;
	}

	function translateScalar(value, shape) {
	  return shape.toType(value);
	}

	/**
	 * @api private
	 */
	module.exports = JsonParser;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var util = __webpack_require__(159);
	var QueryParamSerializer = __webpack_require__(165);
	var Shape = __webpack_require__(166);

	function buildRequest(req) {
	  var operation = req.service.api.operations[req.operation];
	  var httpRequest = req.httpRequest;
	  httpRequest.headers['Content-Type'] =
	    'application/x-www-form-urlencoded; charset=utf-8';
	  httpRequest.params = {
	    Version: req.service.api.apiVersion,
	    Action: operation.name
	  };

	  // convert the request parameters into a list of query params,
	  // e.g. Deeply.NestedParam.0.Name=value
	  var builder = new QueryParamSerializer();
	  builder.serialize(req.params, operation.input, function(name, value) {
	    httpRequest.params[name] = value;
	  });
	  httpRequest.body = util.queryParamsToString(httpRequest.params);
	}

	function extractError(resp) {
	  var data, body = resp.httpResponse.body.toString();
	  if (body.match('<UnknownOperationException')) {
	    data = {
	      Code: 'UnknownOperation',
	      Message: 'Unknown operation ' + resp.request.operation
	    };
	  } else {
	    try {
	      data = new AWS.XML.Parser().parse(body);
	    } catch (e) {
	      data = {
	        Code: resp.httpResponse.statusCode,
	        Message: resp.httpResponse.statusMessage
	      };
	    }
	  }

	  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
	  if (data.Errors) data = data.Errors;
	  if (data.Error) data = data.Error;
	  if (data.Code) {
	    resp.error = util.error(new Error(), {
	      code: data.Code,
	      message: data.Message
	    });
	  } else {
	    resp.error = util.error(new Error(), {
	      code: resp.httpResponse.statusCode,
	      message: null
	    });
	  }
	}

	function extractData(resp) {
	  var req = resp.request;
	  var operation = req.service.api.operations[req.operation];
	  var shape = operation.output || {};
	  var origRules = shape;

	  if (origRules.resultWrapper) {
	    var tmp = Shape.create({type: 'structure'});
	    tmp.members[origRules.resultWrapper] = shape;
	    tmp.memberNames = [origRules.resultWrapper];
	    util.property(shape, 'name', shape.resultWrapper);
	    shape = tmp;
	  }

	  var parser = new AWS.XML.Parser();

	  // TODO: Refactor XML Parser to parse RequestId from response.
	  if (shape && shape.members && !shape.members._XAMZRequestId) {
	    var requestIdShape = Shape.create(
	      { type: 'string' },
	      { api: { protocol: 'query' } },
	      'requestId'
	    );
	    shape.members._XAMZRequestId = requestIdShape;
	  }

	  var data = parser.parse(resp.httpResponse.body.toString(), shape);
	  resp.requestId = data._XAMZRequestId || data.requestId;

	  if (data._XAMZRequestId) delete data._XAMZRequestId;

	  if (origRules.resultWrapper) {
	    if (data[origRules.resultWrapper]) {
	      util.update(data, data[origRules.resultWrapper]);
	      delete data[origRules.resultWrapper];
	    }
	  }

	  resp.data = data;
	}

	/**
	 * @api private
	 */
	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);

	function QueryParamSerializer() {
	}

	QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
	  serializeStructure('', params, shape, fn);
	};

	function ucfirst(shape) {
	  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
	    return shape.name;
	  } else {
	    return shape.name[0].toUpperCase() + shape.name.substr(1);
	  }
	}

	function serializeStructure(prefix, struct, rules, fn) {
	  util.each(rules.members, function(name, member) {
	    var value = struct[name];
	    if (value === null || value === undefined) return;

	    var memberName = ucfirst(member);
	    memberName = prefix ? prefix + '.' + memberName : memberName;
	    serializeMember(memberName, value, member, fn);
	  });
	}

	function serializeMap(name, map, rules, fn) {
	  var i = 1;
	  util.each(map, function (key, value) {
	    var prefix = rules.flattened ? '.' : '.entry.';
	    var position = prefix + (i++) + '.';
	    var keyName = position + (rules.key.name || 'key');
	    var valueName = position + (rules.value.name || 'value');
	    serializeMember(name + keyName, key, rules.key, fn);
	    serializeMember(name + valueName, value, rules.value, fn);
	  });
	}

	function serializeList(name, list, rules, fn) {
	  var memberRules = rules.member || {};

	  if (list.length === 0) {
	    fn.call(this, name, null);
	    return;
	  }

	  util.arrayEach(list, function (v, n) {
	    var suffix = '.' + (n + 1);
	    if (rules.api.protocol === 'ec2') {
	      // Do nothing for EC2
	      suffix = suffix + ''; // make linter happy
	    } else if (rules.flattened) {
	      if (memberRules.name) {
	        var parts = name.split('.');
	        parts.pop();
	        parts.push(ucfirst(memberRules));
	        name = parts.join('.');
	      }
	    } else {
	      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
	    }
	    serializeMember(name + suffix, v, memberRules, fn);
	  });
	}

	function serializeMember(name, value, rules, fn) {
	  if (value === null || value === undefined) return;
	  if (rules.type === 'structure') {
	    serializeStructure(name, value, rules, fn);
	  } else if (rules.type === 'list') {
	    serializeList(name, value, rules, fn);
	  } else if (rules.type === 'map') {
	    serializeMap(name, value, rules, fn);
	  } else {
	    fn(name, rules.toWireFormat(value).toString());
	  }
	}

	/**
	 * @api private
	 */
	module.exports = QueryParamSerializer;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	var Collection = __webpack_require__(167);

	var util = __webpack_require__(159);

	function property(obj, name, value) {
	  if (value !== null && value !== undefined) {
	    util.property.apply(this, arguments);
	  }
	}

	function memoizedProperty(obj, name) {
	  if (!obj.constructor.prototype[name]) {
	    util.memoizedProperty.apply(this, arguments);
	  }
	}

	function Shape(shape, options, memberName) {
	  options = options || {};

	  property(this, 'shape', shape.shape);
	  property(this, 'api', options.api, false);
	  property(this, 'type', shape.type);
	  property(this, 'enum', shape.enum);
	  property(this, 'min', shape.min);
	  property(this, 'max', shape.max);
	  property(this, 'pattern', shape.pattern);
	  property(this, 'location', shape.location || this.location || 'body');
	  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
	    shape.locationName || memberName);
	  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
	  property(this, 'isComposite', shape.isComposite || false);
	  property(this, 'isShape', true, false);
	  property(this, 'isQueryName', Boolean(shape.queryName), false);
	  property(this, 'isLocationName', Boolean(shape.locationName), false);
	  property(this, 'isIdempotent', shape.idempotencyToken === true);
	  property(this, 'isJsonValue', shape.jsonvalue === true);
	  property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
	  property(this, 'isEventStream', Boolean(shape.eventstream), false);
	  property(this, 'isEvent', Boolean(shape.event), false);
	  property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
	  property(this, 'isEventHeader', Boolean(shape.eventheader), false);
	  property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);

	  if (options.documentation) {
	    property(this, 'documentation', shape.documentation);
	    property(this, 'documentationUrl', shape.documentationUrl);
	  }

	  if (shape.xmlAttribute) {
	    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
	  }

	  // type conversion and parsing
	  property(this, 'defaultValue', null);
	  this.toWireFormat = function(value) {
	    if (value === null || value === undefined) return '';
	    return value;
	  };
	  this.toType = function(value) { return value; };
	}

	/**
	 * @api private
	 */
	Shape.normalizedTypes = {
	  character: 'string',
	  double: 'float',
	  long: 'integer',
	  short: 'integer',
	  biginteger: 'integer',
	  bigdecimal: 'float',
	  blob: 'binary'
	};

	/**
	 * @api private
	 */
	Shape.types = {
	  'structure': StructureShape,
	  'list': ListShape,
	  'map': MapShape,
	  'boolean': BooleanShape,
	  'timestamp': TimestampShape,
	  'float': FloatShape,
	  'integer': IntegerShape,
	  'string': StringShape,
	  'base64': Base64Shape,
	  'binary': BinaryShape
	};

	Shape.resolve = function resolve(shape, options) {
	  if (shape.shape) {
	    var refShape = options.api.shapes[shape.shape];
	    if (!refShape) {
	      throw new Error('Cannot find shape reference: ' + shape.shape);
	    }

	    return refShape;
	  } else {
	    return null;
	  }
	};

	Shape.create = function create(shape, options, memberName) {
	  if (shape.isShape) return shape;

	  var refShape = Shape.resolve(shape, options);
	  if (refShape) {
	    var filteredKeys = Object.keys(shape);
	    if (!options.documentation) {
	      filteredKeys = filteredKeys.filter(function(name) {
	        return !name.match(/documentation/);
	      });
	    }

	    // create an inline shape with extra members
	    var InlineShape = function() {
	      refShape.constructor.call(this, shape, options, memberName);
	    };
	    InlineShape.prototype = refShape;
	    return new InlineShape();
	  } else {
	    // set type if not set
	    if (!shape.type) {
	      if (shape.members) shape.type = 'structure';
	      else if (shape.member) shape.type = 'list';
	      else if (shape.key) shape.type = 'map';
	      else shape.type = 'string';
	    }

	    // normalize types
	    var origType = shape.type;
	    if (Shape.normalizedTypes[shape.type]) {
	      shape.type = Shape.normalizedTypes[shape.type];
	    }

	    if (Shape.types[shape.type]) {
	      return new Shape.types[shape.type](shape, options, memberName);
	    } else {
	      throw new Error('Unrecognized shape type: ' + origType);
	    }
	  }
	};

	function CompositeShape(shape) {
	  Shape.apply(this, arguments);
	  property(this, 'isComposite', true);

	  if (shape.flattened) {
	    property(this, 'flattened', shape.flattened || false);
	  }
	}

	function StructureShape(shape, options) {
	  var self = this;
	  var requiredMap = null, firstInit = !this.isShape;

	  CompositeShape.apply(this, arguments);

	  if (firstInit) {
	    property(this, 'defaultValue', function() { return {}; });
	    property(this, 'members', {});
	    property(this, 'memberNames', []);
	    property(this, 'required', []);
	    property(this, 'isRequired', function() { return false; });
	  }

	  if (shape.members) {
	    property(this, 'members', new Collection(shape.members, options, function(name, member) {
	      return Shape.create(member, options, name);
	    }));
	    memoizedProperty(this, 'memberNames', function() {
	      return shape.xmlOrder || Object.keys(shape.members);
	    });

	    if (shape.event) {
	      memoizedProperty(this, 'eventPayloadMemberName', function() {
	        var members = self.members;
	        var memberNames = self.memberNames;
	        // iterate over members to find ones that are event payloads
	        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
	          if (members[memberNames[i]].isEventPayload) {
	            return memberNames[i];
	          }
	        }
	      });

	      memoizedProperty(this, 'eventHeaderMemberNames', function() {
	        var members = self.members;
	        var memberNames = self.memberNames;
	        var eventHeaderMemberNames = [];
	        // iterate over members to find ones that are event headers
	        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
	          if (members[memberNames[i]].isEventHeader) {
	            eventHeaderMemberNames.push(memberNames[i]);
	          }
	        }
	        return eventHeaderMemberNames;
	      });
	    }
	  }

	  if (shape.required) {
	    property(this, 'required', shape.required);
	    property(this, 'isRequired', function(name) {
	      if (!requiredMap) {
	        requiredMap = {};
	        for (var i = 0; i < shape.required.length; i++) {
	          requiredMap[shape.required[i]] = true;
	        }
	      }

	      return requiredMap[name];
	    }, false, true);
	  }

	  property(this, 'resultWrapper', shape.resultWrapper || null);

	  if (shape.payload) {
	    property(this, 'payload', shape.payload);
	  }

	  if (typeof shape.xmlNamespace === 'string') {
	    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
	  } else if (typeof shape.xmlNamespace === 'object') {
	    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
	    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
	  }
	}

	function ListShape(shape, options) {
	  var self = this, firstInit = !this.isShape;
	  CompositeShape.apply(this, arguments);

	  if (firstInit) {
	    property(this, 'defaultValue', function() { return []; });
	  }

	  if (shape.member) {
	    memoizedProperty(this, 'member', function() {
	      return Shape.create(shape.member, options);
	    });
	  }

	  if (this.flattened) {
	    var oldName = this.name;
	    memoizedProperty(this, 'name', function() {
	      return self.member.name || oldName;
	    });
	  }
	}

	function MapShape(shape, options) {
	  var firstInit = !this.isShape;
	  CompositeShape.apply(this, arguments);

	  if (firstInit) {
	    property(this, 'defaultValue', function() { return {}; });
	    property(this, 'key', Shape.create({type: 'string'}, options));
	    property(this, 'value', Shape.create({type: 'string'}, options));
	  }

	  if (shape.key) {
	    memoizedProperty(this, 'key', function() {
	      return Shape.create(shape.key, options);
	    });
	  }
	  if (shape.value) {
	    memoizedProperty(this, 'value', function() {
	      return Shape.create(shape.value, options);
	    });
	  }
	}

	function TimestampShape(shape) {
	  var self = this;
	  Shape.apply(this, arguments);

	  if (shape.timestampFormat) {
	    property(this, 'timestampFormat', shape.timestampFormat);
	  } else if (self.isTimestampFormatSet && this.timestampFormat) {
	    property(this, 'timestampFormat', this.timestampFormat);
	  } else if (this.location === 'header') {
	    property(this, 'timestampFormat', 'rfc822');
	  } else if (this.location === 'querystring') {
	    property(this, 'timestampFormat', 'iso8601');
	  } else if (this.api) {
	    switch (this.api.protocol) {
	      case 'json':
	      case 'rest-json':
	        property(this, 'timestampFormat', 'unixTimestamp');
	        break;
	      case 'rest-xml':
	      case 'query':
	      case 'ec2':
	        property(this, 'timestampFormat', 'iso8601');
	        break;
	    }
	  }

	  this.toType = function(value) {
	    if (value === null || value === undefined) return null;
	    if (typeof value.toUTCString === 'function') return value;
	    return typeof value === 'string' || typeof value === 'number' ?
	           util.date.parseTimestamp(value) : null;
	  };

	  this.toWireFormat = function(value) {
	    return util.date.format(value, self.timestampFormat);
	  };
	}

	function StringShape() {
	  Shape.apply(this, arguments);

	  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
	  this.toType = function(value) {
	    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
	      value || '' : value;
	    if (this.isJsonValue) {
	      return JSON.parse(value);
	    }

	    return value && typeof value.toString === 'function' ?
	      value.toString() : value;
	  };

	  this.toWireFormat = function(value) {
	    return this.isJsonValue ? JSON.stringify(value) : value;
	  };
	}

	function FloatShape() {
	  Shape.apply(this, arguments);

	  this.toType = function(value) {
	    if (value === null || value === undefined) return null;
	    return parseFloat(value);
	  };
	  this.toWireFormat = this.toType;
	}

	function IntegerShape() {
	  Shape.apply(this, arguments);

	  this.toType = function(value) {
	    if (value === null || value === undefined) return null;
	    return parseInt(value, 10);
	  };
	  this.toWireFormat = this.toType;
	}

	function BinaryShape() {
	  Shape.apply(this, arguments);
	  this.toType = util.base64.decode;
	  this.toWireFormat = util.base64.encode;
	}

	function Base64Shape() {
	  BinaryShape.apply(this, arguments);
	}

	function BooleanShape() {
	  Shape.apply(this, arguments);

	  this.toType = function(value) {
	    if (typeof value === 'boolean') return value;
	    if (value === null || value === undefined) return null;
	    return value === 'true';
	  };
	}

	/**
	 * @api private
	 */
	Shape.shapes = {
	  StructureShape: StructureShape,
	  ListShape: ListShape,
	  MapShape: MapShape,
	  StringShape: StringShape,
	  BooleanShape: BooleanShape,
	  Base64Shape: Base64Shape
	};

	/**
	 * @api private
	 */
	module.exports = Shape;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	var memoizedProperty = __webpack_require__(159).memoizedProperty;

	function memoize(name, value, fn, nameTr) {
	  memoizedProperty(this, nameTr(name), function() {
	    return fn(name, value);
	  });
	}

	function Collection(iterable, options, fn, nameTr) {
	  nameTr = nameTr || String;
	  var self = this;

	  for (var id in iterable) {
	    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
	      memoize.call(self, id, iterable[id], fn, nameTr);
	    }
	  }
	}

	/**
	 * @api private
	 */
	module.exports = Collection;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);

	function populateMethod(req) {
	  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
	}

	function generateURI(endpointPath, operationPath, input, params) {
	  var uri = [endpointPath, operationPath].join('/');
	  uri = uri.replace(/\/+/g, '/');

	  var queryString = {}, queryStringSet = false;
	  util.each(input.members, function (name, member) {
	    var paramValue = params[name];
	    if (paramValue === null || paramValue === undefined) return;
	    if (member.location === 'uri') {
	      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
	      uri = uri.replace(regex, function(_, plus) {
	        var fn = plus ? util.uriEscapePath : util.uriEscape;
	        return fn(String(paramValue));
	      });
	    } else if (member.location === 'querystring') {
	      queryStringSet = true;

	      if (member.type === 'list') {
	        queryString[member.name] = paramValue.map(function(val) {
	          return util.uriEscape(member.member.toWireFormat(val).toString());
	        });
	      } else if (member.type === 'map') {
	        util.each(paramValue, function(key, value) {
	          if (Array.isArray(value)) {
	            queryString[key] = value.map(function(val) {
	              return util.uriEscape(String(val));
	            });
	          } else {
	            queryString[key] = util.uriEscape(String(value));
	          }
	        });
	      } else {
	        queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
	      }
	    }
	  });

	  if (queryStringSet) {
	    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
	    var parts = [];
	    util.arrayEach(Object.keys(queryString).sort(), function(key) {
	      if (!Array.isArray(queryString[key])) {
	        queryString[key] = [queryString[key]];
	      }
	      for (var i = 0; i < queryString[key].length; i++) {
	        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
	      }
	    });
	    uri += parts.join('&');
	  }

	  return uri;
	}

	function populateURI(req) {
	  var operation = req.service.api.operations[req.operation];
	  var input = operation.input;

	  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
	  req.httpRequest.path = uri;
	}

	function populateHeaders(req) {
	  var operation = req.service.api.operations[req.operation];
	  util.each(operation.input.members, function (name, member) {
	    var value = req.params[name];
	    if (value === null || value === undefined) return;

	    if (member.location === 'headers' && member.type === 'map') {
	      util.each(value, function(key, memberValue) {
	        req.httpRequest.headers[member.name + key] = memberValue;
	      });
	    } else if (member.location === 'header') {
	      value = member.toWireFormat(value).toString();
	      if (member.isJsonValue) {
	        value = util.base64.encode(value);
	      }
	      req.httpRequest.headers[member.name] = value;
	    }
	  });
	}

	function buildRequest(req) {
	  populateMethod(req);
	  populateURI(req);
	  populateHeaders(req);
	}

	function extractError() {
	}

	function extractData(resp) {
	  var req = resp.request;
	  var data = {};
	  var r = resp.httpResponse;
	  var operation = req.service.api.operations[req.operation];
	  var output = operation.output;

	  // normalize headers names to lower-cased keys for matching
	  var headers = {};
	  util.each(r.headers, function (k, v) {
	    headers[k.toLowerCase()] = v;
	  });

	  util.each(output.members, function(name, member) {
	    var header = (member.name || name).toLowerCase();
	    if (member.location === 'headers' && member.type === 'map') {
	      data[name] = {};
	      var location = member.isLocationName ? member.name : '';
	      var pattern = new RegExp('^' + location + '(.+)', 'i');
	      util.each(r.headers, function (k, v) {
	        var result = k.match(pattern);
	        if (result !== null) {
	          data[name][result[1]] = v;
	        }
	      });
	    } else if (member.location === 'header') {
	      if (headers[header] !== undefined) {
	        var value = member.isJsonValue ?
	          util.base64.decode(headers[header]) :
	          headers[header];
	        data[name] = member.toType(value);
	      }
	    } else if (member.location === 'statusCode') {
	      data[name] = parseInt(r.statusCode, 10);
	    }
	  });

	  resp.data = data;
	}

	/**
	 * @api private
	 */
	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData,
	  generateURI: generateURI
	};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);
	var Rest = __webpack_require__(168);
	var Json = __webpack_require__(161);
	var JsonBuilder = __webpack_require__(162);
	var JsonParser = __webpack_require__(163);

	function populateBody(req) {
	  var builder = new JsonBuilder();
	  var input = req.service.api.operations[req.operation].input;

	  if (input.payload) {
	    var params = {};
	    var payloadShape = input.members[input.payload];
	    params = req.params[input.payload];
	    if (params === undefined) return;

	    if (payloadShape.type === 'structure') {
	      req.httpRequest.body = builder.build(params, payloadShape);
	      applyContentTypeHeader(req);
	    } else { // non-JSON payload
	      req.httpRequest.body = params;
	      if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
	        applyContentTypeHeader(req, true);
	      }
	    }
	  } else {
	    req.httpRequest.body = builder.build(req.params, input);
	    applyContentTypeHeader(req);
	  }
	}

	function applyContentTypeHeader(req, isBinary) {
	  var operation = req.service.api.operations[req.operation];
	  var input = operation.input;

	  if (!req.httpRequest.headers['Content-Type']) {
	    var type = isBinary ? 'binary/octet-stream' : 'application/json';
	    req.httpRequest.headers['Content-Type'] = type;
	  }
	}

	function buildRequest(req) {
	  Rest.buildRequest(req);

	  // never send body payload on GET/HEAD/DELETE
	  if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
	    populateBody(req);
	  }
	}

	function extractError(resp) {
	  Json.extractError(resp);
	}

	function extractData(resp) {
	  Rest.extractData(resp);

	  var req = resp.request;
	  var operation = req.service.api.operations[req.operation];
	  var rules = req.service.api.operations[req.operation].output || {};
	  var parser;
	  var hasEventOutput = operation.hasEventOutput;

	  if (rules.payload) {
	    var payloadMember = rules.members[rules.payload];
	    var body = resp.httpResponse.body;
	    if (payloadMember.isEventStream) {
	      parser = new JsonParser();
	      resp.data[payload] = util.createEventStream(
	        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
	        parser,
	        payloadMember
	      );
	    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
	      var parser = new JsonParser();
	      resp.data[rules.payload] = parser.parse(body, payloadMember);
	    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
	      resp.data[rules.payload] = body;
	    } else {
	      resp.data[rules.payload] = payloadMember.toType(body);
	    }
	  } else {
	    var data = resp.data;
	    Json.extractData(resp);
	    resp.data = util.merge(data, resp.data);
	  }
	}

	/**
	 * @api private
	 */
	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var util = __webpack_require__(159);
	var Rest = __webpack_require__(168);

	function populateBody(req) {
	  var input = req.service.api.operations[req.operation].input;
	  var builder = new AWS.XML.Builder();
	  var params = req.params;

	  var payload = input.payload;
	  if (payload) {
	    var payloadMember = input.members[payload];
	    params = params[payload];
	    if (params === undefined) return;

	    if (payloadMember.type === 'structure') {
	      var rootElement = payloadMember.name;
	      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
	    } else { // non-xml payload
	      req.httpRequest.body = params;
	    }
	  } else {
	    req.httpRequest.body = builder.toXML(params, input, input.name ||
	      input.shape || util.string.upperFirst(req.operation) + 'Request');
	  }
	}

	function buildRequest(req) {
	  Rest.buildRequest(req);

	  // never send body payload on GET/HEAD
	  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
	    populateBody(req);
	  }
	}

	function extractError(resp) {
	  Rest.extractError(resp);

	  var data;
	  try {
	    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
	  } catch (e) {
	    data = {
	      Code: resp.httpResponse.statusCode,
	      Message: resp.httpResponse.statusMessage
	    };
	  }

	  if (data.Errors) data = data.Errors;
	  if (data.Error) data = data.Error;
	  if (data.Code) {
	    resp.error = util.error(new Error(), {
	      code: data.Code,
	      message: data.Message
	    });
	  } else {
	    resp.error = util.error(new Error(), {
	      code: resp.httpResponse.statusCode,
	      message: null
	    });
	  }
	}

	function extractData(resp) {
	  Rest.extractData(resp);

	  var parser;
	  var req = resp.request;
	  var body = resp.httpResponse.body;
	  var operation = req.service.api.operations[req.operation];
	  var output = operation.output;

	  var hasEventOutput = operation.hasEventOutput;

	  var payload = output.payload;
	  if (payload) {
	    var payloadMember = output.members[payload];
	    if (payloadMember.isEventStream) {
	      parser = new AWS.XML.Parser();
	      resp.data[payload] = util.createEventStream(
	        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
	        parser,
	        payloadMember
	      );
	    } else if (payloadMember.type === 'structure') {
	      parser = new AWS.XML.Parser();
	      resp.data[payload] = parser.parse(body.toString(), payloadMember);
	    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
	      resp.data[payload] = body;
	    } else {
	      resp.data[payload] = payloadMember.toType(body);
	    }
	  } else if (body.length > 0) {
	    parser = new AWS.XML.Parser();
	    var data = parser.parse(body.toString(), output);
	    util.update(resp.data, data);
	  }
	}

	/**
	 * @api private
	 */
	module.exports = {
	  buildRequest: buildRequest,
	  extractError: extractError,
	  extractData: extractData
	};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);
	var XmlNode = __webpack_require__(172).XmlNode;
	var XmlText = __webpack_require__(174).XmlText;

	function XmlBuilder() { }

	XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
	  var xml = new XmlNode(rootElement);
	  applyNamespaces(xml, shape, true);
	  serialize(xml, params, shape);
	  return xml.children.length > 0 || noEmpty ? xml.toString() : '';
	};

	function serialize(xml, value, shape) {
	  switch (shape.type) {
	    case 'structure': return serializeStructure(xml, value, shape);
	    case 'map': return serializeMap(xml, value, shape);
	    case 'list': return serializeList(xml, value, shape);
	    default: return serializeScalar(xml, value, shape);
	  }
	}

	function serializeStructure(xml, params, shape) {
	  util.arrayEach(shape.memberNames, function(memberName) {
	    var memberShape = shape.members[memberName];
	    if (memberShape.location !== 'body') return;

	    var value = params[memberName];
	    var name = memberShape.name;
	    if (value !== undefined && value !== null) {
	      if (memberShape.isXmlAttribute) {
	        xml.addAttribute(name, value);
	      } else if (memberShape.flattened) {
	        serialize(xml, value, memberShape);
	      } else {
	        var element = new XmlNode(name);
	        xml.addChildNode(element);
	        applyNamespaces(element, memberShape);
	        serialize(element, value, memberShape);
	      }
	    }
	  });
	}

	function serializeMap(xml, map, shape) {
	  var xmlKey = shape.key.name || 'key';
	  var xmlValue = shape.value.name || 'value';

	  util.each(map, function(key, value) {
	    var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
	    xml.addChildNode(entry);

	    var entryKey = new XmlNode(xmlKey);
	    var entryValue = new XmlNode(xmlValue);
	    entry.addChildNode(entryKey)
	    entry.addChildNode(entryValue)

	    serialize(entryKey, key, shape.key);
	    serialize(entryValue, value, shape.value);
	  });
	}

	function serializeList(xml, list, shape) {
	  if (shape.flattened) {
	    util.arrayEach(list, function(value) {
	      var name = shape.member.name || shape.name;
	      var element = new XmlNode(name);
	      xml.addChildNode(element);
	      serialize(element, value, shape.member);
	    });
	  } else {
	    util.arrayEach(list, function(value) {
	      var name = shape.member.name || 'member';
	      var element = new XmlNode(name);
	      xml.addChildNode(element);
	      serialize(element, value, shape.member);
	    });
	  }
	}

	function serializeScalar(xml, value, shape) {
	  xml.addChildNode(
	    new XmlText(shape.toWireFormat(value))
	  );
	}

	function applyNamespaces(xml, shape, isRoot) {
	  var uri, prefix = 'xmlns';
	  if (shape.xmlNamespaceUri) {
	    uri = shape.xmlNamespaceUri;
	    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
	  } else if (isRoot && shape.api.xmlNamespaceUri) {
	    uri = shape.api.xmlNamespaceUri;
	  }

	  if (uri) xml.addAttribute(prefix, uri);
	}

	/**
	 * @api private
	 */
	module.exports = XmlBuilder;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	var escapeAttribute = __webpack_require__(173).escapeAttribute;

	/**
	 * Represents an XML node.
	 * @api private
	 */
	function XmlNode(name, children) {
	    if (children === void 0) { children = []; }
	    this.name = name;
	    this.children = children;
	    this.attributes = {};
	}
	XmlNode.prototype.addAttribute = function (name, value) {
	    this.attributes[name] = value;
	    return this;
	};
	XmlNode.prototype.addChildNode = function (child) {
	    this.children.push(child);
	    return this;
	};
	XmlNode.prototype.removeAttribute = function (name) {
	    delete this.attributes[name];
	    return this;
	};
	XmlNode.prototype.toString = function () {
	    var hasChildren = Boolean(this.children.length);
	    var xmlText = '<' + this.name;
	    // add attributes
	    var attributes = this.attributes;
	    for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
	        var attributeName = attributeNames[i];
	        var attribute = attributes[attributeName];
	        if (typeof attribute !== 'undefined' && attribute !== null) {
	            xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
	        }
	    }
	    return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) { return c.toString(); }).join('') + '</' + this.name + '>';
	};

	/**
	 * @api private
	 */
	module.exports = {
	    XmlNode: XmlNode
	};

/***/ }),
/* 173 */
/***/ (function(module, exports) {

	/**
	 * Escapes characters that can not be in an XML attribute.
	 */
	function escapeAttribute(value) {
	    return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
	}

	/**
	 * @api private
	 */
	module.exports = {
	    escapeAttribute: escapeAttribute
	};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	var escapeElement = __webpack_require__(175).escapeElement;

	/**
	 * Represents an XML text value.
	 * @api private
	 */
	function XmlText(value) {
	    this.value = value;
	}

	XmlText.prototype.toString = function () {
	    return escapeElement('' + this.value);
	};

	/**
	 * @api private
	 */
	module.exports = {
	    XmlText: XmlText
	};

/***/ }),
/* 175 */
/***/ (function(module, exports) {

	/**
	 * Escapes characters that can not be in an XML element.
	 */
	function escapeElement(value) {
	    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}

	/**
	 * @api private
	 */
	module.exports = {
	    escapeElement: escapeElement
	};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	var Collection = __webpack_require__(167);
	var Operation = __webpack_require__(177);
	var Shape = __webpack_require__(166);
	var Paginator = __webpack_require__(178);
	var ResourceWaiter = __webpack_require__(179);

	var util = __webpack_require__(159);
	var property = util.property;
	var memoizedProperty = util.memoizedProperty;

	function Api(api, options) {
	  api = api || {};
	  options = options || {};
	  options.api = this;

	  api.metadata = api.metadata || {};

	  property(this, 'isApi', true, false);
	  property(this, 'apiVersion', api.metadata.apiVersion);
	  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
	  property(this, 'signingName', api.metadata.signingName);
	  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
	  property(this, 'signatureVersion', api.metadata.signatureVersion);
	  property(this, 'jsonVersion', api.metadata.jsonVersion);
	  property(this, 'targetPrefix', api.metadata.targetPrefix);
	  property(this, 'protocol', api.metadata.protocol);
	  property(this, 'timestampFormat', api.metadata.timestampFormat);
	  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
	  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
	  property(this, 'fullName', api.metadata.serviceFullName);
	  property(this, 'serviceId', api.metadata.serviceId);

	  memoizedProperty(this, 'className', function() {
	    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
	    if (!name) return null;

	    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
	    if (name === 'ElasticLoadBalancing') name = 'ELB';
	    return name;
	  });

	  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
	    return new Operation(name, operation, options);
	  }, util.string.lowerFirst));

	  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
	    return Shape.create(shape, options);
	  }));

	  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
	    return new Paginator(name, paginator, options);
	  }));

	  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
	    return new ResourceWaiter(name, waiter, options);
	  }, util.string.lowerFirst));

	  if (options.documentation) {
	    property(this, 'documentation', api.documentation);
	    property(this, 'documentationUrl', api.documentationUrl);
	  }
	}

	/**
	 * @api private
	 */
	module.exports = Api;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(166);

	var util = __webpack_require__(159);
	var property = util.property;
	var memoizedProperty = util.memoizedProperty;

	function Operation(name, operation, options) {
	  var self = this;
	  options = options || {};

	  property(this, 'name', operation.name || name);
	  property(this, 'api', options.api, false);

	  operation.http = operation.http || {};
	  property(this, 'httpMethod', operation.http.method || 'POST');
	  property(this, 'httpPath', operation.http.requestUri || '/');
	  property(this, 'authtype', operation.authtype || '');

	  memoizedProperty(this, 'input', function() {
	    if (!operation.input) {
	      return new Shape.create({type: 'structure'}, options);
	    }
	    return Shape.create(operation.input, options);
	  });

	  memoizedProperty(this, 'output', function() {
	    if (!operation.output) {
	      return new Shape.create({type: 'structure'}, options);
	    }
	    return Shape.create(operation.output, options);
	  });

	  memoizedProperty(this, 'errors', function() {
	    var list = [];
	    if (!operation.errors) return null;

	    for (var i = 0; i < operation.errors.length; i++) {
	      list.push(Shape.create(operation.errors[i], options));
	    }

	    return list;
	  });

	  memoizedProperty(this, 'paginator', function() {
	    return options.api.paginators[name];
	  });

	  if (options.documentation) {
	    property(this, 'documentation', operation.documentation);
	    property(this, 'documentationUrl', operation.documentationUrl);
	  }

	  // idempotentMembers only tracks top-level input shapes
	  memoizedProperty(this, 'idempotentMembers', function() {
	    var idempotentMembers = [];
	    var input = self.input;
	    var members = input.members;
	    if (!input.members) {
	      return idempotentMembers;
	    }
	    for (var name in members) {
	      if (!members.hasOwnProperty(name)) {
	        continue;
	      }
	      if (members[name].isIdempotent === true) {
	        idempotentMembers.push(name);
	      }
	    }
	    return idempotentMembers;
	  });

	  memoizedProperty(this, 'hasEventOutput', function() {
	    var output = self.output;
	    return hasEventStream(output);
	  });
	}

	function hasEventStream(topLevelShape) {
	  var members = topLevelShape.members;
	  var payload = topLevelShape.payload;

	  if (!topLevelShape.members) {
	    return false;
	  }

	  if (payload) {
	    var payloadMember = members[payload];
	    return payloadMember.isEventStream;
	  }

	  // check if any member is an event stream
	  for (var name in members) {
	    if (!members.hasOwnProperty(name)) {
	      if (members[name].isEventStream === true) {
	        return true;
	      }
	    }
	  }
	  return false;
	}

	/**
	 * @api private
	 */
	module.exports = Operation;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	var property = __webpack_require__(159).property;

	function Paginator(name, paginator) {
	  property(this, 'inputToken', paginator.input_token);
	  property(this, 'limitKey', paginator.limit_key);
	  property(this, 'moreResults', paginator.more_results);
	  property(this, 'outputToken', paginator.output_token);
	  property(this, 'resultKey', paginator.result_key);
	}

	/**
	 * @api private
	 */
	module.exports = Paginator;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);
	var property = util.property;

	function ResourceWaiter(name, waiter, options) {
	  options = options || {};
	  property(this, 'name', name);
	  property(this, 'api', options.api, false);

	  if (waiter.operation) {
	    property(this, 'operation', util.string.lowerFirst(waiter.operation));
	  }

	  var self = this;
	  var keys = [
	    'type',
	    'description',
	    'delay',
	    'maxAttempts',
	    'acceptors'
	  ];

	  keys.forEach(function(key) {
	    var value = waiter[key];
	    if (value) {
	      property(self, key, value);
	    }
	  });
	}

	/**
	 * @api private
	 */
	module.exports = ResourceWaiter;


/***/ }),
/* 180 */
/***/ (function(module, exports) {

	function apiLoader(svc, version) {
	  if (!apiLoader.services.hasOwnProperty(svc)) {
	    throw new Error('InvalidService: Failed to load api for ' + svc);
	  }
	  return apiLoader.services[svc][version];
	}

	/**
	 * @api private
	 *
	 * This member of AWS.apiLoader is private, but changing it will necessitate a
	 * change to ../scripts/services-table-generator.ts
	 */
	apiLoader.services = {};

	/**
	 * @api private
	 */
	module.exports = apiLoader;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * @api private
	 * @!method on(eventName, callback)
	 *   Registers an event listener callback for the event given by `eventName`.
	 *   Parameters passed to the callback function depend on the individual event
	 *   being triggered. See the event documentation for those parameters.
	 *
	 *   @param eventName [String] the event name to register the listener for
	 *   @param callback [Function] the listener callback function
	 *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
	 *     Default to be false.
	 *   @return [AWS.SequentialExecutor] the same object for chaining
	 */
	AWS.SequentialExecutor = AWS.util.inherit({

	  constructor: function SequentialExecutor() {
	    this._events = {};
	  },

	  /**
	   * @api private
	   */
	  listeners: function listeners(eventName) {
	    return this._events[eventName] ? this._events[eventName].slice(0) : [];
	  },

	  on: function on(eventName, listener, toHead) {
	    if (this._events[eventName]) {
	      toHead ?
	        this._events[eventName].unshift(listener) :
	        this._events[eventName].push(listener);
	    } else {
	      this._events[eventName] = [listener];
	    }
	    return this;
	  },

	  /**
	   * @api private
	   */
	  onAsync: function onAsync(eventName, listener, toHead) {
	    listener._isAsync = true;
	    return this.on(eventName, listener, toHead);
	  },

	  removeListener: function removeListener(eventName, listener) {
	    var listeners = this._events[eventName];
	    if (listeners) {
	      var length = listeners.length;
	      var position = -1;
	      for (var i = 0; i < length; ++i) {
	        if (listeners[i] === listener) {
	          position = i;
	        }
	      }
	      if (position > -1) {
	        listeners.splice(position, 1);
	      }
	    }
	    return this;
	  },

	  removeAllListeners: function removeAllListeners(eventName) {
	    if (eventName) {
	      delete this._events[eventName];
	    } else {
	      this._events = {};
	    }
	    return this;
	  },

	  /**
	   * @api private
	   */
	  emit: function emit(eventName, eventArgs, doneCallback) {
	    if (!doneCallback) doneCallback = function() { };
	    var listeners = this.listeners(eventName);
	    var count = listeners.length;
	    this.callListeners(listeners, eventArgs, doneCallback);
	    return count > 0;
	  },

	  /**
	   * @api private
	   */
	  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
	    var self = this;
	    var error = prevError || null;

	    function callNextListener(err) {
	      if (err) {
	        error = AWS.util.error(error || new Error(), err);
	        if (self._haltHandlersOnError) {
	          return doneCallback.call(self, error);
	        }
	      }
	      self.callListeners(listeners, args, doneCallback, error);
	    }

	    while (listeners.length > 0) {
	      var listener = listeners.shift();
	      if (listener._isAsync) { // asynchronous listener
	        listener.apply(self, args.concat([callNextListener]));
	        return; // stop here, callNextListener will continue
	      } else { // synchronous listener
	        try {
	          listener.apply(self, args);
	        } catch (err) {
	          error = AWS.util.error(error || new Error(), err);
	        }
	        if (error && self._haltHandlersOnError) {
	          doneCallback.call(self, error);
	          return;
	        }
	      }
	    }
	    doneCallback.call(self, error);
	  },

	  /**
	   * Adds or copies a set of listeners from another list of
	   * listeners or SequentialExecutor object.
	   *
	   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
	   *   a list of events and callbacks, or an event emitter object
	   *   containing listeners to add to this emitter object.
	   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
	   * @example Adding listeners from a map of listeners
	   *   emitter.addListeners({
	   *     event1: [function() { ... }, function() { ... }],
	   *     event2: [function() { ... }]
	   *   });
	   *   emitter.emit('event1'); // emitter has event1
	   *   emitter.emit('event2'); // emitter has event2
	   * @example Adding listeners from another emitter object
	   *   var emitter1 = new AWS.SequentialExecutor();
	   *   emitter1.on('event1', function() { ... });
	   *   emitter1.on('event2', function() { ... });
	   *   var emitter2 = new AWS.SequentialExecutor();
	   *   emitter2.addListeners(emitter1);
	   *   emitter2.emit('event1'); // emitter2 has event1
	   *   emitter2.emit('event2'); // emitter2 has event2
	   */
	  addListeners: function addListeners(listeners) {
	    var self = this;

	    // extract listeners if parameter is an SequentialExecutor object
	    if (listeners._events) listeners = listeners._events;

	    AWS.util.each(listeners, function(event, callbacks) {
	      if (typeof callbacks === 'function') callbacks = [callbacks];
	      AWS.util.arrayEach(callbacks, function(callback) {
	        self.on(event, callback);
	      });
	    });

	    return self;
	  },

	  /**
	   * Registers an event with {on} and saves the callback handle function
	   * as a property on the emitter object using a given `name`.
	   *
	   * @param name [String] the property name to set on this object containing
	   *   the callback function handle so that the listener can be removed in
	   *   the future.
	   * @param (see on)
	   * @return (see on)
	   * @example Adding a named listener DATA_CALLBACK
	   *   var listener = function() { doSomething(); };
	   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
	   *
	   *   // the following prints: true
	   *   console.log(emitter.DATA_CALLBACK == listener);
	   */
	  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
	    this[name] = callback;
	    this.addListener(eventName, callback, toHead);
	    return this;
	  },

	  /**
	   * @api private
	   */
	  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {
	    callback._isAsync = true;
	    return this.addNamedListener(name, eventName, callback);
	  },

	  /**
	   * Helper method to add a set of named listeners using
	   * {addNamedListener}. The callback contains a parameter
	   * with a handle to the `addNamedListener` method.
	   *
	   * @callback callback function(add)
	   *   The callback function is called immediately in order to provide
	   *   the `add` function to the block. This simplifies the addition of
	   *   a large group of named listeners.
	   *   @param add [Function] the {addNamedListener} function to call
	   *     when registering listeners.
	   * @example Adding a set of named listeners
	   *   emitter.addNamedListeners(function(add) {
	   *     add('DATA_CALLBACK', 'data', function() { ... });
	   *     add('OTHER', 'otherEvent', function() { ... });
	   *     add('LAST', 'lastEvent', function() { ... });
	   *   });
	   *
	   *   // these properties are now set:
	   *   emitter.DATA_CALLBACK;
	   *   emitter.OTHER;
	   *   emitter.LAST;
	   */
	  addNamedListeners: function addNamedListeners(callback) {
	    var self = this;
	    callback(
	      function() {
	        self.addNamedListener.apply(self, arguments);
	      },
	      function() {
	        self.addNamedAsyncListener.apply(self, arguments);
	      }
	    );
	    return this;
	  }
	});

	/**
	 * {on} is the prefered method.
	 * @api private
	 */
	AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

	/**
	 * @api private
	 */
	module.exports = AWS.SequentialExecutor;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var Api = __webpack_require__(176);
	var regionConfig = __webpack_require__(183);

	var inherit = AWS.util.inherit;
	var clientCount = 0;

	/**
	 * The service class representing an AWS service.
	 *
	 * @abstract
	 *
	 * @!attribute apiVersions
	 *   @return [Array<String>] the list of API versions supported by this service.
	 *   @readonly
	 */
	AWS.Service = inherit({
	  /**
	   * Create a new service object with a configuration object
	   *
	   * @param config [map] a map of configuration options
	   */
	  constructor: function Service(config) {
	    if (!this.loadServiceClass) {
	      throw AWS.util.error(new Error(),
	        'Service must be constructed with `new\' operator');
	    }
	    var ServiceClass = this.loadServiceClass(config || {});
	    if (ServiceClass) {
	      var originalConfig = AWS.util.copy(config);
	      var svc = new ServiceClass(config);
	      Object.defineProperty(svc, '_originalConfig', {
	        get: function() { return originalConfig; },
	        enumerable: false,
	        configurable: true
	      });
	      svc._clientId = ++clientCount;
	      return svc;
	    }
	    this.initialize(config);
	  },

	  /**
	   * @api private
	   */
	  initialize: function initialize(config) {
	    var svcConfig = AWS.config[this.serviceIdentifier];
	    this.config = new AWS.Config(AWS.config);
	    if (svcConfig) this.config.update(svcConfig, true);
	    if (config) this.config.update(config, true);

	    this.validateService();
	    if (!this.config.endpoint) regionConfig(this);

	    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
	    this.setEndpoint(this.config.endpoint);
	    //enable attaching listeners to service client
	    AWS.SequentialExecutor.call(this);
	    AWS.Service.addDefaultMonitoringListeners(this);
	    if (this.config.clientSideMonitoring && this.publisher) {
	      var publisher = this.publisher;
	      this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
	        process.nextTick(function() {publisher.eventHandler(event);});
	      });
	      this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
	        process.nextTick(function() {publisher.eventHandler(event);});
	      });
	    }
	  },

	  /**
	   * @api private
	   */
	  validateService: function validateService() {
	  },

	  /**
	   * @api private
	   */
	  loadServiceClass: function loadServiceClass(serviceConfig) {
	    var config = serviceConfig;
	    if (!AWS.util.isEmpty(this.api)) {
	      return null;
	    } else if (config.apiConfig) {
	      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
	    } else if (!this.constructor.services) {
	      return null;
	    } else {
	      config = new AWS.Config(AWS.config);
	      config.update(serviceConfig, true);
	      var version = config.apiVersions[this.constructor.serviceIdentifier];
	      version = version || config.apiVersion;
	      return this.getLatestServiceClass(version);
	    }
	  },

	  /**
	   * @api private
	   */
	  getLatestServiceClass: function getLatestServiceClass(version) {
	    version = this.getLatestServiceVersion(version);
	    if (this.constructor.services[version] === null) {
	      AWS.Service.defineServiceApi(this.constructor, version);
	    }

	    return this.constructor.services[version];
	  },

	  /**
	   * @api private
	   */
	  getLatestServiceVersion: function getLatestServiceVersion(version) {
	    if (!this.constructor.services || this.constructor.services.length === 0) {
	      throw new Error('No services defined on ' +
	                      this.constructor.serviceIdentifier);
	    }

	    if (!version) {
	      version = 'latest';
	    } else if (AWS.util.isType(version, Date)) {
	      version = AWS.util.date.iso8601(version).split('T')[0];
	    }

	    if (Object.hasOwnProperty(this.constructor.services, version)) {
	      return version;
	    }

	    var keys = Object.keys(this.constructor.services).sort();
	    var selectedVersion = null;
	    for (var i = keys.length - 1; i >= 0; i--) {
	      // versions that end in "*" are not available on disk and can be
	      // skipped, so do not choose these as selectedVersions
	      if (keys[i][keys[i].length - 1] !== '*') {
	        selectedVersion = keys[i];
	      }
	      if (keys[i].substr(0, 10) <= version) {
	        return selectedVersion;
	      }
	    }

	    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
	                    ' API to satisfy version constraint `' + version + '\'');
	  },

	  /**
	   * @api private
	   */
	  api: {},

	  /**
	   * @api private
	   */
	  defaultRetryCount: 3,

	  /**
	   * @api private
	   */
	  customizeRequests: function customizeRequests(callback) {
	    if (!callback) {
	      this.customRequestHandler = null;
	    } else if (typeof callback === 'function') {
	      this.customRequestHandler = callback;
	    } else {
	      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
	    }
	  },

	  /**
	   * Calls an operation on a service with the given input parameters.
	   *
	   * @param operation [String] the name of the operation to call on the service.
	   * @param params [map] a map of input options for the operation
	   * @callback callback function(err, data)
	   *   If a callback is supplied, it is called when a response is returned
	   *   from the service.
	   *   @param err [Error] the error object returned from the request.
	   *     Set to `null` if the request is successful.
	   *   @param data [Object] the de-serialized data returned from
	   *     the request. Set to `null` if a request error occurs.
	   */
	  makeRequest: function makeRequest(operation, params, callback) {
	    if (typeof params === 'function') {
	      callback = params;
	      params = null;
	    }

	    params = params || {};
	    if (this.config.params) { // copy only toplevel bound params
	      var rules = this.api.operations[operation];
	      if (rules) {
	        params = AWS.util.copy(params);
	        AWS.util.each(this.config.params, function(key, value) {
	          if (rules.input.members[key]) {
	            if (params[key] === undefined || params[key] === null) {
	              params[key] = value;
	            }
	          }
	        });
	      }
	    }

	    var request = new AWS.Request(this, operation, params);
	    this.addAllRequestListeners(request);
	    this.attachMonitoringEmitter(request);
	    if (callback) request.send(callback);
	    return request;
	  },

	  /**
	   * Calls an operation on a service with the given input parameters, without
	   * any authentication data. This method is useful for "public" API operations.
	   *
	   * @param operation [String] the name of the operation to call on the service.
	   * @param params [map] a map of input options for the operation
	   * @callback callback function(err, data)
	   *   If a callback is supplied, it is called when a response is returned
	   *   from the service.
	   *   @param err [Error] the error object returned from the request.
	   *     Set to `null` if the request is successful.
	   *   @param data [Object] the de-serialized data returned from
	   *     the request. Set to `null` if a request error occurs.
	   */
	  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
	    if (typeof params === 'function') {
	      callback = params;
	      params = {};
	    }

	    var request = this.makeRequest(operation, params).toUnauthenticated();
	    return callback ? request.send(callback) : request;
	  },

	  /**
	   * Waits for a given state
	   *
	   * @param state [String] the state on the service to wait for
	   * @param params [map] a map of parameters to pass with each request
	   * @option params $waiter [map] a map of configuration options for the waiter
	   * @option params $waiter.delay [Number] The number of seconds to wait between
	   *                                       requests
	   * @option params $waiter.maxAttempts [Number] The maximum number of requests
	   *                                             to send while waiting
	   * @callback callback function(err, data)
	   *   If a callback is supplied, it is called when a response is returned
	   *   from the service.
	   *   @param err [Error] the error object returned from the request.
	   *     Set to `null` if the request is successful.
	   *   @param data [Object] the de-serialized data returned from
	   *     the request. Set to `null` if a request error occurs.
	   */
	  waitFor: function waitFor(state, params, callback) {
	    var waiter = new AWS.ResourceWaiter(this, state);
	    return waiter.wait(params, callback);
	  },

	  /**
	   * @api private
	   */
	  addAllRequestListeners: function addAllRequestListeners(request) {
	    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
	                AWS.EventListeners.CorePost];
	    for (var i = 0; i < list.length; i++) {
	      if (list[i]) request.addListeners(list[i]);
	    }

	    // disable parameter validation
	    if (!this.config.paramValidation) {
	      request.removeListener('validate',
	        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
	    }

	    if (this.config.logger) { // add logging events
	      request.addListeners(AWS.EventListeners.Logger);
	    }

	    this.setupRequestListeners(request);
	    // call prototype's customRequestHandler
	    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
	      this.constructor.prototype.customRequestHandler(request);
	    }
	    // call instance's customRequestHandler
	    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
	      this.customRequestHandler(request);
	    }
	  },

	  /**
	   * Event recording metrics for a whole API call.
	   * @returns {object} a subset of api call metrics
	   * @api private
	   */
	  apiCallEvent: function apiCallEvent(request) {
	    var api = request.service.api.operations[request.operation];
	    return {
	      Type: 'ApiCall',
	      Api: api ? api.name : request.operation,
	      Version: 1,
	      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
	    }
	  },

	  /**
	   * Event recording metrics for an API call attempt.
	   * @returns {object} a subset of api call attempt metrics
	   * @api private
	   */
	  apiAttemptEvent: function apiAttemptEvent(request) {
	    var api = request.service.api.operations[request.operation];
	    var monitoringEvent = {
	      Type: 'ApiCallAttempt',
	      Api: api ? api.name : request.operation,
	      Version: 1,
	      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
	      Fqdn: request.httpRequest.endpoint.hostname,
	      UserAgent: request.httpRequest.getUserAgent(),
	    };
	    var response = request.response;
	    if (!response.httpResponse.headers) return monitoringEvent;
	    if (request.httpRequest.headers['x-amz-security-token']) {
	      monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
	    }
	    if (response.httpResponse.headers['x-amzn-requestid']) {
	      monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
	    }
	    if (response.httpResponse.headers['x-amz-request-id']) {
	      monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
	    }
	    if (response.httpResponse.headers['x-amz-id-2']) {
	      monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
	    }
	    if (response.httpResponse.statusCode) {
	      monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
	    }
	    if (
	      !request._unAuthenticated &&
	      request.service.config.credentials.accessKeyId
	    ) {
	      monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
	    }
	    return monitoringEvent
	  },

	  /**
	   * Add metrics of failed request.
	   * @api private
	   */
	  attemptFailEvent: function attemptFailEvent(request) {
	    var monitoringEvent = this.apiAttemptEvent(request);
	    var response = request.response;
	    if (response.httpResponse.statusCode > 299 ) {
	      monitoringEvent.AwsException = response.error.code;
	      monitoringEvent.AwsExceptionMessage = response.error.message;
	    } else {
	      monitoringEvent.SdkException = response.error.code || response.error.name;
	      monitoringEvent.SdkExceptionMessage = response.error.message;
	    }
	    return monitoringEvent;
	  },

	  /**
	   * Attach listeners to request object to fetch metrics of each request
	   * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
	   * @api private
	   */
	  attachMonitoringEmitter: function attachMonitoringEmitter(request) {
	    var attemptTimestamp; //timestamp marking the beginning of a request attempt
	    var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency
	    var attemptLatency; //latency from request sent out to http response reaching SDK
	    var callStartRealTime; //Start time of API call. Used to calculating API call latency
	    var attemptCount = 0; //request.retryCount is not reliable here
	    var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)
	    var callTimestamp; //timestamp when the request is created
	    var self = this;
	    var addToHead = true;

	    request.on('validate', function () {
	      callStartRealTime = AWS.util.realClock.now();
	      callTimestamp = Date.now();
	    }, addToHead);
	    request.on('sign', function () {
	      attemptStartRealTime = AWS.util.realClock.now();
	      attemptTimestamp = Date.now();
	      region = request.httpRequest.region;
	      attemptCount++;
	    }, addToHead)
	    request.on('validateResponse', function() {
	      attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
	    })
	    request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
	      var apiAttemptEvent = self.apiAttemptEvent(request);
	      apiAttemptEvent.Timestamp = attemptTimestamp;
	      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
	      apiAttemptEvent.Region = region;
	      self.emit('apiCallAttempt', [apiAttemptEvent]);
	    });
	    request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
	      var apiAttemptEvent = self.attemptFailEvent(request);
	      apiAttemptEvent.Timestamp = attemptTimestamp;
	      //attemptLatency may not be available if fail before response
	      attemptLatency = attemptLatency ||
	        Math.round(AWS.util.realClock.now() - attemptStartRealTime);
	      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
	      apiAttemptEvent.Region = region;
	      self.emit('apiCallAttempt', [apiAttemptEvent]);
	    });
	    request.addNamedListener('API_CALL', 'complete', function API_CALL() {
	      var apiCallEvent = self.apiCallEvent(request);
	      apiCallEvent.AttemptCount = attemptCount;
	      if (apiCallEvent.AttemptCount <= 0) return;
	      apiCallEvent.Timestamp = callTimestamp;
	      var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
	      apiCallEvent.Latency = latency >= 0 ? latency : 0;
	      self.emit('apiCall', [apiCallEvent]);
	    })
	  },

	  /**
	   * Override this method to setup any custom request listeners for each
	   * new request to the service.
	   *
	   * @abstract
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	  },

	  /**
	   * Gets the signer class for a given request
	   * @api private
	   */
	  getSignerClass: function getSignerClass(request) {
	    var version;
	    // get operation authtype if present
	    var operation = null;
	    var authtype = '';
	    if (request) {
	      var operations = request.service.api.operations || {};
	      operation = operations[request.operation] || null;
	      authtype = operation ? operation.authtype : '';
	    }
	    if (this.config.signatureVersion) {
	      version = this.config.signatureVersion;
	    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
	      version = 'v4';
	    } else {
	      version = this.api.signatureVersion;
	    }
	    return AWS.Signers.RequestSigner.getVersion(version);
	  },

	  /**
	   * @api private
	   */
	  serviceInterface: function serviceInterface() {
	    switch (this.api.protocol) {
	      case 'ec2': return AWS.EventListeners.Query;
	      case 'query': return AWS.EventListeners.Query;
	      case 'json': return AWS.EventListeners.Json;
	      case 'rest-json': return AWS.EventListeners.RestJson;
	      case 'rest-xml': return AWS.EventListeners.RestXml;
	    }
	    if (this.api.protocol) {
	      throw new Error('Invalid service `protocol\' ' +
	        this.api.protocol + ' in API config');
	    }
	  },

	  /**
	   * @api private
	   */
	  successfulResponse: function successfulResponse(resp) {
	    return resp.httpResponse.statusCode < 300;
	  },

	  /**
	   * How many times a failed request should be retried before giving up.
	   * the defaultRetryCount can be overriden by service classes.
	   *
	   * @api private
	   */
	  numRetries: function numRetries() {
	    if (this.config.maxRetries !== undefined) {
	      return this.config.maxRetries;
	    } else {
	      return this.defaultRetryCount;
	    }
	  },

	  /**
	   * @api private
	   */
	  retryDelays: function retryDelays(retryCount) {
	    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions);
	  },

	  /**
	   * @api private
	   */
	  retryableError: function retryableError(error) {
	    if (this.timeoutError(error)) return true;
	    if (this.networkingError(error)) return true;
	    if (this.expiredCredentialsError(error)) return true;
	    if (this.throttledError(error)) return true;
	    if (error.statusCode >= 500) return true;
	    return false;
	  },

	  /**
	   * @api private
	   */
	  networkingError: function networkingError(error) {
	    return error.code === 'NetworkingError';
	  },

	  /**
	   * @api private
	   */
	  timeoutError: function timeoutError(error) {
	    return error.code === 'TimeoutError';
	  },

	  /**
	   * @api private
	   */
	  expiredCredentialsError: function expiredCredentialsError(error) {
	    // TODO : this only handles *one* of the expired credential codes
	    return (error.code === 'ExpiredTokenException');
	  },

	  /**
	   * @api private
	   */
	  clockSkewError: function clockSkewError(error) {
	    switch (error.code) {
	      case 'RequestTimeTooSkewed':
	      case 'RequestExpired':
	      case 'InvalidSignatureException':
	      case 'SignatureDoesNotMatch':
	      case 'AuthFailure':
	      case 'RequestInTheFuture':
	        return true;
	      default: return false;
	    }
	  },

	  /**
	   * @api private
	   */
	  getSkewCorrectedDate: function getSkewCorrectedDate() {
	    return new Date(Date.now() + this.config.systemClockOffset);
	  },

	  /**
	   * @api private
	   */
	  applyClockOffset: function applyClockOffset(newServerTime) {
	    if (newServerTime) {
	      this.config.systemClockOffset = newServerTime - Date.now();
	    }
	  },

	  /**
	   * @api private
	   */
	  isClockSkewed: function isClockSkewed(newServerTime) {
	    if (newServerTime) {
	      return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 30000;
	    }
	  },

	  /**
	   * @api private
	   */
	  throttledError: function throttledError(error) {
	    // this logic varies between services
	    switch (error.code) {
	      case 'ProvisionedThroughputExceededException':
	      case 'Throttling':
	      case 'ThrottlingException':
	      case 'RequestLimitExceeded':
	      case 'RequestThrottled':
	      case 'TooManyRequestsException':
	        return true;
	      default:
	        return false;
	    }
	  },

	  /**
	   * @api private
	   */
	  endpointFromTemplate: function endpointFromTemplate(endpoint) {
	    if (typeof endpoint !== 'string') return endpoint;

	    var e = endpoint;
	    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
	    e = e.replace(/\{region\}/g, this.config.region);
	    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
	    return e;
	  },

	  /**
	   * @api private
	   */
	  setEndpoint: function setEndpoint(endpoint) {
	    this.endpoint = new AWS.Endpoint(endpoint, this.config);
	  },

	  /**
	   * @api private
	   */
	  paginationConfig: function paginationConfig(operation, throwException) {
	    var paginator = this.api.operations[operation].paginator;
	    if (!paginator) {
	      if (throwException) {
	        var e = new Error();
	        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
	      }
	      return null;
	    }

	    return paginator;
	  }
	});

	AWS.util.update(AWS.Service, {

	  /**
	   * Adds one method for each operation described in the api configuration
	   *
	   * @api private
	   */
	  defineMethods: function defineMethods(svc) {
	    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
	      if (svc.prototype[method]) return;
	      var operation = svc.prototype.api.operations[method];
	      if (operation.authtype === 'none') {
	        svc.prototype[method] = function (params, callback) {
	          return this.makeUnauthenticatedRequest(method, params, callback);
	        };
	      } else {
	        svc.prototype[method] = function (params, callback) {
	          return this.makeRequest(method, params, callback);
	        };
	      }
	    });
	  },

	  /**
	   * Defines a new Service class using a service identifier and list of versions
	   * including an optional set of features (functions) to apply to the class
	   * prototype.
	   *
	   * @param serviceIdentifier [String] the identifier for the service
	   * @param versions [Array<String>] a list of versions that work with this
	   *   service
	   * @param features [Object] an object to attach to the prototype
	   * @return [Class<Service>] the service class defined by this function.
	   */
	  defineService: function defineService(serviceIdentifier, versions, features) {
	    AWS.Service._serviceMap[serviceIdentifier] = true;
	    if (!Array.isArray(versions)) {
	      features = versions;
	      versions = [];
	    }

	    var svc = inherit(AWS.Service, features || {});

	    if (typeof serviceIdentifier === 'string') {
	      AWS.Service.addVersions(svc, versions);

	      var identifier = svc.serviceIdentifier || serviceIdentifier;
	      svc.serviceIdentifier = identifier;
	    } else { // defineService called with an API
	      svc.prototype.api = serviceIdentifier;
	      AWS.Service.defineMethods(svc);
	    }
	    AWS.SequentialExecutor.call(this.prototype);
	    //util.clientSideMonitoring is only available in node
	    if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
	      var Publisher = AWS.util.clientSideMonitoring.Publisher;
	      var configProvider = AWS.util.clientSideMonitoring.configProvider;
	      this.prototype.publisher = new Publisher(configProvider());
	    }
	    AWS.SequentialExecutor.call(svc.prototype);
	    AWS.Service.addDefaultMonitoringListeners(svc.prototype);
	    return svc;
	  },

	  /**
	   * @api private
	   */
	  addVersions: function addVersions(svc, versions) {
	    if (!Array.isArray(versions)) versions = [versions];

	    svc.services = svc.services || {};
	    for (var i = 0; i < versions.length; i++) {
	      if (svc.services[versions[i]] === undefined) {
	        svc.services[versions[i]] = null;
	      }
	    }

	    svc.apiVersions = Object.keys(svc.services).sort();
	  },

	  /**
	   * @api private
	   */
	  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
	    var svc = inherit(superclass, {
	      serviceIdentifier: superclass.serviceIdentifier
	    });

	    function setApi(api) {
	      if (api.isApi) {
	        svc.prototype.api = api;
	      } else {
	        svc.prototype.api = new Api(api);
	      }
	    }

	    if (typeof version === 'string') {
	      if (apiConfig) {
	        setApi(apiConfig);
	      } else {
	        try {
	          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
	        } catch (err) {
	          throw AWS.util.error(err, {
	            message: 'Could not find API configuration ' +
	              superclass.serviceIdentifier + '-' + version
	          });
	        }
	      }
	      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
	        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
	      }
	      superclass.services[version] = svc;
	    } else {
	      setApi(version);
	    }

	    AWS.Service.defineMethods(svc);
	    return svc;
	  },

	  /**
	   * @api private
	   */
	  hasService: function(identifier) {
	    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
	  },

	  /**
	   * @param attachOn attach default monitoring listeners to object
	   *
	   * Each monitoring event should be emitted from service client to service constructor prototype and then
	   * to global service prototype like bubbling up. These default monitoring events listener will transfer
	   * the monitoring events to the upper layer.
	   * @api private
	   */
	  addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
	    attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
	      var baseClass = Object.getPrototypeOf(attachOn);
	      if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
	    });
	    attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
	      var baseClass = Object.getPrototypeOf(attachOn);
	      if (baseClass._events) baseClass.emit('apiCall', [event]);
	    });
	  },

	  /**
	   * @api private
	   */
	  _serviceMap: {}
	});

	AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);

	/**
	 * @api private
	 */
	module.exports = AWS.Service;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(159);
	var regionConfig = __webpack_require__(184);

	function generateRegionPrefix(region) {
	  if (!region) return null;

	  var parts = region.split('-');
	  if (parts.length < 3) return null;
	  return parts.slice(0, parts.length - 2).join('-') + '-*';
	}

	function derivedKeys(service) {
	  var region = service.config.region;
	  var regionPrefix = generateRegionPrefix(region);
	  var endpointPrefix = service.api.endpointPrefix;

	  return [
	    [region, endpointPrefix],
	    [regionPrefix, endpointPrefix],
	    [region, '*'],
	    [regionPrefix, '*'],
	    ['*', endpointPrefix],
	    ['*', '*']
	  ].map(function(item) {
	    return item[0] && item[1] ? item.join('/') : null;
	  });
	}

	function applyConfig(service, config) {
	  util.each(config, function(key, value) {
	    if (key === 'globalEndpoint') return;
	    if (service.config[key] === undefined || service.config[key] === null) {
	      service.config[key] = value;
	    }
	  });
	}

	function configureEndpoint(service) {
	  var keys = derivedKeys(service);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!key) continue;

	    if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {
	      var config = regionConfig.rules[key];
	      if (typeof config === 'string') {
	        config = regionConfig.patterns[config];
	      }

	      // set dualstack endpoint
	      if (service.config.useDualstack && util.isDualstackAvailable(service)) {
	        config = util.copy(config);
	        config.endpoint = '{service}.dualstack.{region}.amazonaws.com';
	      }

	      // set global endpoint
	      service.isGlobalEndpoint = !!config.globalEndpoint;

	      // signature version
	      if (!config.signatureVersion) config.signatureVersion = 'v4';

	      // merge config
	      applyConfig(service, config);
	      return;
	    }
	  }
	}

	/**
	 * @api private
	 */
	module.exports = configureEndpoint;


/***/ }),
/* 184 */
/***/ (function(module, exports) {

	module.exports = {"rules":{"*/*":{"endpoint":"{service}.{region}.amazonaws.com"},"cn-*/*":{"endpoint":"{service}.{region}.amazonaws.com.cn"},"*/budgets":"globalSSL","*/cloudfront":"globalSSL","*/iam":"globalSSL","*/sts":"globalSSL","*/importexport":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2","globalEndpoint":true},"*/route53":{"endpoint":"https://{service}.amazonaws.com","signatureVersion":"v3https","globalEndpoint":true},"*/waf":"globalSSL","us-gov-*/iam":"globalGovCloud","us-gov-*/sts":{"endpoint":"{service}.{region}.amazonaws.com"},"us-gov-west-1/s3":"s3signature","us-west-1/s3":"s3signature","us-west-2/s3":"s3signature","eu-west-1/s3":"s3signature","ap-southeast-1/s3":"s3signature","ap-southeast-2/s3":"s3signature","ap-northeast-1/s3":"s3signature","sa-east-1/s3":"s3signature","us-east-1/s3":{"endpoint":"{service}.amazonaws.com","signatureVersion":"s3"},"us-east-1/sdb":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2"},"*/sdb":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"v2"}},"patterns":{"globalSSL":{"endpoint":"https://{service}.amazonaws.com","globalEndpoint":true},"globalGovCloud":{"endpoint":"{service}.us-gov.amazonaws.com"},"s3signature":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"s3"}}}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	__webpack_require__(186);
	__webpack_require__(187);
	var PromisesDependency;

	/**
	 * The main configuration class used by all service objects to set
	 * the region, credentials, and other options for requests.
	 *
	 * By default, credentials and region settings are left unconfigured.
	 * This should be configured by the application before using any
	 * AWS service APIs.
	 *
	 * In order to set global configuration options, properties should
	 * be assigned to the global {AWS.config} object.
	 *
	 * @see AWS.config
	 *
	 * @!group General Configuration Options
	 *
	 * @!attribute credentials
	 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
	 *
	 * @!attribute region
	 *   @example Set the global region setting to us-west-2
	 *     AWS.config.update({region: 'us-west-2'});
	 *   @return [AWS.Credentials] The region to send service requests to.
	 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
	 *     A list of available endpoints for each AWS service
	 *
	 * @!attribute maxRetries
	 *   @return [Integer] the maximum amount of retries to perform for a
	 *     service request. By default this value is calculated by the specific
	 *     service object that the request is being made to.
	 *
	 * @!attribute maxRedirects
	 *   @return [Integer] the maximum amount of redirects to follow for a
	 *     service request. Defaults to 10.
	 *
	 * @!attribute paramValidation
	 *   @return [Boolean|map] whether input parameters should be validated against
	 *     the operation description before sending the request. Defaults to true.
	 *     Pass a map to enable any of the following specific validation features:
	 *
	 *     * **min** [Boolean] &mdash; Validates that a value meets the min
	 *       constraint. This is enabled by default when paramValidation is set
	 *       to `true`.
	 *     * **max** [Boolean] &mdash; Validates that a value meets the max
	 *       constraint.
	 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
	 *       regular expression.
	 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
	 *       of the allowable enum values.
	 *
	 * @!attribute computeChecksums
	 *   @return [Boolean] whether to compute checksums for payload bodies when
	 *     the service accepts it (currently supported in S3 only).
	 *
	 * @!attribute convertResponseTypes
	 *   @return [Boolean] whether types are converted when parsing response data.
	 *     Currently only supported for JSON based services. Turning this off may
	 *     improve performance on large response payloads. Defaults to `true`.
	 *
	 * @!attribute correctClockSkew
	 *   @return [Boolean] whether to apply a clock skew correction and retry
	 *     requests that fail because of an skewed client clock. Defaults to
	 *     `false`.
	 *
	 * @!attribute sslEnabled
	 *   @return [Boolean] whether SSL is enabled for requests
	 *
	 * @!attribute s3ForcePathStyle
	 *   @return [Boolean] whether to force path style URLs for S3 objects
	 *
	 * @!attribute s3BucketEndpoint
	 *   @note Setting this configuration option requires an `endpoint` to be
	 *     provided explicitly to the service constructor.
	 *   @return [Boolean] whether the provided endpoint addresses an individual
	 *     bucket (false if it addresses the root API endpoint).
	 *
	 * @!attribute s3DisableBodySigning
	 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
	 *     Body signing can only be disabled when using https. Defaults to `true`.
	 *
	 * @!attribute useAccelerateEndpoint
	 *   @note This configuration option is only compatible with S3 while accessing
	 *     dns-compatible buckets.
	 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
	 *     Defaults to `false`.
	 *
	 * @!attribute retryDelayOptions
	 *   @example Set the base retry delay for all services to 300 ms
	 *     AWS.config.update({retryDelayOptions: {base: 300}});
	 *     // Delays with maxRetries = 3: 300, 600, 1200
	 *   @example Set a custom backoff function to provide delay values on retries
	 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount) {
	 *       // returns delay in ms
	 *     }}});
	 *   @return [map] A set of options to configure the retry delay on retryable errors.
	 *     Currently supported options are:
	 *
	 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
	 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
	 *       DynamoDB, where it defaults to 50ms.
	 *     * **customBackoff ** [function] &mdash; A custom function that accepts a retry count
	 *       and returns the amount of time to delay in milliseconds. The `base` option will be
	 *       ignored if this option is supplied.
	 *
	 * @!attribute httpOptions
	 *   @return [map] A set of options to pass to the low-level HTTP request.
	 *     Currently supported options are:
	 *
	 *     * **proxy** [String] &mdash; the URL to proxy requests through
	 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
	 *       HTTP requests with. Used for connection pooling. Defaults to the global
	 *       agent (`http.globalAgent`) for non-SSL connections. Note that for
	 *       SSL connections, a special Agent object is used in order to enable
	 *       peer certificate verification. This feature is only supported in the
	 *       Node.js environment.
	 *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
	 *       failing to establish a connection with the server after
	 *       `connectTimeout` milliseconds. This timeout has no effect once a socket
	 *       connection has been established.
	 *     * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
	 *       milliseconds of inactivity on the socket. Defaults to two minutes
	 *       (120000)
	 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
	 *       HTTP requests. Used in the browser environment only. Set to false to
	 *       send requests synchronously. Defaults to true (async on).
	 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
	 *       property of an XMLHttpRequest object. Used in the browser environment
	 *       only. Defaults to false.
	 * @!attribute logger
	 *   @return [#write,#log] an object that responds to .write() (like a stream)
	 *     or .log() (like the console object) in order to log information about
	 *     requests
	 *
	 * @!attribute systemClockOffset
	 *   @return [Number] an offset value in milliseconds to apply to all signing
	 *     times. Use this to compensate for clock skew when your system may be
	 *     out of sync with the service time. Note that this configuration option
	 *     can only be applied to the global `AWS.config` object and cannot be
	 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
	 *
	 * @!attribute signatureVersion
	 *   @return [String] the signature version to sign requests with (overriding
	 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
	 *
	 * @!attribute signatureCache
	 *   @return [Boolean] whether the signature to sign requests with (overriding
	 *     the API configuration) is cached. Only applies to the signature version 'v4'.
	 *     Defaults to `true`.
	 */
	AWS.Config = AWS.util.inherit({
	  /**
	   * @!endgroup
	   */

	  /**
	   * Creates a new configuration object. This is the object that passes
	   * option data along to service requests, including credentials, security,
	   * region information, and some service specific settings.
	   *
	   * @example Creating a new configuration object with credentials and region
	   *   var config = new AWS.Config({
	   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
	   *   });
	   * @option options accessKeyId [String] your AWS access key ID.
	   * @option options secretAccessKey [String] your AWS secret access key.
	   * @option options sessionToken [AWS.Credentials] the optional AWS
	   *   session token to sign requests with.
	   * @option options credentials [AWS.Credentials] the AWS credentials
	   *   to sign requests with. You can either specify this object, or
	   *   specify the accessKeyId and secretAccessKey options directly.
	   * @option options credentialProvider [AWS.CredentialProviderChain] the
	   *   provider chain used to resolve credentials if no static `credentials`
	   *   property is set.
	   * @option options region [String] the region to send service requests to.
	   *   See {region} for more information.
	   * @option options maxRetries [Integer] the maximum amount of retries to
	   *   attempt with a request. See {maxRetries} for more information.
	   * @option options maxRedirects [Integer] the maximum amount of redirects to
	   *   follow with a request. See {maxRedirects} for more information.
	   * @option options sslEnabled [Boolean] whether to enable SSL for
	   *   requests.
	   * @option options paramValidation [Boolean|map] whether input parameters
	   *   should be validated against the operation description before sending
	   *   the request. Defaults to true. Pass a map to enable any of the
	   *   following specific validation features:
	   *
	   *   * **min** [Boolean] &mdash; Validates that a value meets the min
	   *     constraint. This is enabled by default when paramValidation is set
	   *     to `true`.
	   *   * **max** [Boolean] &mdash; Validates that a value meets the max
	   *     constraint.
	   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
	   *     regular expression.
	   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
	   *     of the allowable enum values.
	   * @option options computeChecksums [Boolean] whether to compute checksums
	   *   for payload bodies when the service accepts it (currently supported
	   *   in S3 only)
	   * @option options convertResponseTypes [Boolean] whether types are converted
	   *     when parsing response data. Currently only supported for JSON based
	   *     services. Turning this off may improve performance on large response
	   *     payloads. Defaults to `true`.
	   * @option options correctClockSkew [Boolean] whether to apply a clock skew
	   *     correction and retry requests that fail because of an skewed client
	   *     clock. Defaults to `false`.
	   * @option options s3ForcePathStyle [Boolean] whether to force path
	   *   style URLs for S3 objects.
	   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
	   *   addresses an individual bucket (false if it addresses the root API
	   *   endpoint). Note that setting this configuration option requires an
	   *   `endpoint` to be provided explicitly to the service constructor.
	   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
	   *   should be disabled when using signature version `v4`. Body signing
	   *   can only be disabled when using https. Defaults to `true`.
	   *
	   * @option options retryDelayOptions [map] A set of options to configure
	   *   the retry delay on retryable errors. Currently supported options are:
	   *
	   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
	   *     exponential backoff for operation retries. Defaults to 100 ms for all
	   *     services except DynamoDB, where it defaults to 50ms.
	   *   * **customBackoff ** [function] &mdash; A custom function that accepts a retry count
	   *     and returns the amount of time to delay in milliseconds. The `base` option will be
	   *     ignored if this option is supplied.
	   * @option options httpOptions [map] A set of options to pass to the low-level
	   *   HTTP request. Currently supported options are:
	   *
	   *   * **proxy** [String] &mdash; the URL to proxy requests through
	   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
	   *     HTTP requests with. Used for connection pooling. Defaults to the global
	   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
	   *     SSL connections, a special Agent object is used in order to enable
	   *     peer certificate verification. This feature is only available in the
	   *     Node.js environment.
	   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
	   *     failing to establish a connection with the server after
	   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
	   *     connection has been established.
	   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
	   *     milliseconds of inactivity on the socket. Defaults to two minutes
	   *     (120000).
	   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
	   *     HTTP requests. Used in the browser environment only. Set to false to
	   *     send requests synchronously. Defaults to true (async on).
	   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
	   *     property of an XMLHttpRequest object. Used in the browser environment
	   *     only. Defaults to false.
	   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
	   *   (or a date) that represents the latest possible API version that can be
	   *   used in all services (unless overridden by `apiVersions`). Specify
	   *   'latest' to use the latest possible version.
	   * @option options apiVersions [map<String, String|Date>] a map of service
	   *   identifiers (the lowercase service class name) with the API version to
	   *   use when instantiating a service. Specify 'latest' for each individual
	   *   that can use the latest available version.
	   * @option options logger [#write,#log] an object that responds to .write()
	   *   (like a stream) or .log() (like the console object) in order to log
	   *   information about requests
	   * @option options systemClockOffset [Number] an offset value in milliseconds
	   *   to apply to all signing times. Use this to compensate for clock skew
	   *   when your system may be out of sync with the service time. Note that
	   *   this configuration option can only be applied to the global `AWS.config`
	   *   object and cannot be overridden in service-specific configuration.
	   *   Defaults to 0 milliseconds.
	   * @option options signatureVersion [String] the signature version to sign
	   *   requests with (overriding the API configuration). Possible values are:
	   *   'v2', 'v3', 'v4'.
	   * @option options signatureCache [Boolean] whether the signature to sign
	   *   requests with (overriding the API configuration) is cached. Only applies
	   *   to the signature version 'v4'. Defaults to `true`.
	   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
	   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
	   * @option options clientSideMonitoring [Boolean] whether to collect and
	   * publish this client's performance metrics of all its API requests.
	   */
	  constructor: function Config(options) {
	    if (options === undefined) options = {};
	    options = this.extractCredentials(options);

	    AWS.util.each.call(this, this.keys, function (key, value) {
	      this.set(key, options[key], value);
	    });
	  },

	  /**
	   * @!group Managing Credentials
	   */

	  /**
	   * Loads credentials from the configuration object. This is used internally
	   * by the SDK to ensure that refreshable {Credentials} objects are properly
	   * refreshed and loaded when sending a request. If you want to ensure that
	   * your credentials are loaded prior to a request, you can use this method
	   * directly to provide accurate credential data stored in the object.
	   *
	   * @note If you configure the SDK with static or environment credentials,
	   *   the credential data should already be present in {credentials} attribute.
	   *   This method is primarily necessary to load credentials from asynchronous
	   *   sources, or sources that can refresh credentials periodically.
	   * @example Getting your access key
	   *   AWS.config.getCredentials(function(err) {
	   *     if (err) console.log(err.stack); // credentials not loaded
	   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
	   *   })
	   * @callback callback function(err)
	   *   Called when the {credentials} have been properly set on the configuration
	   *   object.
	   *
	   *   @param err [Error] if this is set, credentials were not successfully
	   *     loaded and this error provides information why.
	   * @see credentials
	   * @see Credentials
	   */
	  getCredentials: function getCredentials(callback) {
	    var self = this;

	    function finish(err) {
	      callback(err, err ? null : self.credentials);
	    }

	    function credError(msg, err) {
	      return new AWS.util.error(err || new Error(), {
	        code: 'CredentialsError',
	        message: msg,
	        name: 'CredentialsError'
	      });
	    }

	    function getAsyncCredentials() {
	      self.credentials.get(function(err) {
	        if (err) {
	          var msg = 'Could not load credentials from ' +
	            self.credentials.constructor.name;
	          err = credError(msg, err);
	        }
	        finish(err);
	      });
	    }

	    function getStaticCredentials() {
	      var err = null;
	      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
	        err = credError('Missing credentials');
	      }
	      finish(err);
	    }

	    if (self.credentials) {
	      if (typeof self.credentials.get === 'function') {
	        getAsyncCredentials();
	      } else { // static credentials
	        getStaticCredentials();
	      }
	    } else if (self.credentialProvider) {
	      self.credentialProvider.resolve(function(err, creds) {
	        if (err) {
	          err = credError('Could not load credentials from any providers', err);
	        }
	        self.credentials = creds;
	        finish(err);
	      });
	    } else {
	      finish(credError('No credentials to load'));
	    }
	  },

	  /**
	   * @!group Loading and Setting Configuration Options
	   */

	  /**
	   * @overload update(options, allowUnknownKeys = false)
	   *   Updates the current configuration object with new options.
	   *
	   *   @example Update maxRetries property of a configuration object
	   *     config.update({maxRetries: 10});
	   *   @param [Object] options a map of option keys and values.
	   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
	   *     the configuration object. Defaults to `false`.
	   *   @see constructor
	   */
	  update: function update(options, allowUnknownKeys) {
	    allowUnknownKeys = allowUnknownKeys || false;
	    options = this.extractCredentials(options);
	    AWS.util.each.call(this, options, function (key, value) {
	      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
	          AWS.Service.hasService(key)) {
	        this.set(key, value);
	      }
	    });
	  },

	  /**
	   * Loads configuration data from a JSON file into this config object.
	   * @note Loading configuration will reset all existing configuration
	   *   on the object.
	   * @!macro nobrowser
	   * @param path [String] the path relative to your process's current
	   *    working directory to load configuration from.
	   * @return [AWS.Config] the same configuration object
	   */
	  loadFromPath: function loadFromPath(path) {
	    this.clear();

	    var options = JSON.parse(AWS.util.readFileSync(path));
	    var fileSystemCreds = new AWS.FileSystemCredentials(path);
	    var chain = new AWS.CredentialProviderChain();
	    chain.providers.unshift(fileSystemCreds);
	    chain.resolve(function (err, creds) {
	      if (err) throw err;
	      else options.credentials = creds;
	    });

	    this.constructor(options);

	    return this;
	  },

	  /**
	   * Clears configuration data on this object
	   *
	   * @api private
	   */
	  clear: function clear() {
	    /*jshint forin:false */
	    AWS.util.each.call(this, this.keys, function (key) {
	      delete this[key];
	    });

	    // reset credential provider
	    this.set('credentials', undefined);
	    this.set('credentialProvider', undefined);
	  },

	  /**
	   * Sets a property on the configuration object, allowing for a
	   * default value
	   * @api private
	   */
	  set: function set(property, value, defaultValue) {
	    if (value === undefined) {
	      if (defaultValue === undefined) {
	        defaultValue = this.keys[property];
	      }
	      if (typeof defaultValue === 'function') {
	        this[property] = defaultValue.call(this);
	      } else {
	        this[property] = defaultValue;
	      }
	    } else if (property === 'httpOptions' && this[property]) {
	      // deep merge httpOptions
	      this[property] = AWS.util.merge(this[property], value);
	    } else {
	      this[property] = value;
	    }
	  },

	  /**
	   * All of the keys with their default values.
	   *
	   * @constant
	   * @api private
	   */
	  keys: {
	    credentials: null,
	    credentialProvider: null,
	    region: null,
	    logger: null,
	    apiVersions: {},
	    apiVersion: null,
	    endpoint: undefined,
	    httpOptions: {
	      timeout: 120000
	    },
	    maxRetries: undefined,
	    maxRedirects: 10,
	    paramValidation: true,
	    sslEnabled: true,
	    s3ForcePathStyle: false,
	    s3BucketEndpoint: false,
	    s3DisableBodySigning: true,
	    computeChecksums: true,
	    convertResponseTypes: true,
	    correctClockSkew: false,
	    customUserAgent: null,
	    dynamoDbCrc32: true,
	    systemClockOffset: 0,
	    signatureVersion: null,
	    signatureCache: true,
	    retryDelayOptions: {},
	    useAccelerateEndpoint: false,
	    clientSideMonitoring: false
	  },

	  /**
	   * Extracts accessKeyId, secretAccessKey and sessionToken
	   * from a configuration hash.
	   *
	   * @api private
	   */
	  extractCredentials: function extractCredentials(options) {
	    if (options.accessKeyId && options.secretAccessKey) {
	      options = AWS.util.copy(options);
	      options.credentials = new AWS.Credentials(options);
	    }
	    return options;
	  },

	  /**
	   * Sets the promise dependency the SDK will use wherever Promises are returned.
	   * Passing `null` will force the SDK to use native Promises if they are available.
	   * If native Promises are not available, passing `null` will have no effect.
	   * @param [Constructor] dep A reference to a Promise constructor
	   */
	  setPromisesDependency: function setPromisesDependency(dep) {
	    PromisesDependency = dep;
	    // if null was passed in, we should try to use native promises
	    if (dep === null && typeof Promise === 'function') {
	      PromisesDependency = Promise;
	    }
	    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
	    if (AWS.S3 && AWS.S3.ManagedUpload) constructors.push(AWS.S3.ManagedUpload);
	    AWS.util.addPromises(constructors, PromisesDependency);
	  },

	  /**
	   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
	   */
	  getPromisesDependency: function getPromisesDependency() {
	    return PromisesDependency;
	  }
	});

	/**
	 * @return [AWS.Config] The global configuration object singleton instance
	 * @readonly
	 * @see AWS.Config
	 */
	AWS.config = new AWS.Config();


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * Represents your AWS security credentials, specifically the
	 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
	 * Creating a `Credentials` object allows you to pass around your
	 * security information to configuration and service objects.
	 *
	 * Note that this class typically does not need to be constructed manually,
	 * as the {AWS.Config} and {AWS.Service} classes both accept simple
	 * options hashes with the three keys. These structures will be converted
	 * into Credentials objects automatically.
	 *
	 * ## Expiring and Refreshing Credentials
	 *
	 * Occasionally credentials can expire in the middle of a long-running
	 * application. In this case, the SDK will automatically attempt to
	 * refresh the credentials from the storage location if the Credentials
	 * class implements the {refresh} method.
	 *
	 * If you are implementing a credential storage location, you
	 * will want to create a subclass of the `Credentials` class and
	 * override the {refresh} method. This method allows credentials to be
	 * retrieved from the backing store, be it a file system, database, or
	 * some network storage. The method should reset the credential attributes
	 * on the object.
	 *
	 * @!attribute expired
	 *   @return [Boolean] whether the credentials have been expired and
	 *     require a refresh. Used in conjunction with {expireTime}.
	 * @!attribute expireTime
	 *   @return [Date] a time when credentials should be considered expired. Used
	 *     in conjunction with {expired}.
	 * @!attribute accessKeyId
	 *   @return [String] the AWS access key ID
	 * @!attribute secretAccessKey
	 *   @return [String] the AWS secret access key
	 * @!attribute sessionToken
	 *   @return [String] an optional AWS session token
	 */
	AWS.Credentials = AWS.util.inherit({
	  /**
	   * A credentials object can be created using positional arguments or an options
	   * hash.
	   *
	   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
	   *   Creates a Credentials object with a given set of credential information
	   *   as positional arguments.
	   *   @param accessKeyId [String] the AWS access key ID
	   *   @param secretAccessKey [String] the AWS secret access key
	   *   @param sessionToken [String] the optional AWS session token
	   *   @example Create a credentials object with AWS credentials
	   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
	   * @overload AWS.Credentials(options)
	   *   Creates a Credentials object with a given set of credential information
	   *   as an options hash.
	   *   @option options accessKeyId [String] the AWS access key ID
	   *   @option options secretAccessKey [String] the AWS secret access key
	   *   @option options sessionToken [String] the optional AWS session token
	   *   @example Create a credentials object with AWS credentials
	   *     var creds = new AWS.Credentials({
	   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
	   *     });
	   */
	  constructor: function Credentials() {
	    // hide secretAccessKey from being displayed with util.inspect
	    AWS.util.hideProperties(this, ['secretAccessKey']);

	    this.expired = false;
	    this.expireTime = null;
	    if (arguments.length === 1 && typeof arguments[0] === 'object') {
	      var creds = arguments[0].credentials || arguments[0];
	      this.accessKeyId = creds.accessKeyId;
	      this.secretAccessKey = creds.secretAccessKey;
	      this.sessionToken = creds.sessionToken;
	    } else {
	      this.accessKeyId = arguments[0];
	      this.secretAccessKey = arguments[1];
	      this.sessionToken = arguments[2];
	    }
	  },

	  /**
	   * @return [Integer] the number of seconds before {expireTime} during which
	   *   the credentials will be considered expired.
	   */
	  expiryWindow: 15,

	  /**
	   * @return [Boolean] whether the credentials object should call {refresh}
	   * @note Subclasses should override this method to provide custom refresh
	   *   logic.
	   */
	  needsRefresh: function needsRefresh() {
	    var currentTime = AWS.util.date.getDate().getTime();
	    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

	    if (this.expireTime && adjustedTime > this.expireTime) {
	      return true;
	    } else {
	      return this.expired || !this.accessKeyId || !this.secretAccessKey;
	    }
	  },

	  /**
	   * Gets the existing credentials, refreshing them if they are not yet loaded
	   * or have expired. Users should call this method before using {refresh},
	   * as this will not attempt to reload credentials when they are already
	   * loaded into the object.
	   *
	   * @callback callback function(err)
	   *   When this callback is called with no error, it means either credentials
	   *   do not need to be refreshed or refreshed credentials information has
	   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
	   *   and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   */
	  get: function get(callback) {
	    var self = this;
	    if (this.needsRefresh()) {
	      this.refresh(function(err) {
	        if (!err) self.expired = false; // reset expired flag
	        if (callback) callback(err);
	      });
	    } else if (callback) {
	      callback();
	    }
	  },

	  /**
	   * @!method  getPromise()
	   *   Returns a 'thenable' promise.
	   *   Gets the existing credentials, refreshing them if they are not yet loaded
	   *   or have expired. Users should call this method before using {refresh},
	   *   as this will not attempt to reload credentials when they are already
	   *   loaded into the object.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function()
	   *     Called if the promise is fulfilled. When this callback is called, it
	   *     means either credentials do not need to be refreshed or refreshed
	   *     credentials information has been loaded into the object (as the
	   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
	   *   @callback rejectedCallback function(err)
	   *     Called if the promise is rejected.
	   *     @param err [Error] if an error occurred, this value will be filled
	   *   @return [Promise] A promise that represents the state of the `get` call.
	   *   @example Calling the `getPromise` method.
	   *     var promise = credProvider.getPromise();
	   *     promise.then(function() { ... }, function(err) { ... });
	   */

	  /**
	   * @!method  refreshPromise()
	   *   Returns a 'thenable' promise.
	   *   Refreshes the credentials. Users should call {get} before attempting
	   *   to forcibly refresh credentials.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function()
	   *     Called if the promise is fulfilled. When this callback is called, it
	   *     means refreshed credentials information has been loaded into the object
	   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
	   *   @callback rejectedCallback function(err)
	   *     Called if the promise is rejected.
	   *     @param err [Error] if an error occurred, this value will be filled
	   *   @return [Promise] A promise that represents the state of the `refresh` call.
	   *   @example Calling the `refreshPromise` method.
	   *     var promise = credProvider.refreshPromise();
	   *     promise.then(function() { ... }, function(err) { ... });
	   */

	  /**
	   * Refreshes the credentials. Users should call {get} before attempting
	   * to forcibly refresh credentials.
	   *
	   * @callback callback function(err)
	   *   When this callback is called with no error, it means refreshed
	   *   credentials information has been loaded into the object (as the
	   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @note Subclasses should override this class to reset the
	   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
	   *   on the credentials object and then call the callback with
	   *   any error information.
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    this.expired = false;
	    callback();
	  }
	});

	/**
	 * @api private
	 */
	AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
	  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
	  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
	};

	/**
	 * @api private
	 */
	AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
	  delete this.prototype.getPromise;
	  delete this.prototype.refreshPromise;
	};

	AWS.util.addPromises(AWS.Credentials);


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * Creates a credential provider chain that searches for AWS credentials
	 * in a list of credential providers specified by the {providers} property.
	 *
	 * By default, the chain will use the {defaultProviders} to resolve credentials.
	 * These providers will look in the environment using the
	 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
	 *
	 * ## Setting Providers
	 *
	 * Each provider in the {providers} list should be a function that returns
	 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
	 * form allows for delayed execution of the credential construction.
	 *
	 * ## Resolving Credentials from a Chain
	 *
	 * Call {resolve} to return the first valid credential object that can be
	 * loaded by the provider chain.
	 *
	 * For example, to resolve a chain with a custom provider that checks a file
	 * on disk after the set of {defaultProviders}:
	 *
	 * ```javascript
	 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
	 * var chain = new AWS.CredentialProviderChain();
	 * chain.providers.push(diskProvider);
	 * chain.resolve();
	 * ```
	 *
	 * The above code will return the `diskProvider` object if the
	 * file contains credentials and the `defaultProviders` do not contain
	 * any credential settings.
	 *
	 * @!attribute providers
	 *   @return [Array<AWS.Credentials, Function>]
	 *     a list of credentials objects or functions that return credentials
	 *     objects. If the provider is a function, the function will be
	 *     executed lazily when the provider needs to be checked for valid
	 *     credentials. By default, this object will be set to the
	 *     {defaultProviders}.
	 *   @see defaultProviders
	 */
	AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

	  /**
	   * Creates a new CredentialProviderChain with a default set of providers
	   * specified by {defaultProviders}.
	   */
	  constructor: function CredentialProviderChain(providers) {
	    if (providers) {
	      this.providers = providers;
	    } else {
	      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
	    }
	  },

	  /**
	   * @!method  resolvePromise()
	   *   Returns a 'thenable' promise.
	   *   Resolves the provider chain by searching for the first set of
	   *   credentials in {providers}.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function(credentials)
	   *     Called if the promise is fulfilled and the provider resolves the chain
	   *     to a credentials object
	   *     @param credentials [AWS.Credentials] the credentials object resolved
	   *       by the provider chain.
	   *   @callback rejectedCallback function(error)
	   *     Called if the promise is rejected.
	   *     @param err [Error] the error object returned if no credentials are found.
	   *   @return [Promise] A promise that represents the state of the `resolve` method call.
	   *   @example Calling the `resolvePromise` method.
	   *     var promise = chain.resolvePromise();
	   *     promise.then(function(credentials) { ... }, function(err) { ... });
	   */

	  /**
	   * Resolves the provider chain by searching for the first set of
	   * credentials in {providers}.
	   *
	   * @callback callback function(err, credentials)
	   *   Called when the provider resolves the chain to a credentials object
	   *   or null if no credentials can be found.
	   *
	   *   @param err [Error] the error object returned if no credentials are
	   *     found.
	   *   @param credentials [AWS.Credentials] the credentials object resolved
	   *     by the provider chain.
	   * @return [AWS.CredentialProviderChain] the provider, for chaining.
	   */
	  resolve: function resolve(callback) {
	    if (this.providers.length === 0) {
	      callback(new Error('No providers'));
	      return this;
	    }

	    var index = 0;
	    var providers = this.providers.slice(0);

	    function resolveNext(err, creds) {
	      if ((!err && creds) || index === providers.length) {
	        callback(err, creds);
	        return;
	      }

	      var provider = providers[index++];
	      if (typeof provider === 'function') {
	        creds = provider.call();
	      } else {
	        creds = provider;
	      }

	      if (creds.get) {
	        creds.get(function(getErr) {
	          resolveNext(getErr, getErr ? null : creds);
	        });
	      } else {
	        resolveNext(null, creds);
	      }
	    }

	    resolveNext();
	    return this;
	  }
	});

	/**
	 * The default set of providers used by a vanilla CredentialProviderChain.
	 *
	 * In the browser:
	 *
	 * ```javascript
	 * AWS.CredentialProviderChain.defaultProviders = []
	 * ```
	 *
	 * In Node.js:
	 *
	 * ```javascript
	 * AWS.CredentialProviderChain.defaultProviders = [
	 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
	 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
	 *   function () { return new AWS.SharedIniFileCredentials(); },
	 *   function () {
	 *     // if AWS_CONTAINER_CREDENTIALS_RELATIVE_URI is set
	 *       return new AWS.ECSCredentials();
	 *     // else
	 *       return new AWS.EC2MetadataCredentials();
	 *   }
	 * ]
	 * ```
	 */
	AWS.CredentialProviderChain.defaultProviders = [];

	/**
	 * @api private
	 */
	AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
	  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
	};

	/**
	 * @api private
	 */
	AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
	  delete this.prototype.resolvePromise;
	};

	AWS.util.addPromises(AWS.CredentialProviderChain);


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;

	/**
	 * The endpoint that a service will talk to, for example,
	 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
	 * you need to override an endpoint for a service, you can
	 * set the endpoint on a service by passing the endpoint
	 * object with the `endpoint` option key:
	 *
	 * ```javascript
	 * var ep = new AWS.Endpoint('awsproxy.example.com');
	 * var s3 = new AWS.S3({endpoint: ep});
	 * s3.service.endpoint.hostname == 'awsproxy.example.com'
	 * ```
	 *
	 * Note that if you do not specify a protocol, the protocol will
	 * be selected based on your current {AWS.config} configuration.
	 *
	 * @!attribute protocol
	 *   @return [String] the protocol (http or https) of the endpoint
	 *     URL
	 * @!attribute hostname
	 *   @return [String] the host portion of the endpoint, e.g.,
	 *     example.com
	 * @!attribute host
	 *   @return [String] the host portion of the endpoint including
	 *     the port, e.g., example.com:80
	 * @!attribute port
	 *   @return [Integer] the port of the endpoint
	 * @!attribute href
	 *   @return [String] the full URL of the endpoint
	 */
	AWS.Endpoint = inherit({

	  /**
	   * @overload Endpoint(endpoint)
	   *   Constructs a new endpoint given an endpoint URL. If the
	   *   URL omits a protocol (http or https), the default protocol
	   *   set in the global {AWS.config} will be used.
	   *   @param endpoint [String] the URL to construct an endpoint from
	   */
	  constructor: function Endpoint(endpoint, config) {
	    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

	    if (typeof endpoint === 'undefined' || endpoint === null) {
	      throw new Error('Invalid endpoint: ' + endpoint);
	    } else if (typeof endpoint !== 'string') {
	      return AWS.util.copy(endpoint);
	    }

	    if (!endpoint.match(/^http/)) {
	      var useSSL = config && config.sslEnabled !== undefined ?
	        config.sslEnabled : AWS.config.sslEnabled;
	      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
	    }

	    AWS.util.update(this, AWS.util.urlParse(endpoint));

	    // Ensure the port property is set as an integer
	    if (this.port) {
	      this.port = parseInt(this.port, 10);
	    } else {
	      this.port = this.protocol === 'https:' ? 443 : 80;
	    }
	  }

	});

	/**
	 * The low level HTTP request object, encapsulating all HTTP header
	 * and body data sent by a service request.
	 *
	 * @!attribute method
	 *   @return [String] the HTTP method of the request
	 * @!attribute path
	 *   @return [String] the path portion of the URI, e.g.,
	 *     "/list/?start=5&num=10"
	 * @!attribute headers
	 *   @return [map<String,String>]
	 *     a map of header keys and their respective values
	 * @!attribute body
	 *   @return [String] the request body payload
	 * @!attribute endpoint
	 *   @return [AWS.Endpoint] the endpoint for the request
	 * @!attribute region
	 *   @api private
	 *   @return [String] the region, for signing purposes only.
	 */
	AWS.HttpRequest = inherit({

	  /**
	   * @api private
	   */
	  constructor: function HttpRequest(endpoint, region) {
	    endpoint = new AWS.Endpoint(endpoint);
	    this.method = 'POST';
	    this.path = endpoint.path || '/';
	    this.headers = {};
	    this.body = '';
	    this.endpoint = endpoint;
	    this.region = region;
	    this._userAgent = '';
	    this.setUserAgent();
	  },

	  /**
	   * @api private
	   */
	  setUserAgent: function setUserAgent() {
	    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
	  },

	  getUserAgentHeaderName: function getUserAgentHeaderName() {
	    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
	    return prefix + 'User-Agent';
	  },

	  /**
	   * @api private
	   */
	  appendToUserAgent: function appendToUserAgent(agentPartial) {
	    if (typeof agentPartial === 'string' && agentPartial) {
	      this._userAgent += ' ' + agentPartial;
	    }
	    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
	  },

	  /**
	   * @api private
	   */
	  getUserAgent: function getUserAgent() {
	    return this._userAgent;
	  },

	  /**
	   * @return [String] the part of the {path} excluding the
	   *   query string
	   */
	  pathname: function pathname() {
	    return this.path.split('?', 1)[0];
	  },

	  /**
	   * @return [String] the query string portion of the {path}
	   */
	  search: function search() {
	    var query = this.path.split('?', 2)[1];
	    if (query) {
	      query = AWS.util.queryStringParse(query);
	      return AWS.util.queryParamsToString(query);
	    }
	    return '';
	  }

	});

	/**
	 * The low level HTTP response object, encapsulating all HTTP header
	 * and body data returned from the request.
	 *
	 * @!attribute statusCode
	 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
	 * @!attribute headers
	 *   @return [map<String,String>]
	 *      a map of response header keys and their respective values
	 * @!attribute body
	 *   @return [String] the response body payload
	 * @!attribute [r] streaming
	 *   @return [Boolean] whether this response is being streamed at a low-level.
	 *     Defaults to `false` (buffered reads). Do not modify this manually, use
	 *     {createUnbufferedStream} to convert the stream to unbuffered mode
	 *     instead.
	 */
	AWS.HttpResponse = inherit({

	  /**
	   * @api private
	   */
	  constructor: function HttpResponse() {
	    this.statusCode = undefined;
	    this.headers = {};
	    this.body = undefined;
	    this.streaming = false;
	    this.stream = null;
	  },

	  /**
	   * Disables buffering on the HTTP response and returns the stream for reading.
	   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
	   *   Use this object to directly read data off of the stream.
	   * @note This object is only available after the {AWS.Request~httpHeaders}
	   *   event has fired. This method must be called prior to
	   *   {AWS.Request~httpData}.
	   * @example Taking control of a stream
	   *   request.on('httpHeaders', function(statusCode, headers) {
	   *     if (statusCode < 300) {
	   *       if (headers.etag === 'xyz') {
	   *         // pipe the stream, disabling buffering
	   *         var stream = this.response.httpResponse.createUnbufferedStream();
	   *         stream.pipe(process.stdout);
	   *       } else { // abort this request and set a better error message
	   *         this.abort();
	   *         this.response.error = new Error('Invalid ETag');
	   *       }
	   *     }
	   *   }).send(console.log);
	   */
	  createUnbufferedStream: function createUnbufferedStream() {
	    this.streaming = true;
	    return this.stream;
	  }
	});


	AWS.HttpClient = inherit({});

	/**
	 * @api private
	 */
	AWS.HttpClient.getInstance = function getInstance() {
	  if (this.singleton === undefined) {
	    this.singleton = new this();
	  }
	  return this.singleton;
	};


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var SequentialExecutor = __webpack_require__(181);
	/**
	 * The namespace used to register global event listeners for request building
	 * and sending.
	 */
	AWS.EventListeners = {
	  /**
	   * @!attribute VALIDATE_CREDENTIALS
	   *   A request listener that validates whether the request is being
	   *   sent with credentials.
	   *   Handles the {AWS.Request~validate 'validate' Request event}
	   *   @example Sending a request without validating credentials
	   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
	   *     request.removeListener('validate', listener);
	   *   @readonly
	   *   @return [Function]
	   * @!attribute VALIDATE_REGION
	   *   A request listener that validates whether the region is set
	   *   for a request.
	   *   Handles the {AWS.Request~validate 'validate' Request event}
	   *   @example Sending a request without validating region configuration
	   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
	   *     request.removeListener('validate', listener);
	   *   @readonly
	   *   @return [Function]
	   * @!attribute VALIDATE_PARAMETERS
	   *   A request listener that validates input parameters in a request.
	   *   Handles the {AWS.Request~validate 'validate' Request event}
	   *   @example Sending a request without validating parameters
	   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
	   *     request.removeListener('validate', listener);
	   *   @example Disable parameter validation globally
	   *     AWS.EventListeners.Core.removeListener('validate',
	   *       AWS.EventListeners.Core.VALIDATE_REGION);
	   *   @readonly
	   *   @return [Function]
	   * @!attribute SEND
	   *   A request listener that initiates the HTTP connection for a
	   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
	   *   @example Replacing the HTTP handler
	   *     var listener = AWS.EventListeners.Core.SEND;
	   *     request.removeListener('send', listener);
	   *     request.on('send', function(response) {
	   *       customHandler.send(response);
	   *     });
	   *   @return [Function]
	   *   @readonly
	   * @!attribute HTTP_DATA
	   *   A request listener that reads data from the HTTP connection in order
	   *   to build the response data.
	   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
	   *   Remove this handler if you are overriding the 'httpData' event and
	   *   do not want extra data processing and buffering overhead.
	   *   @example Disabling default data processing
	   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
	   *     request.removeListener('httpData', listener);
	   *   @return [Function]
	   *   @readonly
	   */
	  Core: {} /* doc hack */
	};

	/**
	 * @api private
	 */
	function getOperationAuthtype(req) {
	  if (!req.service.api.operations) {
	    return '';
	  }
	  var operation = req.service.api.operations[req.operation];
	  return operation ? operation.authtype : '';
	}

	AWS.EventListeners = {
	  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
	    addAsync('VALIDATE_CREDENTIALS', 'validate',
	        function VALIDATE_CREDENTIALS(req, done) {
	      if (!req.service.api.signatureVersion) return done(); // none
	      req.service.config.getCredentials(function(err) {
	        if (err) {
	          req.response.error = AWS.util.error(err,
	            {code: 'CredentialsError', message: 'Missing credentials in config'});
	        }
	        done();
	      });
	    });

	    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
	      if (!req.service.config.region && !req.service.isGlobalEndpoint) {
	        req.response.error = AWS.util.error(new Error(),
	          {code: 'ConfigError', message: 'Missing region in config'});
	      }
	    });

	    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
	      if (!req.service.api.operations) {
	        return;
	      }
	      var operation = req.service.api.operations[req.operation];
	      if (!operation) {
	        return;
	      }
	      var idempotentMembers = operation.idempotentMembers;
	      if (!idempotentMembers.length) {
	        return;
	      }
	      // creates a copy of params so user's param object isn't mutated
	      var params = AWS.util.copy(req.params);
	      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
	        if (!params[idempotentMembers[i]]) {
	          // add the member
	          params[idempotentMembers[i]] = AWS.util.uuid.v4();
	        }
	      }
	      req.params = params;
	    });

	    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
	      if (!req.service.api.operations) {
	        return;
	      }
	      var rules = req.service.api.operations[req.operation].input;
	      var validation = req.service.config.paramValidation;
	      new AWS.ParamValidator(validation).validate(rules, req.params);
	    });

	    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
	      req.haltHandlersOnError();
	      if (!req.service.api.operations) {
	        return;
	      }
	      var operation = req.service.api.operations[req.operation];
	      var authtype = operation ? operation.authtype : '';
	      if (!req.service.api.signatureVersion && !authtype) return done(); // none
	      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
	        var body = req.httpRequest.body || '';
	        if (authtype.indexOf('unsigned-body') >= 0) {
	          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
	          return done();
	        }
	        AWS.util.computeSha256(body, function(err, sha) {
	          if (err) {
	            done(err);
	          }
	          else {
	            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
	            done();
	          }
	        });
	      } else {
	        done();
	      }
	    });

	    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
	      var authtype = getOperationAuthtype(req);
	      if (req.httpRequest.headers['Content-Length'] === undefined) {
	        try {
	          var length = AWS.util.string.byteLength(req.httpRequest.body);
	          req.httpRequest.headers['Content-Length'] = length;
	        } catch (err) {
	          if (authtype.indexOf('unsigned-body') === -1) {
	            throw err;
	          } else {
	            // Body isn't signed and may not need content length (lex)
	            return;
	          }
	        }
	      }
	    });

	    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
	      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
	    });

	    add('RESTART', 'restart', function RESTART() {
	      var err = this.response.error;
	      if (!err || !err.retryable) return;

	      this.httpRequest = new AWS.HttpRequest(
	        this.service.endpoint,
	        this.service.region
	      );

	      if (this.response.retryCount < this.service.config.maxRetries) {
	        this.response.retryCount++;
	      } else {
	        this.response.error = null;
	      }
	    });

	    addAsync('SIGN', 'sign', function SIGN(req, done) {
	      var service = req.service;
	      var operations = req.service.api.operations || {};
	      var operation = operations[req.operation];
	      var authtype = operation ? operation.authtype : '';
	      if (!service.api.signatureVersion && !authtype) return done(); // none

	      service.config.getCredentials(function (err, credentials) {
	        if (err) {
	          req.response.error = err;
	          return done();
	        }

	        try {
	          var date = service.getSkewCorrectedDate();
	          var SignerClass = service.getSignerClass(req);
	          var signer = new SignerClass(req.httpRequest,
	            service.api.signingName || service.api.endpointPrefix,
	            {
	              signatureCache: service.config.signatureCache,
	              operation: operation
	            });
	          signer.setServiceClientId(service._clientId);

	          // clear old authorization headers
	          delete req.httpRequest.headers['Authorization'];
	          delete req.httpRequest.headers['Date'];
	          delete req.httpRequest.headers['X-Amz-Date'];

	          // add new authorization
	          signer.addAuthorization(credentials, date);
	          req.signedAt = date;
	        } catch (e) {
	          req.response.error = e;
	        }
	        done();
	      });
	    });

	    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
	      if (this.service.successfulResponse(resp, this)) {
	        resp.data = {};
	        resp.error = null;
	      } else {
	        resp.data = null;
	        resp.error = AWS.util.error(new Error(),
	          {code: 'UnknownError', message: 'An unknown error occurred.'});
	      }
	    });

	    addAsync('SEND', 'send', function SEND(resp, done) {
	      resp.httpResponse._abortCallback = done;
	      resp.error = null;
	      resp.data = null;

	      function callback(httpResp) {
	        resp.httpResponse.stream = httpResp;
	        var stream = resp.request.httpRequest.stream;
	        var service = resp.request.service;
	        var api = service.api;
	        var operationName = resp.request.operation;
	        var operation = api.operations[operationName] || {};

	        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
	          resp.request.emit(
	            'httpHeaders',
	            [statusCode, headers, resp, statusMessage]
	          );

	          if (!resp.httpResponse.streaming) {
	            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
	              // if we detect event streams, we're going to have to
	              // return the stream immediately
	              if (operation.hasEventOutput && service.successfulResponse(resp)) {
	                // skip reading the IncomingStream
	                resp.request.emit('httpDone');
	                done();
	                return;
	              }

	              httpResp.on('readable', function onReadable() {
	                var data = httpResp.read();
	                if (data !== null) {
	                  resp.request.emit('httpData', [data, resp]);
	                }
	              });
	            } else { // legacy streams API
	              httpResp.on('data', function onData(data) {
	                resp.request.emit('httpData', [data, resp]);
	              });
	            }
	          }
	        });

	        httpResp.on('end', function onEnd() {
	          if (!stream || !stream.didCallback) {
	            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
	              // don't concatenate response chunks when streaming event stream data when response is successful
	              return;
	            }
	            resp.request.emit('httpDone');
	            done();
	          }
	        });
	      }

	      function progress(httpResp) {
	        httpResp.on('sendProgress', function onSendProgress(value) {
	          resp.request.emit('httpUploadProgress', [value, resp]);
	        });

	        httpResp.on('receiveProgress', function onReceiveProgress(value) {
	          resp.request.emit('httpDownloadProgress', [value, resp]);
	        });
	      }

	      function error(err) {
	        if (err.code !== 'RequestAbortedError') {
	          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
	          err = AWS.util.error(err, {
	            code: errCode,
	            region: resp.request.httpRequest.region,
	            hostname: resp.request.httpRequest.endpoint.hostname,
	            retryable: true
	          });
	        }
	        resp.error = err;
	        resp.request.emit('httpError', [resp.error, resp], function() {
	          done();
	        });
	      }

	      function executeSend() {
	        var http = AWS.HttpClient.getInstance();
	        var httpOptions = resp.request.service.config.httpOptions || {};
	        try {
	          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
	                                          callback, error);
	          progress(stream);
	        } catch (err) {
	          error(err);
	        }
	      }
	      var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;
	      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
	        this.emit('sign', [this], function(err) {
	          if (err) done(err);
	          else executeSend();
	        });
	      } else {
	        executeSend();
	      }
	    });

	    add('HTTP_HEADERS', 'httpHeaders',
	        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
	      resp.httpResponse.statusCode = statusCode;
	      resp.httpResponse.statusMessage = statusMessage;
	      resp.httpResponse.headers = headers;
	      resp.httpResponse.body = new AWS.util.Buffer('');
	      resp.httpResponse.buffers = [];
	      resp.httpResponse.numBytes = 0;
	      var dateHeader = headers.date || headers.Date;
	      var service = resp.request.service;
	      if (dateHeader) {
	        var serverTime = Date.parse(dateHeader);
	        if (service.config.correctClockSkew
	            && service.isClockSkewed(serverTime)) {
	          service.applyClockOffset(serverTime);
	        }
	      }
	    });

	    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
	      if (chunk) {
	        if (AWS.util.isNode()) {
	          resp.httpResponse.numBytes += chunk.length;

	          var total = resp.httpResponse.headers['content-length'];
	          var progress = { loaded: resp.httpResponse.numBytes, total: total };
	          resp.request.emit('httpDownloadProgress', [progress, resp]);
	        }

	        resp.httpResponse.buffers.push(new AWS.util.Buffer(chunk));
	      }
	    });

	    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
	      // convert buffers array into single buffer
	      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
	        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
	        resp.httpResponse.body = body;
	      }
	      delete resp.httpResponse.numBytes;
	      delete resp.httpResponse.buffers;
	    });

	    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
	      if (resp.httpResponse.statusCode) {
	        resp.error.statusCode = resp.httpResponse.statusCode;
	        if (resp.error.retryable === undefined) {
	          resp.error.retryable = this.service.retryableError(resp.error, this);
	        }
	      }
	    });

	    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
	      if (!resp.error) return;
	      switch (resp.error.code) {
	        case 'RequestExpired': // EC2 only
	        case 'ExpiredTokenException':
	        case 'ExpiredToken':
	          resp.error.retryable = true;
	          resp.request.service.config.credentials.expired = true;
	      }
	    });

	    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
	      var err = resp.error;
	      if (!err) return;
	      if (typeof err.code === 'string' && typeof err.message === 'string') {
	        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
	          resp.error.retryable = true;
	        }
	      }
	    });

	    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
	      if (!resp.error) return;
	      if (this.service.clockSkewError(resp.error)
	          && this.service.config.correctClockSkew) {
	        resp.error.retryable = true;
	      }
	    });

	    add('REDIRECT', 'retry', function REDIRECT(resp) {
	      if (resp.error && resp.error.statusCode >= 300 &&
	          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
	        this.httpRequest.endpoint =
	          new AWS.Endpoint(resp.httpResponse.headers['location']);
	        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
	        resp.error.redirect = true;
	        resp.error.retryable = true;
	      }
	    });

	    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
	      if (resp.error) {
	        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
	          resp.error.retryDelay = 0;
	        } else if (resp.retryCount < resp.maxRetries) {
	          resp.error.retryDelay = this.service.retryDelays(resp.retryCount) || 0;
	        }
	      }
	    });

	    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
	      var delay, willRetry = false;

	      if (resp.error) {
	        delay = resp.error.retryDelay || 0;
	        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
	          resp.retryCount++;
	          willRetry = true;
	        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
	          resp.redirectCount++;
	          willRetry = true;
	        }
	      }

	      if (willRetry) {
	        resp.error = null;
	        setTimeout(done, delay);
	      } else {
	        done();
	      }
	    });
	  }),

	  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
	    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
	    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

	    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
	      if (err.code === 'NetworkingError' && err.errno === 'ENOTFOUND') {
	        var message = 'Inaccessible host: `' + err.hostname +
	          '\'. This service may not be available in the `' + err.region +
	          '\' region.';
	        this.response.error = AWS.util.error(new Error(message), {
	          code: 'UnknownEndpoint',
	          region: err.region,
	          hostname: err.hostname,
	          retryable: true,
	          originalError: err
	        });
	      }
	    });
	  }),

	  Logger: new SequentialExecutor().addNamedListeners(function(add) {
	    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
	      var req = resp.request;
	      var logger = req.service.config.logger;
	      if (!logger) return;
	      function filterSensitiveLog(inputShape, shape) {
	        if (!shape) {
	          return shape;
	        }
	        switch (inputShape.type) {
	          case 'structure':
	            var struct = {};
	            AWS.util.each(shape, function(subShapeName, subShape) {
	              if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
	                struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
	              } else {
	                struct[subShapeName] = subShape;
	              }
	            })
	            return struct
	          case 'list':
	            var list = [];
	            AWS.util.arrayEach(shape, function(subShape, index) {
	              list.push(filterSensitiveLog(inputShape.member, subShape));
	            })
	            return list;
	          case 'map':
	            var map = {};
	            AWS.util.each(shape, function(key, value) {
	              map[key] = filterSensitiveLog(inputShape.value, value);
	            })
	            return map;
	          default:
	            if (inputShape.isSensitive) {
	              return '***SensitiveInformation***'
	            } else {
	              return shape;
	            }
	        }
	      }

	      function buildMessage() {
	        var time = resp.request.service.getSkewCorrectedDate().getTime();
	        var delta = (time - req.startTime.getTime()) / 1000;
	        var ansi = logger.isTTY ? true : false;
	        var status = resp.httpResponse.statusCode;
	        var censoredParams = req.params;
	        if (
	          req.service.api.operations &&
	              req.service.api.operations[req.operation] &&
	              req.service.api.operations[req.operation].input
	        ) {
	          var inputShape = req.service.api.operations[req.operation].input;
	          censoredParams = filterSensitiveLog(inputShape, req.params);
	        }
	        var params = __webpack_require__(190).inspect(censoredParams, true, null);
	        var message = '';
	        if (ansi) message += '\x1B[33m';
	        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
	        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
	        if (ansi) message += '\x1B[0;1m';
	        message += ' ' + AWS.util.string.lowerFirst(req.operation);
	        message += '(' + params + ')';
	        if (ansi) message += '\x1B[0m';
	        return message;
	      }

	      var line = buildMessage();
	      if (typeof logger.log === 'function') {
	        logger.log(line);
	      } else if (typeof logger.write === 'function') {
	        logger.write(line + '\n');
	      }
	    });
	  }),

	  Json: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(161);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  Rest: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(168);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(169);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(170);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  }),

	  Query: new SequentialExecutor().addNamedListeners(function(add) {
	    var svc = __webpack_require__(164);
	    add('BUILD', 'build', svc.buildRequest);
	    add('EXTRACT_DATA', 'extractData', svc.extractData);
	    add('EXTRACT_ERROR', 'extractError', svc.extractError);
	  })
	};


/***/ }),
/* 190 */
/***/ (function(module, exports) {

	module.exports = require("util");

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var AcceptorStateMachine = __webpack_require__(192);
	var inherit = AWS.util.inherit;
	var domain = AWS.util.domain;
	var jmespath = __webpack_require__(193);

	/**
	 * @api private
	 */
	var hardErrorStates = {success: 1, error: 1, complete: 1};

	function isTerminalState(machine) {
	  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
	}

	var fsm = new AcceptorStateMachine();
	fsm.setupStates = function() {
	  var transition = function(_, done) {
	    var self = this;
	    self._haltHandlersOnError = false;

	    self.emit(self._asm.currentState, function(err) {
	      if (err) {
	        if (isTerminalState(self)) {
	          if (domain && self.domain instanceof domain.Domain) {
	            err.domainEmitter = self;
	            err.domain = self.domain;
	            err.domainThrown = false;
	            self.domain.emit('error', err);
	          } else {
	            throw err;
	          }
	        } else {
	          self.response.error = err;
	          done(err);
	        }
	      } else {
	        done(self.response.error);
	      }
	    });

	  };

	  this.addState('validate', 'build', 'error', transition);
	  this.addState('build', 'afterBuild', 'restart', transition);
	  this.addState('afterBuild', 'sign', 'restart', transition);
	  this.addState('sign', 'send', 'retry', transition);
	  this.addState('retry', 'afterRetry', 'afterRetry', transition);
	  this.addState('afterRetry', 'sign', 'error', transition);
	  this.addState('send', 'validateResponse', 'retry', transition);
	  this.addState('validateResponse', 'extractData', 'extractError', transition);
	  this.addState('extractError', 'extractData', 'retry', transition);
	  this.addState('extractData', 'success', 'retry', transition);
	  this.addState('restart', 'build', 'error', transition);
	  this.addState('success', 'complete', 'complete', transition);
	  this.addState('error', 'complete', 'complete', transition);
	  this.addState('complete', null, null, transition);
	};
	fsm.setupStates();

	/**
	 * ## Asynchronous Requests
	 *
	 * All requests made through the SDK are asynchronous and use a
	 * callback interface. Each service method that kicks off a request
	 * returns an `AWS.Request` object that you can use to register
	 * callbacks.
	 *
	 * For example, the following service method returns the request
	 * object as "request", which can be used to register callbacks:
	 *
	 * ```javascript
	 * // request is an AWS.Request object
	 * var request = ec2.describeInstances();
	 *
	 * // register callbacks on request to retrieve response data
	 * request.on('success', function(response) {
	 *   console.log(response.data);
	 * });
	 * ```
	 *
	 * When a request is ready to be sent, the {send} method should
	 * be called:
	 *
	 * ```javascript
	 * request.send();
	 * ```
	 *
	 * Since registered callbacks may or may not be idempotent, requests should only
	 * be sent once. To perform the same operation multiple times, you will need to
	 * create multiple request objects, each with its own registered callbacks.
	 *
	 * ## Removing Default Listeners for Events
	 *
	 * Request objects are built with default listeners for the various events,
	 * depending on the service type. In some cases, you may want to remove
	 * some built-in listeners to customize behaviour. Doing this requires
	 * access to the built-in listener functions, which are exposed through
	 * the {AWS.EventListeners.Core} namespace. For instance, you may
	 * want to customize the HTTP handler used when sending a request. In this
	 * case, you can remove the built-in listener associated with the 'send'
	 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
	 *
	 * ## Multiple Callbacks and Chaining
	 *
	 * You can register multiple callbacks on any request object. The
	 * callbacks can be registered for different events, or all for the
	 * same event. In addition, you can chain callback registration, for
	 * example:
	 *
	 * ```javascript
	 * request.
	 *   on('success', function(response) {
	 *     console.log("Success!");
	 *   }).
	 *   on('error', function(response) {
	 *     console.log("Error!");
	 *   }).
	 *   on('complete', function(response) {
	 *     console.log("Always!");
	 *   }).
	 *   send();
	 * ```
	 *
	 * The above example will print either "Success! Always!", or "Error! Always!",
	 * depending on whether the request succeeded or not.
	 *
	 * @!attribute httpRequest
	 *   @readonly
	 *   @!group HTTP Properties
	 *   @return [AWS.HttpRequest] the raw HTTP request object
	 *     containing request headers and body information
	 *     sent by the service.
	 *
	 * @!attribute startTime
	 *   @readonly
	 *   @!group Operation Properties
	 *   @return [Date] the time that the request started
	 *
	 * @!group Request Building Events
	 *
	 * @!event validate(request)
	 *   Triggered when a request is being validated. Listeners
	 *   should throw an error if the request should not be sent.
	 *   @param request [Request] the request object being sent
	 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
	 *   @see AWS.EventListeners.Core.VALIDATE_REGION
	 *   @example Ensuring that a certain parameter is set before sending a request
	 *     var req = s3.putObject(params);
	 *     req.on('validate', function() {
	 *       if (!req.params.Body.match(/^Hello\s/)) {
	 *         throw new Error('Body must start with "Hello "');
	 *       }
	 *     });
	 *     req.send(function(err, data) { ... });
	 *
	 * @!event build(request)
	 *   Triggered when the request payload is being built. Listeners
	 *   should fill the necessary information to send the request
	 *   over HTTP.
	 *   @param (see AWS.Request~validate)
	 *   @example Add a custom HTTP header to a request
	 *     var req = s3.putObject(params);
	 *     req.on('build', function() {
	 *       req.httpRequest.headers['Custom-Header'] = 'value';
	 *     });
	 *     req.send(function(err, data) { ... });
	 *
	 * @!event sign(request)
	 *   Triggered when the request is being signed. Listeners should
	 *   add the correct authentication headers and/or adjust the body,
	 *   depending on the authentication mechanism being used.
	 *   @param (see AWS.Request~validate)
	 *
	 * @!group Request Sending Events
	 *
	 * @!event send(response)
	 *   Triggered when the request is ready to be sent. Listeners
	 *   should call the underlying transport layer to initiate
	 *   the sending of the request.
	 *   @param response [Response] the response object
	 *   @context [Request] the request object that was sent
	 *   @see AWS.EventListeners.Core.SEND
	 *
	 * @!event retry(response)
	 *   Triggered when a request failed and might need to be retried or redirected.
	 *   If the response is retryable, the listener should set the
	 *   `response.error.retryable` property to `true`, and optionally set
	 *   `response.error.retryDelay` to the millisecond delay for the next attempt.
	 *   In the case of a redirect, `response.error.redirect` should be set to
	 *   `true` with `retryDelay` set to an optional delay on the next request.
	 *
	 *   If a listener decides that a request should not be retried,
	 *   it should set both `retryable` and `redirect` to false.
	 *
	 *   Note that a retryable error will be retried at most
	 *   {AWS.Config.maxRetries} times (based on the service object's config).
	 *   Similarly, a request that is redirected will only redirect at most
	 *   {AWS.Config.maxRedirects} times.
	 *
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @example Adding a custom retry for a 404 response
	 *     request.on('retry', function(response) {
	 *       // this resource is not yet available, wait 10 seconds to get it again
	 *       if (response.httpResponse.statusCode === 404 && response.error) {
	 *         response.error.retryable = true;   // retry this error
	 *         response.error.retryDelay = 10000; // wait 10 seconds
	 *       }
	 *     });
	 *
	 * @!group Data Parsing Events
	 *
	 * @!event extractError(response)
	 *   Triggered on all non-2xx requests so that listeners can extract
	 *   error details from the response body. Listeners to this event
	 *   should set the `response.error` property.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event extractData(response)
	 *   Triggered in successful requests to allow listeners to
	 *   de-serialize the response body into `response.data`.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!group Completion Events
	 *
	 * @!event success(response)
	 *   Triggered when the request completed successfully.
	 *   `response.data` will contain the response data and
	 *   `response.error` will be null.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event error(error, response)
	 *   Triggered when an error occurs at any point during the
	 *   request. `response.error` will contain details about the error
	 *   that occurred. `response.data` will be null.
	 *   @param error [Error] the error object containing details about
	 *     the error that occurred.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event complete(response)
	 *   Triggered whenever a request cycle completes. `response.error`
	 *   should be checked, since the request may have failed.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!group HTTP Events
	 *
	 * @!event httpHeaders(statusCode, headers, response, statusMessage)
	 *   Triggered when headers are sent by the remote server
	 *   @param statusCode [Integer] the HTTP response code
	 *   @param headers [map<String,String>] the response headers
	 *   @param (see AWS.Request~send)
	 *   @param statusMessage [String] A status message corresponding to the HTTP
	 *                                 response code
	 *   @context (see AWS.Request~send)
	 *
	 * @!event httpData(chunk, response)
	 *   Triggered when data is sent by the remote server
	 *   @param chunk [Buffer] the buffer data containing the next data chunk
	 *     from the server
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @see AWS.EventListeners.Core.HTTP_DATA
	 *
	 * @!event httpUploadProgress(progress, response)
	 *   Triggered when the HTTP request has uploaded more data
	 *   @param progress [map] An object containing the `loaded` and `total` bytes
	 *     of the request.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @note This event will not be emitted in Node.js 0.8.x.
	 *
	 * @!event httpDownloadProgress(progress, response)
	 *   Triggered when the HTTP request has downloaded more data
	 *   @param progress [map] An object containing the `loaded` and `total` bytes
	 *     of the request.
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *   @note This event will not be emitted in Node.js 0.8.x.
	 *
	 * @!event httpError(error, response)
	 *   Triggered when the HTTP request failed
	 *   @param error [Error] the error object that was thrown
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @!event httpDone(response)
	 *   Triggered when the server is finished sending data
	 *   @param (see AWS.Request~send)
	 *   @context (see AWS.Request~send)
	 *
	 * @see AWS.Response
	 */
	AWS.Request = inherit({

	  /**
	   * Creates a request for an operation on a given service with
	   * a set of input parameters.
	   *
	   * @param service [AWS.Service] the service to perform the operation on
	   * @param operation [String] the operation to perform on the service
	   * @param params [Object] parameters to send to the operation.
	   *   See the operation's documentation for the format of the
	   *   parameters.
	   */
	  constructor: function Request(service, operation, params) {
	    var endpoint = service.endpoint;
	    var region = service.config.region;
	    var customUserAgent = service.config.customUserAgent;

	    // global endpoints sign as us-east-1
	    if (service.isGlobalEndpoint) region = 'us-east-1';

	    this.domain = domain && domain.active;
	    this.service = service;
	    this.operation = operation;
	    this.params = params || {};
	    this.httpRequest = new AWS.HttpRequest(endpoint, region);
	    this.httpRequest.appendToUserAgent(customUserAgent);
	    this.startTime = service.getSkewCorrectedDate();

	    this.response = new AWS.Response(this);
	    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
	    this._haltHandlersOnError = false;

	    AWS.SequentialExecutor.call(this);
	    this.emit = this.emitEvent;
	  },

	  /**
	   * @!group Sending a Request
	   */

	  /**
	   * @overload send(callback = null)
	   *   Sends the request object.
	   *
	   *   @callback callback function(err, data)
	   *     If a callback is supplied, it is called when a response is returned
	   *     from the service.
	   *     @context [AWS.Request] the request object being sent.
	   *     @param err [Error] the error object returned from the request.
	   *       Set to `null` if the request is successful.
	   *     @param data [Object] the de-serialized data returned from
	   *       the request. Set to `null` if a request error occurs.
	   *   @example Sending a request with a callback
	   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
	   *     request.send(function(err, data) { console.log(err, data); });
	   *   @example Sending a request with no callback (using event handlers)
	   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
	   *     request.on('complete', function(response) { ... }); // register a callback
	   *     request.send();
	   */
	  send: function send(callback) {
	    if (callback) {
	      // append to user agent
	      this.httpRequest.appendToUserAgent('callback');
	      this.on('complete', function (resp) {
	        callback.call(resp, resp.error, resp.data);
	      });
	    }
	    this.runTo();

	    return this.response;
	  },

	  /**
	   * @!method  promise()
	   *   Sends the request and returns a 'thenable' promise.
	   *
	   *   Two callbacks can be provided to the `then` method on the returned promise.
	   *   The first callback will be called if the promise is fulfilled, and the second
	   *   callback will be called if the promise is rejected.
	   *   @callback fulfilledCallback function(data)
	   *     Called if the promise is fulfilled.
	   *     @param data [Object] the de-serialized data returned from the request.
	   *   @callback rejectedCallback function(error)
	   *     Called if the promise is rejected.
	   *     @param error [Error] the error object returned from the request.
	   *   @return [Promise] A promise that represents the state of the request.
	   *   @example Sending a request using promises.
	   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
	   *     var result = request.promise();
	   *     result.then(function(data) { ... }, function(error) { ... });
	   */

	  /**
	   * @api private
	   */
	  build: function build(callback) {
	    return this.runTo('send', callback);
	  },

	  /**
	   * @api private
	   */
	  runTo: function runTo(state, done) {
	    this._asm.runTo(state, done, this);
	    return this;
	  },

	  /**
	   * Aborts a request, emitting the error and complete events.
	   *
	   * @!macro nobrowser
	   * @example Aborting a request after sending
	   *   var params = {
	   *     Bucket: 'bucket', Key: 'key',
	   *     Body: new Buffer(1024 * 1024 * 5) // 5MB payload
	   *   };
	   *   var request = s3.putObject(params);
	   *   request.send(function (err, data) {
	   *     if (err) console.log("Error:", err.code, err.message);
	   *     else console.log(data);
	   *   });
	   *
	   *   // abort request in 1 second
	   *   setTimeout(request.abort.bind(request), 1000);
	   *
	   *   // prints "Error: RequestAbortedError Request aborted by user"
	   * @return [AWS.Request] the same request object, for chaining.
	   * @since v1.4.0
	   */
	  abort: function abort() {
	    this.removeAllListeners('validateResponse');
	    this.removeAllListeners('extractError');
	    this.on('validateResponse', function addAbortedError(resp) {
	      resp.error = AWS.util.error(new Error('Request aborted by user'), {
	         code: 'RequestAbortedError', retryable: false
	      });
	    });

	    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream
	      this.httpRequest.stream.abort();
	      if (this.httpRequest._abortCallback) {
	         this.httpRequest._abortCallback();
	      } else {
	        this.removeAllListeners('send'); // haven't sent yet, so let's not
	      }
	    }

	    return this;
	  },

	  /**
	   * Iterates over each page of results given a pageable request, calling
	   * the provided callback with each page of data. After all pages have been
	   * retrieved, the callback is called with `null` data.
	   *
	   * @note This operation can generate multiple requests to a service.
	   * @example Iterating over multiple pages of objects in an S3 bucket
	   *   var pages = 1;
	   *   s3.listObjects().eachPage(function(err, data) {
	   *     if (err) return;
	   *     console.log("Page", pages++);
	   *     console.log(data);
	   *   });
	   * @example Iterating over multiple pages with an asynchronous callback
	   *   s3.listObjects(params).eachPage(function(err, data, done) {
	   *     doSomethingAsyncAndOrExpensive(function() {
	   *       // The next page of results isn't fetched until done is called
	   *       done();
	   *     });
	   *   });
	   * @callback callback function(err, data, [doneCallback])
	   *   Called with each page of resulting data from the request. If the
	   *   optional `doneCallback` is provided in the function, it must be called
	   *   when the callback is complete.
	   *
	   *   @param err [Error] an error object, if an error occurred.
	   *   @param data [Object] a single page of response data. If there is no
	   *     more data, this object will be `null`.
	   *   @param doneCallback [Function] an optional done callback. If this
	   *     argument is defined in the function declaration, it should be called
	   *     when the next page is ready to be retrieved. This is useful for
	   *     controlling serial pagination across asynchronous operations.
	   *   @return [Boolean] if the callback returns `false`, pagination will
	   *     stop.
	   *
	   * @see AWS.Request.eachItem
	   * @see AWS.Response.nextPage
	   * @since v1.4.0
	   */
	  eachPage: function eachPage(callback) {
	    // Make all callbacks async-ish
	    callback = AWS.util.fn.makeAsync(callback, 3);

	    function wrappedCallback(response) {
	      callback.call(response, response.error, response.data, function (result) {
	        if (result === false) return;

	        if (response.hasNextPage()) {
	          response.nextPage().on('complete', wrappedCallback).send();
	        } else {
	          callback.call(response, null, null, AWS.util.fn.noop);
	        }
	      });
	    }

	    this.on('complete', wrappedCallback).send();
	  },

	  /**
	   * Enumerates over individual items of a request, paging the responses if
	   * necessary.
	   *
	   * @api experimental
	   * @since v1.4.0
	   */
	  eachItem: function eachItem(callback) {
	    var self = this;
	    function wrappedCallback(err, data) {
	      if (err) return callback(err, null);
	      if (data === null) return callback(null, null);

	      var config = self.service.paginationConfig(self.operation);
	      var resultKey = config.resultKey;
	      if (Array.isArray(resultKey)) resultKey = resultKey[0];
	      var items = jmespath.search(data, resultKey);
	      var continueIteration = true;
	      AWS.util.arrayEach(items, function(item) {
	        continueIteration = callback(null, item);
	        if (continueIteration === false) {
	          return AWS.util.abort;
	        }
	      });
	      return continueIteration;
	    }

	    this.eachPage(wrappedCallback);
	  },

	  /**
	   * @return [Boolean] whether the operation can return multiple pages of
	   *   response data.
	   * @see AWS.Response.eachPage
	   * @since v1.4.0
	   */
	  isPageable: function isPageable() {
	    return this.service.paginationConfig(this.operation) ? true : false;
	  },

	  /**
	   * Sends the request and converts the request object into a readable stream
	   * that can be read from or piped into a writable stream.
	   *
	   * @note The data read from a readable stream contains only
	   *   the raw HTTP body contents.
	   * @example Manually reading from a stream
	   *   request.createReadStream().on('data', function(data) {
	   *     console.log("Got data:", data.toString());
	   *   });
	   * @example Piping a request body into a file
	   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
	   *   s3.service.getObject(params).createReadStream().pipe(out);
	   * @return [Stream] the readable stream object that can be piped
	   *   or read from (by registering 'data' event listeners).
	   * @!macro nobrowser
	   */
	  createReadStream: function createReadStream() {
	    var streams = AWS.util.stream;
	    var req = this;
	    var stream = null;

	    if (AWS.HttpClient.streamsApiVersion === 2) {
	      stream = new streams.PassThrough();
	      process.nextTick(function() { req.send(); });
	    } else {
	      stream = new streams.Stream();
	      stream.readable = true;

	      stream.sent = false;
	      stream.on('newListener', function(event) {
	        if (!stream.sent && event === 'data') {
	          stream.sent = true;
	          process.nextTick(function() { req.send(); });
	        }
	      });
	    }

	    this.on('error', function(err) {
	      stream.emit('error', err);
	    });

	    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
	      if (statusCode < 300) {
	        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
	        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
	        req.on('httpError', function streamHttpError(error) {
	          resp.error = error;
	          resp.error.retryable = false;
	        });

	        var shouldCheckContentLength = false;
	        var expectedLen;
	        if (req.httpRequest.method !== 'HEAD') {
	          expectedLen = parseInt(headers['content-length'], 10);
	        }
	        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
	          shouldCheckContentLength = true;
	          var receivedLen = 0;
	        }

	        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
	          if (shouldCheckContentLength && receivedLen !== expectedLen) {
	            stream.emit('error', AWS.util.error(
	              new Error('Stream content length mismatch. Received ' +
	                receivedLen + ' of ' + expectedLen + ' bytes.'),
	              { code: 'StreamContentLengthMismatch' }
	            ));
	          } else if (AWS.HttpClient.streamsApiVersion === 2) {
	            stream.end();
	          } else {
	            stream.emit('end');
	          }
	        };

	        var httpStream = resp.httpResponse.createUnbufferedStream();

	        if (AWS.HttpClient.streamsApiVersion === 2) {
	          if (shouldCheckContentLength) {
	            var lengthAccumulator = new streams.PassThrough();
	            lengthAccumulator._write = function(chunk) {
	              if (chunk && chunk.length) {
	                receivedLen += chunk.length;
	              }
	              return streams.PassThrough.prototype._write.apply(this, arguments);
	            };

	            lengthAccumulator.on('end', checkContentLengthAndEmit);
	            stream.on('error', function(err) {
	              shouldCheckContentLength = false;
	              httpStream.unpipe(lengthAccumulator);
	              lengthAccumulator.emit('end');
	              lengthAccumulator.end();
	            });
	            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
	          } else {
	            httpStream.pipe(stream);
	          }
	        } else {

	          if (shouldCheckContentLength) {
	            httpStream.on('data', function(arg) {
	              if (arg && arg.length) {
	                receivedLen += arg.length;
	              }
	            });
	          }

	          httpStream.on('data', function(arg) {
	            stream.emit('data', arg);
	          });
	          httpStream.on('end', checkContentLengthAndEmit);
	        }

	        httpStream.on('error', function(err) {
	          shouldCheckContentLength = false;
	          stream.emit('error', err);
	        });
	      }
	    });

	    return stream;
	  },

	  /**
	   * @param [Array,Response] args This should be the response object,
	   *   or an array of args to send to the event.
	   * @api private
	   */
	  emitEvent: function emit(eventName, args, done) {
	    if (typeof args === 'function') { done = args; args = null; }
	    if (!done) done = function() { };
	    if (!args) args = this.eventParameters(eventName, this.response);

	    var origEmit = AWS.SequentialExecutor.prototype.emit;
	    origEmit.call(this, eventName, args, function (err) {
	      if (err) this.response.error = err;
	      done.call(this, err);
	    });
	  },

	  /**
	   * @api private
	   */
	  eventParameters: function eventParameters(eventName) {
	    switch (eventName) {
	      case 'restart':
	      case 'validate':
	      case 'sign':
	      case 'build':
	      case 'afterValidate':
	      case 'afterBuild':
	        return [this];
	      case 'error':
	        return [this.response.error, this.response];
	      default:
	        return [this.response];
	    }
	  },

	  /**
	   * @api private
	   */
	  presign: function presign(expires, callback) {
	    if (!callback && typeof expires === 'function') {
	      callback = expires;
	      expires = null;
	    }
	    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
	  },

	  /**
	   * @api private
	   */
	  isPresigned: function isPresigned() {
	    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
	  },

	  /**
	   * @api private
	   */
	  toUnauthenticated: function toUnauthenticated() {
	    this._unAuthenticated = true;
	    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
	    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
	    return this;
	  },

	  /**
	   * @api private
	   */
	  toGet: function toGet() {
	    if (this.service.api.protocol === 'query' ||
	        this.service.api.protocol === 'ec2') {
	      this.removeListener('build', this.buildAsGet);
	      this.addListener('build', this.buildAsGet);
	    }
	    return this;
	  },

	  /**
	   * @api private
	   */
	  buildAsGet: function buildAsGet(request) {
	    request.httpRequest.method = 'GET';
	    request.httpRequest.path = request.service.endpoint.path +
	                               '?' + request.httpRequest.body;
	    request.httpRequest.body = '';

	    // don't need these headers on a GET request
	    delete request.httpRequest.headers['Content-Length'];
	    delete request.httpRequest.headers['Content-Type'];
	  },

	  /**
	   * @api private
	   */
	  haltHandlersOnError: function haltHandlersOnError() {
	    this._haltHandlersOnError = true;
	  }
	});

	/**
	 * @api private
	 */
	AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
	  this.prototype.promise = function promise() {
	    var self = this;
	    // append to user agent
	    this.httpRequest.appendToUserAgent('promise');
	    return new PromiseDependency(function(resolve, reject) {
	      self.on('complete', function(resp) {
	        if (resp.error) {
	          reject(resp.error);
	        } else {
	          // define $response property so that it is not enumberable
	          // this prevents circular reference errors when stringifying the JSON object
	          resolve(Object.defineProperty(
	            resp.data || {},
	            '$response',
	            {value: resp}
	          ));
	        }
	      });
	      self.runTo();
	    });
	  };
	};

	/**
	 * @api private
	 */
	AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
	  delete this.prototype.promise;
	};

	AWS.util.addPromises(AWS.Request);

	AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);


/***/ }),
/* 192 */
/***/ (function(module, exports) {

	function AcceptorStateMachine(states, state) {
	  this.currentState = state || null;
	  this.states = states || {};
	}

	AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
	  if (typeof finalState === 'function') {
	    inputError = bindObject; bindObject = done;
	    done = finalState; finalState = null;
	  }

	  var self = this;
	  var state = self.states[self.currentState];
	  state.fn.call(bindObject || self, inputError, function(err) {
	    if (err) {
	      if (state.fail) self.currentState = state.fail;
	      else return done ? done.call(bindObject, err) : null;
	    } else {
	      if (state.accept) self.currentState = state.accept;
	      else return done ? done.call(bindObject) : null;
	    }
	    if (self.currentState === finalState) {
	      return done ? done.call(bindObject, err) : null;
	    }

	    self.runTo(finalState, done, bindObject, err);
	  });
	};

	AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
	  if (typeof acceptState === 'function') {
	    fn = acceptState; acceptState = null; failState = null;
	  } else if (typeof failState === 'function') {
	    fn = failState; failState = null;
	  }

	  if (!this.currentState) this.currentState = name;
	  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
	  return this;
	};

	/**
	 * @api private
	 */
	module.exports = AcceptorStateMachine;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	(function(exports) {
	  "use strict";

	  function isArray(obj) {
	    if (obj !== null) {
	      return Object.prototype.toString.call(obj) === "[object Array]";
	    } else {
	      return false;
	    }
	  }

	  function isObject(obj) {
	    if (obj !== null) {
	      return Object.prototype.toString.call(obj) === "[object Object]";
	    } else {
	      return false;
	    }
	  }

	  function strictDeepEqual(first, second) {
	    // Check the scalar case first.
	    if (first === second) {
	      return true;
	    }

	    // Check if they are the same type.
	    var firstType = Object.prototype.toString.call(first);
	    if (firstType !== Object.prototype.toString.call(second)) {
	      return false;
	    }
	    // We know that first and second have the same type so we can just check the
	    // first type from now on.
	    if (isArray(first) === true) {
	      // Short circuit if they're not the same length;
	      if (first.length !== second.length) {
	        return false;
	      }
	      for (var i = 0; i < first.length; i++) {
	        if (strictDeepEqual(first[i], second[i]) === false) {
	          return false;
	        }
	      }
	      return true;
	    }
	    if (isObject(first) === true) {
	      // An object is equal if it has the same key/value pairs.
	      var keysSeen = {};
	      for (var key in first) {
	        if (hasOwnProperty.call(first, key)) {
	          if (strictDeepEqual(first[key], second[key]) === false) {
	            return false;
	          }
	          keysSeen[key] = true;
	        }
	      }
	      // Now check that there aren't any keys in second that weren't
	      // in first.
	      for (var key2 in second) {
	        if (hasOwnProperty.call(second, key2)) {
	          if (keysSeen[key2] !== true) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	    return false;
	  }

	  function isFalse(obj) {
	    // From the spec:
	    // A false value corresponds to the following values:
	    // Empty list
	    // Empty object
	    // Empty string
	    // False boolean
	    // null value

	    // First check the scalar values.
	    if (obj === "" || obj === false || obj === null) {
	        return true;
	    } else if (isArray(obj) && obj.length === 0) {
	        // Check for an empty array.
	        return true;
	    } else if (isObject(obj)) {
	        // Check for an empty object.
	        for (var key in obj) {
	            // If there are any keys, then
	            // the object is not empty so the object
	            // is not false.
	            if (obj.hasOwnProperty(key)) {
	              return false;
	            }
	        }
	        return true;
	    } else {
	        return false;
	    }
	  }

	  function objValues(obj) {
	    var keys = Object.keys(obj);
	    var values = [];
	    for (var i = 0; i < keys.length; i++) {
	      values.push(obj[keys[i]]);
	    }
	    return values;
	  }

	  function merge(a, b) {
	      var merged = {};
	      for (var key in a) {
	          merged[key] = a[key];
	      }
	      for (var key2 in b) {
	          merged[key2] = b[key2];
	      }
	      return merged;
	  }

	  var trimLeft;
	  if (typeof String.prototype.trimLeft === "function") {
	    trimLeft = function(str) {
	      return str.trimLeft();
	    };
	  } else {
	    trimLeft = function(str) {
	      return str.match(/^\s*(.*)/)[1];
	    };
	  }

	  // Type constants used to define functions.
	  var TYPE_NUMBER = 0;
	  var TYPE_ANY = 1;
	  var TYPE_STRING = 2;
	  var TYPE_ARRAY = 3;
	  var TYPE_OBJECT = 4;
	  var TYPE_BOOLEAN = 5;
	  var TYPE_EXPREF = 6;
	  var TYPE_NULL = 7;
	  var TYPE_ARRAY_NUMBER = 8;
	  var TYPE_ARRAY_STRING = 9;

	  var TOK_EOF = "EOF";
	  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
	  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
	  var TOK_RBRACKET = "Rbracket";
	  var TOK_RPAREN = "Rparen";
	  var TOK_COMMA = "Comma";
	  var TOK_COLON = "Colon";
	  var TOK_RBRACE = "Rbrace";
	  var TOK_NUMBER = "Number";
	  var TOK_CURRENT = "Current";
	  var TOK_EXPREF = "Expref";
	  var TOK_PIPE = "Pipe";
	  var TOK_OR = "Or";
	  var TOK_AND = "And";
	  var TOK_EQ = "EQ";
	  var TOK_GT = "GT";
	  var TOK_LT = "LT";
	  var TOK_GTE = "GTE";
	  var TOK_LTE = "LTE";
	  var TOK_NE = "NE";
	  var TOK_FLATTEN = "Flatten";
	  var TOK_STAR = "Star";
	  var TOK_FILTER = "Filter";
	  var TOK_DOT = "Dot";
	  var TOK_NOT = "Not";
	  var TOK_LBRACE = "Lbrace";
	  var TOK_LBRACKET = "Lbracket";
	  var TOK_LPAREN= "Lparen";
	  var TOK_LITERAL= "Literal";

	  // The "&", "[", "<", ">" tokens
	  // are not in basicToken because
	  // there are two token variants
	  // ("&&", "[?", "<=", ">=").  This is specially handled
	  // below.

	  var basicTokens = {
	    ".": TOK_DOT,
	    "*": TOK_STAR,
	    ",": TOK_COMMA,
	    ":": TOK_COLON,
	    "{": TOK_LBRACE,
	    "}": TOK_RBRACE,
	    "]": TOK_RBRACKET,
	    "(": TOK_LPAREN,
	    ")": TOK_RPAREN,
	    "@": TOK_CURRENT
	  };

	  var operatorStartToken = {
	      "<": true,
	      ">": true,
	      "=": true,
	      "!": true
	  };

	  var skipChars = {
	      " ": true,
	      "\t": true,
	      "\n": true
	  };


	  function isAlpha(ch) {
	      return (ch >= "a" && ch <= "z") ||
	             (ch >= "A" && ch <= "Z") ||
	             ch === "_";
	  }

	  function isNum(ch) {
	      return (ch >= "0" && ch <= "9") ||
	             ch === "-";
	  }
	  function isAlphaNum(ch) {
	      return (ch >= "a" && ch <= "z") ||
	             (ch >= "A" && ch <= "Z") ||
	             (ch >= "0" && ch <= "9") ||
	             ch === "_";
	  }

	  function Lexer() {
	  }
	  Lexer.prototype = {
	      tokenize: function(stream) {
	          var tokens = [];
	          this._current = 0;
	          var start;
	          var identifier;
	          var token;
	          while (this._current < stream.length) {
	              if (isAlpha(stream[this._current])) {
	                  start = this._current;
	                  identifier = this._consumeUnquotedIdentifier(stream);
	                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
	                               value: identifier,
	                               start: start});
	              } else if (basicTokens[stream[this._current]] !== undefined) {
	                  tokens.push({type: basicTokens[stream[this._current]],
	                              value: stream[this._current],
	                              start: this._current});
	                  this._current++;
	              } else if (isNum(stream[this._current])) {
	                  token = this._consumeNumber(stream);
	                  tokens.push(token);
	              } else if (stream[this._current] === "[") {
	                  // No need to increment this._current.  This happens
	                  // in _consumeLBracket
	                  token = this._consumeLBracket(stream);
	                  tokens.push(token);
	              } else if (stream[this._current] === "\"") {
	                  start = this._current;
	                  identifier = this._consumeQuotedIdentifier(stream);
	                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
	                               value: identifier,
	                               start: start});
	              } else if (stream[this._current] === "'") {
	                  start = this._current;
	                  identifier = this._consumeRawStringLiteral(stream);
	                  tokens.push({type: TOK_LITERAL,
	                               value: identifier,
	                               start: start});
	              } else if (stream[this._current] === "`") {
	                  start = this._current;
	                  var literal = this._consumeLiteral(stream);
	                  tokens.push({type: TOK_LITERAL,
	                               value: literal,
	                               start: start});
	              } else if (operatorStartToken[stream[this._current]] !== undefined) {
	                  tokens.push(this._consumeOperator(stream));
	              } else if (skipChars[stream[this._current]] !== undefined) {
	                  // Ignore whitespace.
	                  this._current++;
	              } else if (stream[this._current] === "&") {
	                  start = this._current;
	                  this._current++;
	                  if (stream[this._current] === "&") {
	                      this._current++;
	                      tokens.push({type: TOK_AND, value: "&&", start: start});
	                  } else {
	                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
	                  }
	              } else if (stream[this._current] === "|") {
	                  start = this._current;
	                  this._current++;
	                  if (stream[this._current] === "|") {
	                      this._current++;
	                      tokens.push({type: TOK_OR, value: "||", start: start});
	                  } else {
	                      tokens.push({type: TOK_PIPE, value: "|", start: start});
	                  }
	              } else {
	                  var error = new Error("Unknown character:" + stream[this._current]);
	                  error.name = "LexerError";
	                  throw error;
	              }
	          }
	          return tokens;
	      },

	      _consumeUnquotedIdentifier: function(stream) {
	          var start = this._current;
	          this._current++;
	          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
	              this._current++;
	          }
	          return stream.slice(start, this._current);
	      },

	      _consumeQuotedIdentifier: function(stream) {
	          var start = this._current;
	          this._current++;
	          var maxLength = stream.length;
	          while (stream[this._current] !== "\"" && this._current < maxLength) {
	              // You can escape a double quote and you can escape an escape.
	              var current = this._current;
	              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
	                                               stream[current + 1] === "\"")) {
	                  current += 2;
	              } else {
	                  current++;
	              }
	              this._current = current;
	          }
	          this._current++;
	          return JSON.parse(stream.slice(start, this._current));
	      },

	      _consumeRawStringLiteral: function(stream) {
	          var start = this._current;
	          this._current++;
	          var maxLength = stream.length;
	          while (stream[this._current] !== "'" && this._current < maxLength) {
	              // You can escape a single quote and you can escape an escape.
	              var current = this._current;
	              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
	                                               stream[current + 1] === "'")) {
	                  current += 2;
	              } else {
	                  current++;
	              }
	              this._current = current;
	          }
	          this._current++;
	          var literal = stream.slice(start + 1, this._current - 1);
	          return literal.replace("\\'", "'");
	      },

	      _consumeNumber: function(stream) {
	          var start = this._current;
	          this._current++;
	          var maxLength = stream.length;
	          while (isNum(stream[this._current]) && this._current < maxLength) {
	              this._current++;
	          }
	          var value = parseInt(stream.slice(start, this._current));
	          return {type: TOK_NUMBER, value: value, start: start};
	      },

	      _consumeLBracket: function(stream) {
	          var start = this._current;
	          this._current++;
	          if (stream[this._current] === "?") {
	              this._current++;
	              return {type: TOK_FILTER, value: "[?", start: start};
	          } else if (stream[this._current] === "]") {
	              this._current++;
	              return {type: TOK_FLATTEN, value: "[]", start: start};
	          } else {
	              return {type: TOK_LBRACKET, value: "[", start: start};
	          }
	      },

	      _consumeOperator: function(stream) {
	          var start = this._current;
	          var startingChar = stream[start];
	          this._current++;
	          if (startingChar === "!") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_NE, value: "!=", start: start};
	              } else {
	                return {type: TOK_NOT, value: "!", start: start};
	              }
	          } else if (startingChar === "<") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_LTE, value: "<=", start: start};
	              } else {
	                  return {type: TOK_LT, value: "<", start: start};
	              }
	          } else if (startingChar === ">") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_GTE, value: ">=", start: start};
	              } else {
	                  return {type: TOK_GT, value: ">", start: start};
	              }
	          } else if (startingChar === "=") {
	              if (stream[this._current] === "=") {
	                  this._current++;
	                  return {type: TOK_EQ, value: "==", start: start};
	              }
	          }
	      },

	      _consumeLiteral: function(stream) {
	          this._current++;
	          var start = this._current;
	          var maxLength = stream.length;
	          var literal;
	          while(stream[this._current] !== "`" && this._current < maxLength) {
	              // You can escape a literal char or you can escape the escape.
	              var current = this._current;
	              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
	                                               stream[current + 1] === "`")) {
	                  current += 2;
	              } else {
	                  current++;
	              }
	              this._current = current;
	          }
	          var literalString = trimLeft(stream.slice(start, this._current));
	          literalString = literalString.replace("\\`", "`");
	          if (this._looksLikeJSON(literalString)) {
	              literal = JSON.parse(literalString);
	          } else {
	              // Try to JSON parse it as "<literal>"
	              literal = JSON.parse("\"" + literalString + "\"");
	          }
	          // +1 gets us to the ending "`", +1 to move on to the next char.
	          this._current++;
	          return literal;
	      },

	      _looksLikeJSON: function(literalString) {
	          var startingChars = "[{\"";
	          var jsonLiterals = ["true", "false", "null"];
	          var numberLooking = "-0123456789";

	          if (literalString === "") {
	              return false;
	          } else if (startingChars.indexOf(literalString[0]) >= 0) {
	              return true;
	          } else if (jsonLiterals.indexOf(literalString) >= 0) {
	              return true;
	          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
	              try {
	                  JSON.parse(literalString);
	                  return true;
	              } catch (ex) {
	                  return false;
	              }
	          } else {
	              return false;
	          }
	      }
	  };

	      var bindingPower = {};
	      bindingPower[TOK_EOF] = 0;
	      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
	      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
	      bindingPower[TOK_RBRACKET] = 0;
	      bindingPower[TOK_RPAREN] = 0;
	      bindingPower[TOK_COMMA] = 0;
	      bindingPower[TOK_RBRACE] = 0;
	      bindingPower[TOK_NUMBER] = 0;
	      bindingPower[TOK_CURRENT] = 0;
	      bindingPower[TOK_EXPREF] = 0;
	      bindingPower[TOK_PIPE] = 1;
	      bindingPower[TOK_OR] = 2;
	      bindingPower[TOK_AND] = 3;
	      bindingPower[TOK_EQ] = 5;
	      bindingPower[TOK_GT] = 5;
	      bindingPower[TOK_LT] = 5;
	      bindingPower[TOK_GTE] = 5;
	      bindingPower[TOK_LTE] = 5;
	      bindingPower[TOK_NE] = 5;
	      bindingPower[TOK_FLATTEN] = 9;
	      bindingPower[TOK_STAR] = 20;
	      bindingPower[TOK_FILTER] = 21;
	      bindingPower[TOK_DOT] = 40;
	      bindingPower[TOK_NOT] = 45;
	      bindingPower[TOK_LBRACE] = 50;
	      bindingPower[TOK_LBRACKET] = 55;
	      bindingPower[TOK_LPAREN] = 60;

	  function Parser() {
	  }

	  Parser.prototype = {
	      parse: function(expression) {
	          this._loadTokens(expression);
	          this.index = 0;
	          var ast = this.expression(0);
	          if (this._lookahead(0) !== TOK_EOF) {
	              var t = this._lookaheadToken(0);
	              var error = new Error(
	                  "Unexpected token type: " + t.type + ", value: " + t.value);
	              error.name = "ParserError";
	              throw error;
	          }
	          return ast;
	      },

	      _loadTokens: function(expression) {
	          var lexer = new Lexer();
	          var tokens = lexer.tokenize(expression);
	          tokens.push({type: TOK_EOF, value: "", start: expression.length});
	          this.tokens = tokens;
	      },

	      expression: function(rbp) {
	          var leftToken = this._lookaheadToken(0);
	          this._advance();
	          var left = this.nud(leftToken);
	          var currentToken = this._lookahead(0);
	          while (rbp < bindingPower[currentToken]) {
	              this._advance();
	              left = this.led(currentToken, left);
	              currentToken = this._lookahead(0);
	          }
	          return left;
	      },

	      _lookahead: function(number) {
	          return this.tokens[this.index + number].type;
	      },

	      _lookaheadToken: function(number) {
	          return this.tokens[this.index + number];
	      },

	      _advance: function() {
	          this.index++;
	      },

	      nud: function(token) {
	        var left;
	        var right;
	        var expression;
	        switch (token.type) {
	          case TOK_LITERAL:
	            return {type: "Literal", value: token.value};
	          case TOK_UNQUOTEDIDENTIFIER:
	            return {type: "Field", name: token.value};
	          case TOK_QUOTEDIDENTIFIER:
	            var node = {type: "Field", name: token.value};
	            if (this._lookahead(0) === TOK_LPAREN) {
	                throw new Error("Quoted identifier not allowed for function names.");
	            } else {
	                return node;
	            }
	            break;
	          case TOK_NOT:
	            right = this.expression(bindingPower.Not);
	            return {type: "NotExpression", children: [right]};
	          case TOK_STAR:
	            left = {type: "Identity"};
	            right = null;
	            if (this._lookahead(0) === TOK_RBRACKET) {
	                // This can happen in a multiselect,
	                // [a, b, *]
	                right = {type: "Identity"};
	            } else {
	                right = this._parseProjectionRHS(bindingPower.Star);
	            }
	            return {type: "ValueProjection", children: [left, right]};
	          case TOK_FILTER:
	            return this.led(token.type, {type: "Identity"});
	          case TOK_LBRACE:
	            return this._parseMultiselectHash();
	          case TOK_FLATTEN:
	            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
	            right = this._parseProjectionRHS(bindingPower.Flatten);
	            return {type: "Projection", children: [left, right]};
	          case TOK_LBRACKET:
	            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
	                right = this._parseIndexExpression();
	                return this._projectIfSlice({type: "Identity"}, right);
	            } else if (this._lookahead(0) === TOK_STAR &&
	                       this._lookahead(1) === TOK_RBRACKET) {
	                this._advance();
	                this._advance();
	                right = this._parseProjectionRHS(bindingPower.Star);
	                return {type: "Projection",
	                        children: [{type: "Identity"}, right]};
	            } else {
	                return this._parseMultiselectList();
	            }
	            break;
	          case TOK_CURRENT:
	            return {type: TOK_CURRENT};
	          case TOK_EXPREF:
	            expression = this.expression(bindingPower.Expref);
	            return {type: "ExpressionReference", children: [expression]};
	          case TOK_LPAREN:
	            var args = [];
	            while (this._lookahead(0) !== TOK_RPAREN) {
	              if (this._lookahead(0) === TOK_CURRENT) {
	                expression = {type: TOK_CURRENT};
	                this._advance();
	              } else {
	                expression = this.expression(0);
	              }
	              args.push(expression);
	            }
	            this._match(TOK_RPAREN);
	            return args[0];
	          default:
	            this._errorToken(token);
	        }
	      },

	      led: function(tokenName, left) {
	        var right;
	        switch(tokenName) {
	          case TOK_DOT:
	            var rbp = bindingPower.Dot;
	            if (this._lookahead(0) !== TOK_STAR) {
	                right = this._parseDotRHS(rbp);
	                return {type: "Subexpression", children: [left, right]};
	            } else {
	                // Creating a projection.
	                this._advance();
	                right = this._parseProjectionRHS(rbp);
	                return {type: "ValueProjection", children: [left, right]};
	            }
	            break;
	          case TOK_PIPE:
	            right = this.expression(bindingPower.Pipe);
	            return {type: TOK_PIPE, children: [left, right]};
	          case TOK_OR:
	            right = this.expression(bindingPower.Or);
	            return {type: "OrExpression", children: [left, right]};
	          case TOK_AND:
	            right = this.expression(bindingPower.And);
	            return {type: "AndExpression", children: [left, right]};
	          case TOK_LPAREN:
	            var name = left.name;
	            var args = [];
	            var expression, node;
	            while (this._lookahead(0) !== TOK_RPAREN) {
	              if (this._lookahead(0) === TOK_CURRENT) {
	                expression = {type: TOK_CURRENT};
	                this._advance();
	              } else {
	                expression = this.expression(0);
	              }
	              if (this._lookahead(0) === TOK_COMMA) {
	                this._match(TOK_COMMA);
	              }
	              args.push(expression);
	            }
	            this._match(TOK_RPAREN);
	            node = {type: "Function", name: name, children: args};
	            return node;
	          case TOK_FILTER:
	            var condition = this.expression(0);
	            this._match(TOK_RBRACKET);
	            if (this._lookahead(0) === TOK_FLATTEN) {
	              right = {type: "Identity"};
	            } else {
	              right = this._parseProjectionRHS(bindingPower.Filter);
	            }
	            return {type: "FilterProjection", children: [left, right, condition]};
	          case TOK_FLATTEN:
	            var leftNode = {type: TOK_FLATTEN, children: [left]};
	            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
	            return {type: "Projection", children: [leftNode, rightNode]};
	          case TOK_EQ:
	          case TOK_NE:
	          case TOK_GT:
	          case TOK_GTE:
	          case TOK_LT:
	          case TOK_LTE:
	            return this._parseComparator(left, tokenName);
	          case TOK_LBRACKET:
	            var token = this._lookaheadToken(0);
	            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
	                right = this._parseIndexExpression();
	                return this._projectIfSlice(left, right);
	            } else {
	                this._match(TOK_STAR);
	                this._match(TOK_RBRACKET);
	                right = this._parseProjectionRHS(bindingPower.Star);
	                return {type: "Projection", children: [left, right]};
	            }
	            break;
	          default:
	            this._errorToken(this._lookaheadToken(0));
	        }
	      },

	      _match: function(tokenType) {
	          if (this._lookahead(0) === tokenType) {
	              this._advance();
	          } else {
	              var t = this._lookaheadToken(0);
	              var error = new Error("Expected " + tokenType + ", got: " + t.type);
	              error.name = "ParserError";
	              throw error;
	          }
	      },

	      _errorToken: function(token) {
	          var error = new Error("Invalid token (" +
	                                token.type + "): \"" +
	                                token.value + "\"");
	          error.name = "ParserError";
	          throw error;
	      },


	      _parseIndexExpression: function() {
	          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
	              return this._parseSliceExpression();
	          } else {
	              var node = {
	                  type: "Index",
	                  value: this._lookaheadToken(0).value};
	              this._advance();
	              this._match(TOK_RBRACKET);
	              return node;
	          }
	      },

	      _projectIfSlice: function(left, right) {
	          var indexExpr = {type: "IndexExpression", children: [left, right]};
	          if (right.type === "Slice") {
	              return {
	                  type: "Projection",
	                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
	              };
	          } else {
	              return indexExpr;
	          }
	      },

	      _parseSliceExpression: function() {
	          // [start:end:step] where each part is optional, as well as the last
	          // colon.
	          var parts = [null, null, null];
	          var index = 0;
	          var currentToken = this._lookahead(0);
	          while (currentToken !== TOK_RBRACKET && index < 3) {
	              if (currentToken === TOK_COLON) {
	                  index++;
	                  this._advance();
	              } else if (currentToken === TOK_NUMBER) {
	                  parts[index] = this._lookaheadToken(0).value;
	                  this._advance();
	              } else {
	                  var t = this._lookahead(0);
	                  var error = new Error("Syntax error, unexpected token: " +
	                                        t.value + "(" + t.type + ")");
	                  error.name = "Parsererror";
	                  throw error;
	              }
	              currentToken = this._lookahead(0);
	          }
	          this._match(TOK_RBRACKET);
	          return {
	              type: "Slice",
	              children: parts
	          };
	      },

	      _parseComparator: function(left, comparator) {
	        var right = this.expression(bindingPower[comparator]);
	        return {type: "Comparator", name: comparator, children: [left, right]};
	      },

	      _parseDotRHS: function(rbp) {
	          var lookahead = this._lookahead(0);
	          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
	          if (exprTokens.indexOf(lookahead) >= 0) {
	              return this.expression(rbp);
	          } else if (lookahead === TOK_LBRACKET) {
	              this._match(TOK_LBRACKET);
	              return this._parseMultiselectList();
	          } else if (lookahead === TOK_LBRACE) {
	              this._match(TOK_LBRACE);
	              return this._parseMultiselectHash();
	          }
	      },

	      _parseProjectionRHS: function(rbp) {
	          var right;
	          if (bindingPower[this._lookahead(0)] < 10) {
	              right = {type: "Identity"};
	          } else if (this._lookahead(0) === TOK_LBRACKET) {
	              right = this.expression(rbp);
	          } else if (this._lookahead(0) === TOK_FILTER) {
	              right = this.expression(rbp);
	          } else if (this._lookahead(0) === TOK_DOT) {
	              this._match(TOK_DOT);
	              right = this._parseDotRHS(rbp);
	          } else {
	              var t = this._lookaheadToken(0);
	              var error = new Error("Sytanx error, unexpected token: " +
	                                    t.value + "(" + t.type + ")");
	              error.name = "ParserError";
	              throw error;
	          }
	          return right;
	      },

	      _parseMultiselectList: function() {
	          var expressions = [];
	          while (this._lookahead(0) !== TOK_RBRACKET) {
	              var expression = this.expression(0);
	              expressions.push(expression);
	              if (this._lookahead(0) === TOK_COMMA) {
	                  this._match(TOK_COMMA);
	                  if (this._lookahead(0) === TOK_RBRACKET) {
	                    throw new Error("Unexpected token Rbracket");
	                  }
	              }
	          }
	          this._match(TOK_RBRACKET);
	          return {type: "MultiSelectList", children: expressions};
	      },

	      _parseMultiselectHash: function() {
	        var pairs = [];
	        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
	        var keyToken, keyName, value, node;
	        for (;;) {
	          keyToken = this._lookaheadToken(0);
	          if (identifierTypes.indexOf(keyToken.type) < 0) {
	            throw new Error("Expecting an identifier token, got: " +
	                            keyToken.type);
	          }
	          keyName = keyToken.value;
	          this._advance();
	          this._match(TOK_COLON);
	          value = this.expression(0);
	          node = {type: "KeyValuePair", name: keyName, value: value};
	          pairs.push(node);
	          if (this._lookahead(0) === TOK_COMMA) {
	            this._match(TOK_COMMA);
	          } else if (this._lookahead(0) === TOK_RBRACE) {
	            this._match(TOK_RBRACE);
	            break;
	          }
	        }
	        return {type: "MultiSelectHash", children: pairs};
	      }
	  };


	  function TreeInterpreter(runtime) {
	    this.runtime = runtime;
	  }

	  TreeInterpreter.prototype = {
	      search: function(node, value) {
	          return this.visit(node, value);
	      },

	      visit: function(node, value) {
	          var matched, current, result, first, second, field, left, right, collected, i;
	          switch (node.type) {
	            case "Field":
	              if (value === null ) {
	                  return null;
	              } else if (isObject(value)) {
	                  field = value[node.name];
	                  if (field === undefined) {
	                      return null;
	                  } else {
	                      return field;
	                  }
	              } else {
	                return null;
	              }
	              break;
	            case "Subexpression":
	              result = this.visit(node.children[0], value);
	              for (i = 1; i < node.children.length; i++) {
	                  result = this.visit(node.children[1], result);
	                  if (result === null) {
	                      return null;
	                  }
	              }
	              return result;
	            case "IndexExpression":
	              left = this.visit(node.children[0], value);
	              right = this.visit(node.children[1], left);
	              return right;
	            case "Index":
	              if (!isArray(value)) {
	                return null;
	              }
	              var index = node.value;
	              if (index < 0) {
	                index = value.length + index;
	              }
	              result = value[index];
	              if (result === undefined) {
	                result = null;
	              }
	              return result;
	            case "Slice":
	              if (!isArray(value)) {
	                return null;
	              }
	              var sliceParams = node.children.slice(0);
	              var computed = this.computeSliceParams(value.length, sliceParams);
	              var start = computed[0];
	              var stop = computed[1];
	              var step = computed[2];
	              result = [];
	              if (step > 0) {
	                  for (i = start; i < stop; i += step) {
	                      result.push(value[i]);
	                  }
	              } else {
	                  for (i = start; i > stop; i += step) {
	                      result.push(value[i]);
	                  }
	              }
	              return result;
	            case "Projection":
	              // Evaluate left child.
	              var base = this.visit(node.children[0], value);
	              if (!isArray(base)) {
	                return null;
	              }
	              collected = [];
	              for (i = 0; i < base.length; i++) {
	                current = this.visit(node.children[1], base[i]);
	                if (current !== null) {
	                  collected.push(current);
	                }
	              }
	              return collected;
	            case "ValueProjection":
	              // Evaluate left child.
	              base = this.visit(node.children[0], value);
	              if (!isObject(base)) {
	                return null;
	              }
	              collected = [];
	              var values = objValues(base);
	              for (i = 0; i < values.length; i++) {
	                current = this.visit(node.children[1], values[i]);
	                if (current !== null) {
	                  collected.push(current);
	                }
	              }
	              return collected;
	            case "FilterProjection":
	              base = this.visit(node.children[0], value);
	              if (!isArray(base)) {
	                return null;
	              }
	              var filtered = [];
	              var finalResults = [];
	              for (i = 0; i < base.length; i++) {
	                matched = this.visit(node.children[2], base[i]);
	                if (!isFalse(matched)) {
	                  filtered.push(base[i]);
	                }
	              }
	              for (var j = 0; j < filtered.length; j++) {
	                current = this.visit(node.children[1], filtered[j]);
	                if (current !== null) {
	                  finalResults.push(current);
	                }
	              }
	              return finalResults;
	            case "Comparator":
	              first = this.visit(node.children[0], value);
	              second = this.visit(node.children[1], value);
	              switch(node.name) {
	                case TOK_EQ:
	                  result = strictDeepEqual(first, second);
	                  break;
	                case TOK_NE:
	                  result = !strictDeepEqual(first, second);
	                  break;
	                case TOK_GT:
	                  result = first > second;
	                  break;
	                case TOK_GTE:
	                  result = first >= second;
	                  break;
	                case TOK_LT:
	                  result = first < second;
	                  break;
	                case TOK_LTE:
	                  result = first <= second;
	                  break;
	                default:
	                  throw new Error("Unknown comparator: " + node.name);
	              }
	              return result;
	            case TOK_FLATTEN:
	              var original = this.visit(node.children[0], value);
	              if (!isArray(original)) {
	                return null;
	              }
	              var merged = [];
	              for (i = 0; i < original.length; i++) {
	                current = original[i];
	                if (isArray(current)) {
	                  merged.push.apply(merged, current);
	                } else {
	                  merged.push(current);
	                }
	              }
	              return merged;
	            case "Identity":
	              return value;
	            case "MultiSelectList":
	              if (value === null) {
	                return null;
	              }
	              collected = [];
	              for (i = 0; i < node.children.length; i++) {
	                  collected.push(this.visit(node.children[i], value));
	              }
	              return collected;
	            case "MultiSelectHash":
	              if (value === null) {
	                return null;
	              }
	              collected = {};
	              var child;
	              for (i = 0; i < node.children.length; i++) {
	                child = node.children[i];
	                collected[child.name] = this.visit(child.value, value);
	              }
	              return collected;
	            case "OrExpression":
	              matched = this.visit(node.children[0], value);
	              if (isFalse(matched)) {
	                  matched = this.visit(node.children[1], value);
	              }
	              return matched;
	            case "AndExpression":
	              first = this.visit(node.children[0], value);

	              if (isFalse(first) === true) {
	                return first;
	              }
	              return this.visit(node.children[1], value);
	            case "NotExpression":
	              first = this.visit(node.children[0], value);
	              return isFalse(first);
	            case "Literal":
	              return node.value;
	            case TOK_PIPE:
	              left = this.visit(node.children[0], value);
	              return this.visit(node.children[1], left);
	            case TOK_CURRENT:
	              return value;
	            case "Function":
	              var resolvedArgs = [];
	              for (i = 0; i < node.children.length; i++) {
	                  resolvedArgs.push(this.visit(node.children[i], value));
	              }
	              return this.runtime.callFunction(node.name, resolvedArgs);
	            case "ExpressionReference":
	              var refNode = node.children[0];
	              // Tag the node with a specific attribute so the type
	              // checker verify the type.
	              refNode.jmespathType = TOK_EXPREF;
	              return refNode;
	            default:
	              throw new Error("Unknown node type: " + node.type);
	          }
	      },

	      computeSliceParams: function(arrayLength, sliceParams) {
	        var start = sliceParams[0];
	        var stop = sliceParams[1];
	        var step = sliceParams[2];
	        var computed = [null, null, null];
	        if (step === null) {
	          step = 1;
	        } else if (step === 0) {
	          var error = new Error("Invalid slice, step cannot be 0");
	          error.name = "RuntimeError";
	          throw error;
	        }
	        var stepValueNegative = step < 0 ? true : false;

	        if (start === null) {
	            start = stepValueNegative ? arrayLength - 1 : 0;
	        } else {
	            start = this.capSliceRange(arrayLength, start, step);
	        }

	        if (stop === null) {
	            stop = stepValueNegative ? -1 : arrayLength;
	        } else {
	            stop = this.capSliceRange(arrayLength, stop, step);
	        }
	        computed[0] = start;
	        computed[1] = stop;
	        computed[2] = step;
	        return computed;
	      },

	      capSliceRange: function(arrayLength, actualValue, step) {
	          if (actualValue < 0) {
	              actualValue += arrayLength;
	              if (actualValue < 0) {
	                  actualValue = step < 0 ? -1 : 0;
	              }
	          } else if (actualValue >= arrayLength) {
	              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
	          }
	          return actualValue;
	      }

	  };

	  function Runtime(interpreter) {
	    this._interpreter = interpreter;
	    this.functionTable = {
	        // name: [function, <signature>]
	        // The <signature> can be:
	        //
	        // {
	        //   args: [[type1, type2], [type1, type2]],
	        //   variadic: true|false
	        // }
	        //
	        // Each arg in the arg list is a list of valid types
	        // (if the function is overloaded and supports multiple
	        // types.  If the type is "any" then no type checking
	        // occurs on the argument.  Variadic is optional
	        // and if not provided is assumed to be false.
	        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
	        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
	        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
	        contains: {
	            _func: this._functionContains,
	            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
	                        {types: [TYPE_ANY]}]},
	        "ends_with": {
	            _func: this._functionEndsWith,
	            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
	        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
	        length: {
	            _func: this._functionLength,
	            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
	        map: {
	            _func: this._functionMap,
	            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
	        max: {
	            _func: this._functionMax,
	            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
	        "merge": {
	            _func: this._functionMerge,
	            _signature: [{types: [TYPE_OBJECT], variadic: true}]
	        },
	        "max_by": {
	          _func: this._functionMaxBy,
	          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
	        },
	        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
	        "starts_with": {
	            _func: this._functionStartsWith,
	            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
	        min: {
	            _func: this._functionMin,
	            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
	        "min_by": {
	          _func: this._functionMinBy,
	          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
	        },
	        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
	        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
	        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
	        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
	        "sort_by": {
	          _func: this._functionSortBy,
	          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
	        },
	        join: {
	            _func: this._functionJoin,
	            _signature: [
	                {types: [TYPE_STRING]},
	                {types: [TYPE_ARRAY_STRING]}
	            ]
	        },
	        reverse: {
	            _func: this._functionReverse,
	            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
	        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
	        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
	        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
	        "not_null": {
	            _func: this._functionNotNull,
	            _signature: [{types: [TYPE_ANY], variadic: true}]
	        }
	    };
	  }

	  Runtime.prototype = {
	    callFunction: function(name, resolvedArgs) {
	      var functionEntry = this.functionTable[name];
	      if (functionEntry === undefined) {
	          throw new Error("Unknown function: " + name + "()");
	      }
	      this._validateArgs(name, resolvedArgs, functionEntry._signature);
	      return functionEntry._func.call(this, resolvedArgs);
	    },

	    _validateArgs: function(name, args, signature) {
	        // Validating the args requires validating
	        // the correct arity and the correct type of each arg.
	        // If the last argument is declared as variadic, then we need
	        // a minimum number of args to be required.  Otherwise it has to
	        // be an exact amount.
	        var pluralized;
	        if (signature[signature.length - 1].variadic) {
	            if (args.length < signature.length) {
	                pluralized = signature.length === 1 ? " argument" : " arguments";
	                throw new Error("ArgumentError: " + name + "() " +
	                                "takes at least" + signature.length + pluralized +
	                                " but received " + args.length);
	            }
	        } else if (args.length !== signature.length) {
	            pluralized = signature.length === 1 ? " argument" : " arguments";
	            throw new Error("ArgumentError: " + name + "() " +
	                            "takes " + signature.length + pluralized +
	                            " but received " + args.length);
	        }
	        var currentSpec;
	        var actualType;
	        var typeMatched;
	        for (var i = 0; i < signature.length; i++) {
	            typeMatched = false;
	            currentSpec = signature[i].types;
	            actualType = this._getTypeName(args[i]);
	            for (var j = 0; j < currentSpec.length; j++) {
	                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
	                    typeMatched = true;
	                    break;
	                }
	            }
	            if (!typeMatched) {
	                throw new Error("TypeError: " + name + "() " +
	                                "expected argument " + (i + 1) +
	                                " to be type " + currentSpec +
	                                " but received type " + actualType +
	                                " instead.");
	            }
	        }
	    },

	    _typeMatches: function(actual, expected, argValue) {
	        if (expected === TYPE_ANY) {
	            return true;
	        }
	        if (expected === TYPE_ARRAY_STRING ||
	            expected === TYPE_ARRAY_NUMBER ||
	            expected === TYPE_ARRAY) {
	            // The expected type can either just be array,
	            // or it can require a specific subtype (array of numbers).
	            //
	            // The simplest case is if "array" with no subtype is specified.
	            if (expected === TYPE_ARRAY) {
	                return actual === TYPE_ARRAY;
	            } else if (actual === TYPE_ARRAY) {
	                // Otherwise we need to check subtypes.
	                // I think this has potential to be improved.
	                var subtype;
	                if (expected === TYPE_ARRAY_NUMBER) {
	                  subtype = TYPE_NUMBER;
	                } else if (expected === TYPE_ARRAY_STRING) {
	                  subtype = TYPE_STRING;
	                }
	                for (var i = 0; i < argValue.length; i++) {
	                    if (!this._typeMatches(
	                            this._getTypeName(argValue[i]), subtype,
	                                             argValue[i])) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	        } else {
	            return actual === expected;
	        }
	    },
	    _getTypeName: function(obj) {
	        switch (Object.prototype.toString.call(obj)) {
	            case "[object String]":
	              return TYPE_STRING;
	            case "[object Number]":
	              return TYPE_NUMBER;
	            case "[object Array]":
	              return TYPE_ARRAY;
	            case "[object Boolean]":
	              return TYPE_BOOLEAN;
	            case "[object Null]":
	              return TYPE_NULL;
	            case "[object Object]":
	              // Check if it's an expref.  If it has, it's been
	              // tagged with a jmespathType attr of 'Expref';
	              if (obj.jmespathType === TOK_EXPREF) {
	                return TYPE_EXPREF;
	              } else {
	                return TYPE_OBJECT;
	              }
	        }
	    },

	    _functionStartsWith: function(resolvedArgs) {
	        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
	    },

	    _functionEndsWith: function(resolvedArgs) {
	        var searchStr = resolvedArgs[0];
	        var suffix = resolvedArgs[1];
	        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
	    },

	    _functionReverse: function(resolvedArgs) {
	        var typeName = this._getTypeName(resolvedArgs[0]);
	        if (typeName === TYPE_STRING) {
	          var originalStr = resolvedArgs[0];
	          var reversedStr = "";
	          for (var i = originalStr.length - 1; i >= 0; i--) {
	              reversedStr += originalStr[i];
	          }
	          return reversedStr;
	        } else {
	          var reversedArray = resolvedArgs[0].slice(0);
	          reversedArray.reverse();
	          return reversedArray;
	        }
	    },

	    _functionAbs: function(resolvedArgs) {
	      return Math.abs(resolvedArgs[0]);
	    },

	    _functionCeil: function(resolvedArgs) {
	        return Math.ceil(resolvedArgs[0]);
	    },

	    _functionAvg: function(resolvedArgs) {
	        var sum = 0;
	        var inputArray = resolvedArgs[0];
	        for (var i = 0; i < inputArray.length; i++) {
	            sum += inputArray[i];
	        }
	        return sum / inputArray.length;
	    },

	    _functionContains: function(resolvedArgs) {
	        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
	    },

	    _functionFloor: function(resolvedArgs) {
	        return Math.floor(resolvedArgs[0]);
	    },

	    _functionLength: function(resolvedArgs) {
	       if (!isObject(resolvedArgs[0])) {
	         return resolvedArgs[0].length;
	       } else {
	         // As far as I can tell, there's no way to get the length
	         // of an object without O(n) iteration through the object.
	         return Object.keys(resolvedArgs[0]).length;
	       }
	    },

	    _functionMap: function(resolvedArgs) {
	      var mapped = [];
	      var interpreter = this._interpreter;
	      var exprefNode = resolvedArgs[0];
	      var elements = resolvedArgs[1];
	      for (var i = 0; i < elements.length; i++) {
	          mapped.push(interpreter.visit(exprefNode, elements[i]));
	      }
	      return mapped;
	    },

	    _functionMerge: function(resolvedArgs) {
	      var merged = {};
	      for (var i = 0; i < resolvedArgs.length; i++) {
	        var current = resolvedArgs[i];
	        for (var key in current) {
	          merged[key] = current[key];
	        }
	      }
	      return merged;
	    },

	    _functionMax: function(resolvedArgs) {
	      if (resolvedArgs[0].length > 0) {
	        var typeName = this._getTypeName(resolvedArgs[0][0]);
	        if (typeName === TYPE_NUMBER) {
	          return Math.max.apply(Math, resolvedArgs[0]);
	        } else {
	          var elements = resolvedArgs[0];
	          var maxElement = elements[0];
	          for (var i = 1; i < elements.length; i++) {
	              if (maxElement.localeCompare(elements[i]) < 0) {
	                  maxElement = elements[i];
	              }
	          }
	          return maxElement;
	        }
	      } else {
	          return null;
	      }
	    },

	    _functionMin: function(resolvedArgs) {
	      if (resolvedArgs[0].length > 0) {
	        var typeName = this._getTypeName(resolvedArgs[0][0]);
	        if (typeName === TYPE_NUMBER) {
	          return Math.min.apply(Math, resolvedArgs[0]);
	        } else {
	          var elements = resolvedArgs[0];
	          var minElement = elements[0];
	          for (var i = 1; i < elements.length; i++) {
	              if (elements[i].localeCompare(minElement) < 0) {
	                  minElement = elements[i];
	              }
	          }
	          return minElement;
	        }
	      } else {
	        return null;
	      }
	    },

	    _functionSum: function(resolvedArgs) {
	      var sum = 0;
	      var listToSum = resolvedArgs[0];
	      for (var i = 0; i < listToSum.length; i++) {
	        sum += listToSum[i];
	      }
	      return sum;
	    },

	    _functionType: function(resolvedArgs) {
	        switch (this._getTypeName(resolvedArgs[0])) {
	          case TYPE_NUMBER:
	            return "number";
	          case TYPE_STRING:
	            return "string";
	          case TYPE_ARRAY:
	            return "array";
	          case TYPE_OBJECT:
	            return "object";
	          case TYPE_BOOLEAN:
	            return "boolean";
	          case TYPE_EXPREF:
	            return "expref";
	          case TYPE_NULL:
	            return "null";
	        }
	    },

	    _functionKeys: function(resolvedArgs) {
	        return Object.keys(resolvedArgs[0]);
	    },

	    _functionValues: function(resolvedArgs) {
	        var obj = resolvedArgs[0];
	        var keys = Object.keys(obj);
	        var values = [];
	        for (var i = 0; i < keys.length; i++) {
	            values.push(obj[keys[i]]);
	        }
	        return values;
	    },

	    _functionJoin: function(resolvedArgs) {
	        var joinChar = resolvedArgs[0];
	        var listJoin = resolvedArgs[1];
	        return listJoin.join(joinChar);
	    },

	    _functionToArray: function(resolvedArgs) {
	        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
	            return resolvedArgs[0];
	        } else {
	            return [resolvedArgs[0]];
	        }
	    },

	    _functionToString: function(resolvedArgs) {
	        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
	            return resolvedArgs[0];
	        } else {
	            return JSON.stringify(resolvedArgs[0]);
	        }
	    },

	    _functionToNumber: function(resolvedArgs) {
	        var typeName = this._getTypeName(resolvedArgs[0]);
	        var convertedValue;
	        if (typeName === TYPE_NUMBER) {
	            return resolvedArgs[0];
	        } else if (typeName === TYPE_STRING) {
	            convertedValue = +resolvedArgs[0];
	            if (!isNaN(convertedValue)) {
	                return convertedValue;
	            }
	        }
	        return null;
	    },

	    _functionNotNull: function(resolvedArgs) {
	        for (var i = 0; i < resolvedArgs.length; i++) {
	            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
	                return resolvedArgs[i];
	            }
	        }
	        return null;
	    },

	    _functionSort: function(resolvedArgs) {
	        var sortedArray = resolvedArgs[0].slice(0);
	        sortedArray.sort();
	        return sortedArray;
	    },

	    _functionSortBy: function(resolvedArgs) {
	        var sortedArray = resolvedArgs[0].slice(0);
	        if (sortedArray.length === 0) {
	            return sortedArray;
	        }
	        var interpreter = this._interpreter;
	        var exprefNode = resolvedArgs[1];
	        var requiredType = this._getTypeName(
	            interpreter.visit(exprefNode, sortedArray[0]));
	        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
	            throw new Error("TypeError");
	        }
	        var that = this;
	        // In order to get a stable sort out of an unstable
	        // sort algorithm, we decorate/sort/undecorate (DSU)
	        // by creating a new list of [index, element] pairs.
	        // In the cmp function, if the evaluated elements are
	        // equal, then the index will be used as the tiebreaker.
	        // After the decorated list has been sorted, it will be
	        // undecorated to extract the original elements.
	        var decorated = [];
	        for (var i = 0; i < sortedArray.length; i++) {
	          decorated.push([i, sortedArray[i]]);
	        }
	        decorated.sort(function(a, b) {
	          var exprA = interpreter.visit(exprefNode, a[1]);
	          var exprB = interpreter.visit(exprefNode, b[1]);
	          if (that._getTypeName(exprA) !== requiredType) {
	              throw new Error(
	                  "TypeError: expected " + requiredType + ", received " +
	                  that._getTypeName(exprA));
	          } else if (that._getTypeName(exprB) !== requiredType) {
	              throw new Error(
	                  "TypeError: expected " + requiredType + ", received " +
	                  that._getTypeName(exprB));
	          }
	          if (exprA > exprB) {
	            return 1;
	          } else if (exprA < exprB) {
	            return -1;
	          } else {
	            // If they're equal compare the items by their
	            // order to maintain relative order of equal keys
	            // (i.e. to get a stable sort).
	            return a[0] - b[0];
	          }
	        });
	        // Undecorate: extract out the original list elements.
	        for (var j = 0; j < decorated.length; j++) {
	          sortedArray[j] = decorated[j][1];
	        }
	        return sortedArray;
	    },

	    _functionMaxBy: function(resolvedArgs) {
	      var exprefNode = resolvedArgs[1];
	      var resolvedArray = resolvedArgs[0];
	      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
	      var maxNumber = -Infinity;
	      var maxRecord;
	      var current;
	      for (var i = 0; i < resolvedArray.length; i++) {
	        current = keyFunction(resolvedArray[i]);
	        if (current > maxNumber) {
	          maxNumber = current;
	          maxRecord = resolvedArray[i];
	        }
	      }
	      return maxRecord;
	    },

	    _functionMinBy: function(resolvedArgs) {
	      var exprefNode = resolvedArgs[1];
	      var resolvedArray = resolvedArgs[0];
	      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
	      var minNumber = Infinity;
	      var minRecord;
	      var current;
	      for (var i = 0; i < resolvedArray.length; i++) {
	        current = keyFunction(resolvedArray[i]);
	        if (current < minNumber) {
	          minNumber = current;
	          minRecord = resolvedArray[i];
	        }
	      }
	      return minRecord;
	    },

	    createKeyFunction: function(exprefNode, allowedTypes) {
	      var that = this;
	      var interpreter = this._interpreter;
	      var keyFunc = function(x) {
	        var current = interpreter.visit(exprefNode, x);
	        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
	          var msg = "TypeError: expected one of " + allowedTypes +
	                    ", received " + that._getTypeName(current);
	          throw new Error(msg);
	        }
	        return current;
	      };
	      return keyFunc;
	    }

	  };

	  function compile(stream) {
	    var parser = new Parser();
	    var ast = parser.parse(stream);
	    return ast;
	  }

	  function tokenize(stream) {
	      var lexer = new Lexer();
	      return lexer.tokenize(stream);
	  }

	  function search(data, expression) {
	      var parser = new Parser();
	      // This needs to be improved.  Both the interpreter and runtime depend on
	      // each other.  The runtime needs the interpreter to support exprefs.
	      // There's likely a clean way to avoid the cyclic dependency.
	      var runtime = new Runtime();
	      var interpreter = new TreeInterpreter(runtime);
	      runtime._interpreter = interpreter;
	      var node = parser.parse(expression);
	      return interpreter.search(node, data);
	  }

	  exports.tokenize = tokenize;
	  exports.compile = compile;
	  exports.search = search;
	  exports.strictDeepEqual = strictDeepEqual;
	})( false ? this.jmespath = {} : exports);


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;
	var jmespath = __webpack_require__(193);

	/**
	 * This class encapsulates the response information
	 * from a service request operation sent through {AWS.Request}.
	 * The response object has two main properties for getting information
	 * back from a request:
	 *
	 * ## The `data` property
	 *
	 * The `response.data` property contains the serialized object data
	 * retrieved from the service request. For instance, for an
	 * Amazon DynamoDB `listTables` method call, the response data might
	 * look like:
	 *
	 * ```
	 * > resp.data
	 * { TableNames:
	 *    [ 'table1', 'table2', ... ] }
	 * ```
	 *
	 * The `data` property can be null if an error occurs (see below).
	 *
	 * ## The `error` property
	 *
	 * In the event of a service error (or transfer error), the
	 * `response.error` property will be filled with the given
	 * error data in the form:
	 *
	 * ```
	 * { code: 'SHORT_UNIQUE_ERROR_CODE',
	 *   message: 'Some human readable error message' }
	 * ```
	 *
	 * In the case of an error, the `data` property will be `null`.
	 * Note that if you handle events that can be in a failure state,
	 * you should always check whether `response.error` is set
	 * before attempting to access the `response.data` property.
	 *
	 * @!attribute data
	 *   @readonly
	 *   @!group Data Properties
	 *   @note Inside of a {AWS.Request~httpData} event, this
	 *     property contains a single raw packet instead of the
	 *     full de-serialized service response.
	 *   @return [Object] the de-serialized response data
	 *     from the service.
	 *
	 * @!attribute error
	 *   An structure containing information about a service
	 *   or networking error.
	 *   @readonly
	 *   @!group Data Properties
	 *   @note This attribute is only filled if a service or
	 *     networking error occurs.
	 *   @return [Error]
	 *     * code [String] a unique short code representing the
	 *       error that was emitted.
	 *     * message [String] a longer human readable error message
	 *     * retryable [Boolean] whether the error message is
	 *       retryable.
	 *     * statusCode [Numeric] in the case of a request that reached the service,
	 *       this value contains the response status code.
	 *     * time [Date] the date time object when the error occurred.
	 *     * hostname [String] set when a networking error occurs to easily
	 *       identify the endpoint of the request.
	 *     * region [String] set when a networking error occurs to easily
	 *       identify the region of the request.
	 *
	 * @!attribute requestId
	 *   @readonly
	 *   @!group Data Properties
	 *   @return [String] the unique request ID associated with the response.
	 *     Log this value when debugging requests for AWS support.
	 *
	 * @!attribute retryCount
	 *   @readonly
	 *   @!group Operation Properties
	 *   @return [Integer] the number of retries that were
	 *     attempted before the request was completed.
	 *
	 * @!attribute redirectCount
	 *   @readonly
	 *   @!group Operation Properties
	 *   @return [Integer] the number of redirects that were
	 *     followed before the request was completed.
	 *
	 * @!attribute httpResponse
	 *   @readonly
	 *   @!group HTTP Properties
	 *   @return [AWS.HttpResponse] the raw HTTP response object
	 *     containing the response headers and body information
	 *     from the server.
	 *
	 * @see AWS.Request
	 */
	AWS.Response = inherit({

	  /**
	   * @api private
	   */
	  constructor: function Response(request) {
	    this.request = request;
	    this.data = null;
	    this.error = null;
	    this.retryCount = 0;
	    this.redirectCount = 0;
	    this.httpResponse = new AWS.HttpResponse();
	    if (request) {
	      this.maxRetries = request.service.numRetries();
	      this.maxRedirects = request.service.config.maxRedirects;
	    }
	  },

	  /**
	   * Creates a new request for the next page of response data, calling the
	   * callback with the page data if a callback is provided.
	   *
	   * @callback callback function(err, data)
	   *   Called when a page of data is returned from the next request.
	   *
	   *   @param err [Error] an error object, if an error occurred in the request
	   *   @param data [Object] the next page of data, or null, if there are no
	   *     more pages left.
	   * @return [AWS.Request] the request object for the next page of data
	   * @return [null] if no callback is provided and there are no pages left
	   *   to retrieve.
	   * @since v1.4.0
	   */
	  nextPage: function nextPage(callback) {
	    var config;
	    var service = this.request.service;
	    var operation = this.request.operation;
	    try {
	      config = service.paginationConfig(operation, true);
	    } catch (e) { this.error = e; }

	    if (!this.hasNextPage()) {
	      if (callback) callback(this.error, null);
	      else if (this.error) throw this.error;
	      return null;
	    }

	    var params = AWS.util.copy(this.request.params);
	    if (!this.nextPageTokens) {
	      return callback ? callback(null, null) : null;
	    } else {
	      var inputTokens = config.inputToken;
	      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
	      for (var i = 0; i < inputTokens.length; i++) {
	        params[inputTokens[i]] = this.nextPageTokens[i];
	      }
	      return service.makeRequest(this.request.operation, params, callback);
	    }
	  },

	  /**
	   * @return [Boolean] whether more pages of data can be returned by further
	   *   requests
	   * @since v1.4.0
	   */
	  hasNextPage: function hasNextPage() {
	    this.cacheNextPageTokens();
	    if (this.nextPageTokens) return true;
	    if (this.nextPageTokens === undefined) return undefined;
	    else return false;
	  },

	  /**
	   * @api private
	   */
	  cacheNextPageTokens: function cacheNextPageTokens() {
	    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
	    this.nextPageTokens = undefined;

	    var config = this.request.service.paginationConfig(this.request.operation);
	    if (!config) return this.nextPageTokens;

	    this.nextPageTokens = null;
	    if (config.moreResults) {
	      if (!jmespath.search(this.data, config.moreResults)) {
	        return this.nextPageTokens;
	      }
	    }

	    var exprs = config.outputToken;
	    if (typeof exprs === 'string') exprs = [exprs];
	    AWS.util.arrayEach.call(this, exprs, function (expr) {
	      var output = jmespath.search(this.data, expr);
	      if (output) {
	        this.nextPageTokens = this.nextPageTokens || [];
	        this.nextPageTokens.push(output);
	      }
	    });

	    return this.nextPageTokens;
	  }

	});


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"). You
	 * may not use this file except in compliance with the License. A copy of
	 * the License is located at
	 *
	 *     http://aws.amazon.com/apache2.0/
	 *
	 * or in the "license" file accompanying this file. This file is
	 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific
	 * language governing permissions and limitations under the License.
	 */

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;
	var jmespath = __webpack_require__(193);

	/**
	 * @api private
	 */
	function CHECK_ACCEPTORS(resp) {
	  var waiter = resp.request._waiter;
	  var acceptors = waiter.config.acceptors;
	  var acceptorMatched = false;
	  var state = 'retry';

	  acceptors.forEach(function(acceptor) {
	    if (!acceptorMatched) {
	      var matcher = waiter.matchers[acceptor.matcher];
	      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
	        acceptorMatched = true;
	        state = acceptor.state;
	      }
	    }
	  });

	  if (!acceptorMatched && resp.error) state = 'failure';

	  if (state === 'success') {
	    waiter.setSuccess(resp);
	  } else {
	    waiter.setError(resp, state === 'retry');
	  }
	}

	/**
	 * @api private
	 */
	AWS.ResourceWaiter = inherit({
	  /**
	   * Waits for a given state on a service object
	   * @param service [Service] the service object to wait on
	   * @param state [String] the state (defined in waiter configuration) to wait
	   *   for.
	   * @example Create a waiter for running EC2 instances
	   *   var ec2 = new AWS.EC2;
	   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
	   */
	  constructor: function constructor(service, state) {
	    this.service = service;
	    this.state = state;
	    this.loadWaiterConfig(this.state);
	  },

	  service: null,

	  state: null,

	  config: null,

	  matchers: {
	    path: function(resp, expected, argument) {
	      try {
	        var result = jmespath.search(resp.data, argument);
	      } catch (err) {
	        return false;
	      }

	      return jmespath.strictDeepEqual(result,expected);
	    },

	    pathAll: function(resp, expected, argument) {
	      try {
	        var results = jmespath.search(resp.data, argument);
	      } catch (err) {
	        return false;
	      }

	      if (!Array.isArray(results)) results = [results];
	      var numResults = results.length;
	      if (!numResults) return false;
	      for (var ind = 0 ; ind < numResults; ind++) {
	        if (!jmespath.strictDeepEqual(results[ind], expected)) {
	          return false;
	        }
	      }
	      return true;
	    },

	    pathAny: function(resp, expected, argument) {
	      try {
	        var results = jmespath.search(resp.data, argument);
	      } catch (err) {
	        return false;
	      }

	      if (!Array.isArray(results)) results = [results];
	      var numResults = results.length;
	      for (var ind = 0 ; ind < numResults; ind++) {
	        if (jmespath.strictDeepEqual(results[ind], expected)) {
	          return true;
	        }
	      }
	      return false;
	    },

	    status: function(resp, expected) {
	      var statusCode = resp.httpResponse.statusCode;
	      return (typeof statusCode === 'number') && (statusCode === expected);
	    },

	    error: function(resp, expected) {
	      if (typeof expected === 'string' && resp.error) {
	        return expected === resp.error.code;
	      }
	      // if expected is not string, can be boolean indicating presence of error
	      return expected === !!resp.error;
	    }
	  },

	  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
	    add('RETRY_CHECK', 'retry', function(resp) {
	      var waiter = resp.request._waiter;
	      if (resp.error && resp.error.code === 'ResourceNotReady') {
	        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
	      }
	    });

	    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

	    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
	  }),

	  /**
	   * @return [AWS.Request]
	   */
	  wait: function wait(params, callback) {
	    if (typeof params === 'function') {
	      callback = params; params = undefined;
	    }

	    if (params && params.$waiter) {
	      params = AWS.util.copy(params);
	      if (typeof params.$waiter.delay === 'number') {
	        this.config.delay = params.$waiter.delay;
	      }
	      if (typeof params.$waiter.maxAttempts === 'number') {
	        this.config.maxAttempts = params.$waiter.maxAttempts;
	      }
	      delete params.$waiter;
	    }

	    var request = this.service.makeRequest(this.config.operation, params);
	    request._waiter = this;
	    request.response.maxRetries = this.config.maxAttempts;
	    request.addListeners(this.listeners);

	    if (callback) request.send(callback);
	    return request;
	  },

	  setSuccess: function setSuccess(resp) {
	    resp.error = null;
	    resp.data = resp.data || {};
	    resp.request.removeAllListeners('extractData');
	  },

	  setError: function setError(resp, retryable) {
	    resp.data = null;
	    resp.error = AWS.util.error(resp.error || new Error(), {
	      code: 'ResourceNotReady',
	      message: 'Resource is not in the state ' + this.state,
	      retryable: retryable
	    });
	  },

	  /**
	   * Loads waiter configuration from API configuration
	   *
	   * @api private
	   */
	  loadWaiterConfig: function loadWaiterConfig(state) {
	    if (!this.service.api.waiters[state]) {
	      throw new AWS.util.error(new Error(), {
	        code: 'StateNotFoundError',
	        message: 'State ' + state + ' not found.'
	      });
	    }

	    this.config = AWS.util.copy(this.service.api.waiters[state]);
	  }
	});


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.RequestSigner = inherit({
	  constructor: function RequestSigner(request) {
	    this.request = request;
	  },

	  setServiceClientId: function setServiceClientId(id) {
	    this.serviceClientId = id;
	  },

	  getServiceClientId: function getServiceClientId() {
	    return this.serviceClientId;
	  }
	});

	AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
	  switch (version) {
	    case 'v2': return AWS.Signers.V2;
	    case 'v3': return AWS.Signers.V3;
	    case 'v4': return AWS.Signers.V4;
	    case 's3': return AWS.Signers.S3;
	    case 'v3https': return AWS.Signers.V3Https;
	  }
	  throw new Error('Unknown signing version ' + version);
	};

	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(202);
	__webpack_require__(203);


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
	  addAuthorization: function addAuthorization(credentials, date) {

	    if (!date) date = AWS.util.date.getDate();

	    var r = this.request;

	    r.params.Timestamp = AWS.util.date.iso8601(date);
	    r.params.SignatureVersion = '2';
	    r.params.SignatureMethod = 'HmacSHA256';
	    r.params.AWSAccessKeyId = credentials.accessKeyId;

	    if (credentials.sessionToken) {
	      r.params.SecurityToken = credentials.sessionToken;
	    }

	    delete r.params.Signature; // delete old Signature for re-signing
	    r.params.Signature = this.signature(credentials);

	    r.body = AWS.util.queryParamsToString(r.params);
	    r.headers['Content-Length'] = r.body.length;
	  },

	  signature: function signature(credentials) {
	    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
	  },

	  stringToSign: function stringToSign() {
	    var parts = [];
	    parts.push(this.request.method);
	    parts.push(this.request.endpoint.host.toLowerCase());
	    parts.push(this.request.pathname());
	    parts.push(AWS.util.queryParamsToString(this.request.params));
	    return parts.join('\n');
	  }

	});

	/**
	 * @api private
	 */
	module.exports = AWS.Signers.V2;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
	  addAuthorization: function addAuthorization(credentials, date) {

	    var datetime = AWS.util.date.rfc822(date);

	    this.request.headers['X-Amz-Date'] = datetime;

	    if (credentials.sessionToken) {
	      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
	    }

	    this.request.headers['X-Amzn-Authorization'] =
	      this.authorization(credentials, datetime);

	  },

	  authorization: function authorization(credentials) {
	    return 'AWS3 ' +
	      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
	      'Algorithm=HmacSHA256,' +
	      'SignedHeaders=' + this.signedHeaders() + ',' +
	      'Signature=' + this.signature(credentials);
	  },

	  signedHeaders: function signedHeaders() {
	    var headers = [];
	    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
	      headers.push(h.toLowerCase());
	    });
	    return headers.sort().join(';');
	  },

	  canonicalHeaders: function canonicalHeaders() {
	    var headers = this.request.headers;
	    var parts = [];
	    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
	      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
	    });
	    return parts.sort().join('\n') + '\n';
	  },

	  headersToSign: function headersToSign() {
	    var headers = [];
	    AWS.util.each(this.request.headers, function iterator(k) {
	      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
	        headers.push(k);
	      }
	    });
	    return headers;
	  },

	  signature: function signature(credentials) {
	    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
	  },

	  stringToSign: function stringToSign() {
	    var parts = [];
	    parts.push(this.request.method);
	    parts.push('/');
	    parts.push('');
	    parts.push(this.canonicalHeaders());
	    parts.push(this.request.body);
	    return AWS.util.crypto.sha256(parts.join('\n'));
	  }

	});

	/**
	 * @api private
	 */
	module.exports = AWS.Signers.V3;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;

	__webpack_require__(198);

	/**
	 * @api private
	 */
	AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
	  authorization: function authorization(credentials) {
	    return 'AWS3-HTTPS ' +
	      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
	      'Algorithm=HmacSHA256,' +
	      'Signature=' + this.signature(credentials);
	  },

	  stringToSign: function stringToSign() {
	    return this.request.headers['X-Amz-Date'];
	  }
	});

	/**
	 * @api private
	 */
	module.exports = AWS.Signers.V3Https;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var v4Credentials = __webpack_require__(201);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	var expiresHeader = 'presigned-expires';

	/**
	 * @api private
	 */
	AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
	  constructor: function V4(request, serviceName, options) {
	    AWS.Signers.RequestSigner.call(this, request);
	    this.serviceName = serviceName;
	    options = options || {};
	    this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
	    this.operation = options.operation;
	  },

	  algorithm: 'AWS4-HMAC-SHA256',

	  addAuthorization: function addAuthorization(credentials, date) {
	    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

	    if (this.isPresigned()) {
	      this.updateForPresigned(credentials, datetime);
	    } else {
	      this.addHeaders(credentials, datetime);
	    }

	    this.request.headers['Authorization'] =
	      this.authorization(credentials, datetime);
	  },

	  addHeaders: function addHeaders(credentials, datetime) {
	    this.request.headers['X-Amz-Date'] = datetime;
	    if (credentials.sessionToken) {
	      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
	    }
	  },

	  updateForPresigned: function updateForPresigned(credentials, datetime) {
	    var credString = this.credentialString(datetime);
	    var qs = {
	      'X-Amz-Date': datetime,
	      'X-Amz-Algorithm': this.algorithm,
	      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
	      'X-Amz-Expires': this.request.headers[expiresHeader],
	      'X-Amz-SignedHeaders': this.signedHeaders()
	    };

	    if (credentials.sessionToken) {
	      qs['X-Amz-Security-Token'] = credentials.sessionToken;
	    }

	    if (this.request.headers['Content-Type']) {
	      qs['Content-Type'] = this.request.headers['Content-Type'];
	    }
	    if (this.request.headers['Content-MD5']) {
	      qs['Content-MD5'] = this.request.headers['Content-MD5'];
	    }
	    if (this.request.headers['Cache-Control']) {
	      qs['Cache-Control'] = this.request.headers['Cache-Control'];
	    }

	    // need to pull in any other X-Amz-* headers
	    AWS.util.each.call(this, this.request.headers, function(key, value) {
	      if (key === expiresHeader) return;
	      if (this.isSignableHeader(key)) {
	        var lowerKey = key.toLowerCase();
	        // Metadata should be normalized
	        if (lowerKey.indexOf('x-amz-meta-') === 0) {
	          qs[lowerKey] = value;
	        } else if (lowerKey.indexOf('x-amz-') === 0) {
	          qs[key] = value;
	        }
	      }
	    });

	    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
	    this.request.path += sep + AWS.util.queryParamsToString(qs);
	  },

	  authorization: function authorization(credentials, datetime) {
	    var parts = [];
	    var credString = this.credentialString(datetime);
	    parts.push(this.algorithm + ' Credential=' +
	      credentials.accessKeyId + '/' + credString);
	    parts.push('SignedHeaders=' + this.signedHeaders());
	    parts.push('Signature=' + this.signature(credentials, datetime));
	    return parts.join(', ');
	  },

	  signature: function signature(credentials, datetime) {
	    var signingKey = v4Credentials.getSigningKey(
	      credentials,
	      datetime.substr(0, 8),
	      this.request.region,
	      this.serviceName,
	      this.signatureCache
	    );
	    return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
	  },

	  stringToSign: function stringToSign(datetime) {
	    var parts = [];
	    parts.push('AWS4-HMAC-SHA256');
	    parts.push(datetime);
	    parts.push(this.credentialString(datetime));
	    parts.push(this.hexEncodedHash(this.canonicalString()));
	    return parts.join('\n');
	  },

	  canonicalString: function canonicalString() {
	    var parts = [], pathname = this.request.pathname();
	    if (this.serviceName !== 's3') pathname = AWS.util.uriEscapePath(pathname);

	    parts.push(this.request.method);
	    parts.push(pathname);
	    parts.push(this.request.search());
	    parts.push(this.canonicalHeaders() + '\n');
	    parts.push(this.signedHeaders());
	    parts.push(this.hexEncodedBodyHash());
	    return parts.join('\n');
	  },

	  canonicalHeaders: function canonicalHeaders() {
	    var headers = [];
	    AWS.util.each.call(this, this.request.headers, function (key, item) {
	      headers.push([key, item]);
	    });
	    headers.sort(function (a, b) {
	      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
	    });
	    var parts = [];
	    AWS.util.arrayEach.call(this, headers, function (item) {
	      var key = item[0].toLowerCase();
	      if (this.isSignableHeader(key)) {
	        var value = item[1];
	        if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
	          throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
	            code: 'InvalidHeader'
	          });
	        }
	        parts.push(key + ':' +
	          this.canonicalHeaderValues(value.toString()));
	      }
	    });
	    return parts.join('\n');
	  },

	  canonicalHeaderValues: function canonicalHeaderValues(values) {
	    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
	  },

	  signedHeaders: function signedHeaders() {
	    var keys = [];
	    AWS.util.each.call(this, this.request.headers, function (key) {
	      key = key.toLowerCase();
	      if (this.isSignableHeader(key)) keys.push(key);
	    });
	    return keys.sort().join(';');
	  },

	  credentialString: function credentialString(datetime) {
	    return v4Credentials.createScope(
	      datetime.substr(0, 8),
	      this.request.region,
	      this.serviceName
	    );
	  },

	  hexEncodedHash: function hash(string) {
	    return AWS.util.crypto.sha256(string, 'hex');
	  },

	  hexEncodedBodyHash: function hexEncodedBodyHash() {
	    var request = this.request;
	    if (this.isPresigned() && this.serviceName === 's3' && !request.body) {
	      return 'UNSIGNED-PAYLOAD';
	    } else if (request.headers['X-Amz-Content-Sha256']) {
	      return request.headers['X-Amz-Content-Sha256'];
	    } else {
	      return this.hexEncodedHash(this.request.body || '');
	    }
	  },

	  unsignableHeaders: [
	    'authorization',
	    'content-type',
	    'content-length',
	    'user-agent',
	    expiresHeader,
	    'expect',
	    'x-amzn-trace-id'
	  ],

	  isSignableHeader: function isSignableHeader(key) {
	    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
	    return this.unsignableHeaders.indexOf(key) < 0;
	  },

	  isPresigned: function isPresigned() {
	    return this.request.headers[expiresHeader] ? true : false;
	  }

	});

	/**
	 * @api private
	 */
	module.exports = AWS.Signers.V4;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * @api private
	 */
	var cachedSecret = {};

	/**
	 * @api private
	 */
	var cacheQueue = [];

	/**
	 * @api private
	 */
	var maxCacheEntries = 50;

	/**
	 * @api private
	 */
	var v4Identifier = 'aws4_request';

	/**
	 * @api private
	 */
	module.exports = {
	  /**
	   * @api private
	   *
	   * @param date [String]
	   * @param region [String]
	   * @param serviceName [String]
	   * @return [String]
	   */
	  createScope: function createScope(date, region, serviceName) {
	    return [
	      date.substr(0, 8),
	      region,
	      serviceName,
	      v4Identifier
	    ].join('/');
	  },

	  /**
	   * @api private
	   *
	   * @param credentials [Credentials]
	   * @param date [String]
	   * @param region [String]
	   * @param service [String]
	   * @param shouldCache [Boolean]
	   * @return [String]
	   */
	  getSigningKey: function getSigningKey(
	    credentials,
	    date,
	    region,
	    service,
	    shouldCache
	  ) {
	    var credsIdentifier = AWS.util.crypto
	      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
	    var cacheKey = [credsIdentifier, date, region, service].join('_');
	    shouldCache = shouldCache !== false;
	    if (shouldCache && (cacheKey in cachedSecret)) {
	      return cachedSecret[cacheKey];
	    }

	    var kDate = AWS.util.crypto.hmac(
	      'AWS4' + credentials.secretAccessKey,
	      date,
	      'buffer'
	    );
	    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
	    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');

	    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');
	    if (shouldCache) {
	      cachedSecret[cacheKey] = signingKey;
	      cacheQueue.push(cacheKey);
	      if (cacheQueue.length > maxCacheEntries) {
	        // remove the oldest entry (not the least recently used)
	        delete cachedSecret[cacheQueue.shift()];
	      }
	    }

	    return signingKey;
	  },

	  /**
	   * @api private
	   *
	   * Empties the derived signing key cache. Made available for testing purposes
	   * only.
	   */
	  emptyCache: function emptyCache() {
	    cachedSecret = {};
	    cacheQueue = [];
	  }
	};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
	  /**
	   * When building the stringToSign, these sub resource params should be
	   * part of the canonical resource string with their NON-decoded values
	   */
	  subResources: {
	    'acl': 1,
	    'accelerate': 1,
	    'analytics': 1,
	    'cors': 1,
	    'lifecycle': 1,
	    'delete': 1,
	    'inventory': 1,
	    'location': 1,
	    'logging': 1,
	    'metrics': 1,
	    'notification': 1,
	    'partNumber': 1,
	    'policy': 1,
	    'requestPayment': 1,
	    'replication': 1,
	    'restore': 1,
	    'tagging': 1,
	    'torrent': 1,
	    'uploadId': 1,
	    'uploads': 1,
	    'versionId': 1,
	    'versioning': 1,
	    'versions': 1,
	    'website': 1
	  },

	  // when building the stringToSign, these querystring params should be
	  // part of the canonical resource string with their NON-encoded values
	  responseHeaders: {
	    'response-content-type': 1,
	    'response-content-language': 1,
	    'response-expires': 1,
	    'response-cache-control': 1,
	    'response-content-disposition': 1,
	    'response-content-encoding': 1
	  },

	  addAuthorization: function addAuthorization(credentials, date) {
	    if (!this.request.headers['presigned-expires']) {
	      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
	    }

	    if (credentials.sessionToken) {
	      // presigned URLs require this header to be lowercased
	      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
	    }

	    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
	    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

	    this.request.headers['Authorization'] = auth;
	  },

	  stringToSign: function stringToSign() {
	    var r = this.request;

	    var parts = [];
	    parts.push(r.method);
	    parts.push(r.headers['Content-MD5'] || '');
	    parts.push(r.headers['Content-Type'] || '');

	    // This is the "Date" header, but we use X-Amz-Date.
	    // The S3 signing mechanism requires us to pass an empty
	    // string for this Date header regardless.
	    parts.push(r.headers['presigned-expires'] || '');

	    var headers = this.canonicalizedAmzHeaders();
	    if (headers) parts.push(headers);
	    parts.push(this.canonicalizedResource());

	    return parts.join('\n');

	  },

	  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

	    var amzHeaders = [];

	    AWS.util.each(this.request.headers, function (name) {
	      if (name.match(/^x-amz-/i))
	        amzHeaders.push(name);
	    });

	    amzHeaders.sort(function (a, b) {
	      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
	    });

	    var parts = [];
	    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
	      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
	    });

	    return parts.join('\n');

	  },

	  canonicalizedResource: function canonicalizedResource() {

	    var r = this.request;

	    var parts = r.path.split('?');
	    var path = parts[0];
	    var querystring = parts[1];

	    var resource = '';

	    if (r.virtualHostedBucket)
	      resource += '/' + r.virtualHostedBucket;

	    resource += path;

	    if (querystring) {

	      // collect a list of sub resources and query params that need to be signed
	      var resources = [];

	      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
	        var name = param.split('=')[0];
	        var value = param.split('=')[1];
	        if (this.subResources[name] || this.responseHeaders[name]) {
	          var subresource = { name: name };
	          if (value !== undefined) {
	            if (this.subResources[name]) {
	              subresource.value = value;
	            } else {
	              subresource.value = decodeURIComponent(value);
	            }
	          }
	          resources.push(subresource);
	        }
	      });

	      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

	      if (resources.length) {

	        querystring = [];
	        AWS.util.arrayEach(resources, function (res) {
	          if (res.value === undefined) {
	            querystring.push(res.name);
	          } else {
	            querystring.push(res.name + '=' + res.value);
	          }
	        });

	        resource += '?' + querystring.join('&');
	      }

	    }

	    return resource;

	  },

	  sign: function sign(secret, string) {
	    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
	  }
	});

	/**
	 * @api private
	 */
	module.exports = AWS.Signers.S3;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var inherit = AWS.util.inherit;

	/**
	 * @api private
	 */
	var expiresHeader = 'presigned-expires';

	/**
	 * @api private
	 */
	function signedUrlBuilder(request) {
	  var expires = request.httpRequest.headers[expiresHeader];
	  var signerClass = request.service.getSignerClass(request);

	  delete request.httpRequest.headers['User-Agent'];
	  delete request.httpRequest.headers['X-Amz-User-Agent'];

	  if (signerClass === AWS.Signers.V4) {
	    if (expires > 604800) { // one week expiry is invalid
	      var message = 'Presigning does not support expiry time greater ' +
	                    'than a week with SigV4 signing.';
	      throw AWS.util.error(new Error(), {
	        code: 'InvalidExpiryTime', message: message, retryable: false
	      });
	    }
	    request.httpRequest.headers[expiresHeader] = expires;
	  } else if (signerClass === AWS.Signers.S3) {
	    var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();
	    request.httpRequest.headers[expiresHeader] = parseInt(
	      AWS.util.date.unixTimestamp(now) + expires, 10).toString();
	  } else {
	    throw AWS.util.error(new Error(), {
	      message: 'Presigning only supports S3 or SigV4 signing.',
	      code: 'UnsupportedSigner', retryable: false
	    });
	  }
	}

	/**
	 * @api private
	 */
	function signedUrlSigner(request) {
	  var endpoint = request.httpRequest.endpoint;
	  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
	  var queryParams = {};

	  if (parsedUrl.search) {
	    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
	  }

	  var auth = request.httpRequest.headers['Authorization'].split(' ');
	  if (auth[0] === 'AWS') {
	    auth = auth[1].split(':');
	    queryParams['AWSAccessKeyId'] = auth[0];
	    queryParams['Signature'] = auth[1];

	    AWS.util.each(request.httpRequest.headers, function (key, value) {
	      if (key === expiresHeader) key = 'Expires';
	      if (key.indexOf('x-amz-meta-') === 0) {
	        // Delete existing, potentially not normalized key
	        delete queryParams[key];
	        key = key.toLowerCase();
	      }
	      queryParams[key] = value;
	    });
	    delete request.httpRequest.headers[expiresHeader];
	    delete queryParams['Authorization'];
	    delete queryParams['Host'];
	  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
	    auth.shift();
	    var rest = auth.join(' ');
	    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
	    queryParams['X-Amz-Signature'] = signature;
	    delete queryParams['Expires'];
	  }

	  // build URL
	  endpoint.pathname = parsedUrl.pathname;
	  endpoint.search = AWS.util.queryParamsToString(queryParams);
	}

	/**
	 * @api private
	 */
	AWS.Signers.Presign = inherit({
	  /**
	   * @api private
	   */
	  sign: function sign(request, expireTime, callback) {
	    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
	    request.on('build', signedUrlBuilder);
	    request.on('sign', signedUrlSigner);
	    request.removeListener('afterBuild',
	      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
	    request.removeListener('afterBuild',
	      AWS.EventListeners.Core.COMPUTE_SHA256);

	    request.emit('beforePresign', [request]);

	    if (callback) {
	      request.build(function() {
	        if (this.response.error) callback(this.response.error);
	        else {
	          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
	        }
	      });
	    } else {
	      request.build();
	      if (request.response.error) throw request.response.error;
	      return AWS.util.urlFormat(request.httpRequest.endpoint);
	    }
	  }
	});

	/**
	 * @api private
	 */
	module.exports = AWS.Signers.Presign;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * @api private
	 */
	AWS.ParamValidator = AWS.util.inherit({
	  /**
	   * Create a new validator object.
	   *
	   * @param validation [Boolean|map] whether input parameters should be
	   *     validated against the operation description before sending the
	   *     request. Pass a map to enable any of the following specific
	   *     validation features:
	   *
	   *     * **min** [Boolean] &mdash; Validates that a value meets the min
	   *       constraint. This is enabled by default when paramValidation is set
	   *       to `true`.
	   *     * **max** [Boolean] &mdash; Validates that a value meets the max
	   *       constraint.
	   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
	   *       regular expression.
	   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
	   *       of the allowable enum values.
	   */
	  constructor: function ParamValidator(validation) {
	    if (validation === true || validation === undefined) {
	      validation = {'min': true};
	    }
	    this.validation = validation;
	  },

	  validate: function validate(shape, params, context) {
	    this.errors = [];
	    this.validateMember(shape, params || {}, context || 'params');

	    if (this.errors.length > 1) {
	      var msg = this.errors.join('\n* ');
	      msg = 'There were ' + this.errors.length +
	        ' validation errors:\n* ' + msg;
	      throw AWS.util.error(new Error(msg),
	        {code: 'MultipleValidationErrors', errors: this.errors});
	    } else if (this.errors.length === 1) {
	      throw this.errors[0];
	    } else {
	      return true;
	    }
	  },

	  fail: function fail(code, message) {
	    this.errors.push(AWS.util.error(new Error(message), {code: code}));
	  },

	  validateStructure: function validateStructure(shape, params, context) {
	    this.validateType(params, context, ['object'], 'structure');

	    var paramName;
	    for (var i = 0; shape.required && i < shape.required.length; i++) {
	      paramName = shape.required[i];
	      var value = params[paramName];
	      if (value === undefined || value === null) {
	        this.fail('MissingRequiredParameter',
	          'Missing required key \'' + paramName + '\' in ' + context);
	      }
	    }

	    // validate hash members
	    for (paramName in params) {
	      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

	      var paramValue = params[paramName],
	          memberShape = shape.members[paramName];

	      if (memberShape !== undefined) {
	        var memberContext = [context, paramName].join('.');
	        this.validateMember(memberShape, paramValue, memberContext);
	      } else {
	        this.fail('UnexpectedParameter',
	          'Unexpected key \'' + paramName + '\' found in ' + context);
	      }
	    }

	    return true;
	  },

	  validateMember: function validateMember(shape, param, context) {
	    switch (shape.type) {
	      case 'structure':
	        return this.validateStructure(shape, param, context);
	      case 'list':
	        return this.validateList(shape, param, context);
	      case 'map':
	        return this.validateMap(shape, param, context);
	      default:
	        return this.validateScalar(shape, param, context);
	    }
	  },

	  validateList: function validateList(shape, params, context) {
	    if (this.validateType(params, context, [Array])) {
	      this.validateRange(shape, params.length, context, 'list member count');
	      // validate array members
	      for (var i = 0; i < params.length; i++) {
	        this.validateMember(shape.member, params[i], context + '[' + i + ']');
	      }
	    }
	  },

	  validateMap: function validateMap(shape, params, context) {
	    if (this.validateType(params, context, ['object'], 'map')) {
	      // Build up a count of map members to validate range traits.
	      var mapCount = 0;
	      for (var param in params) {
	        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
	        // Validate any map key trait constraints
	        this.validateMember(shape.key, param,
	                            context + '[key=\'' + param + '\']')
	        this.validateMember(shape.value, params[param],
	                            context + '[\'' + param + '\']');
	        mapCount++;
	      }
	      this.validateRange(shape, mapCount, context, 'map member count');
	    }
	  },

	  validateScalar: function validateScalar(shape, value, context) {
	    switch (shape.type) {
	      case null:
	      case undefined:
	      case 'string':
	        return this.validateString(shape, value, context);
	      case 'base64':
	      case 'binary':
	        return this.validatePayload(value, context);
	      case 'integer':
	      case 'float':
	        return this.validateNumber(shape, value, context);
	      case 'boolean':
	        return this.validateType(value, context, ['boolean']);
	      case 'timestamp':
	        return this.validateType(value, context, [Date,
	          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
	          'Date object, ISO-8601 string, or a UNIX timestamp');
	      default:
	        return this.fail('UnkownType', 'Unhandled type ' +
	                         shape.type + ' for ' + context);
	    }
	  },

	  validateString: function validateString(shape, value, context) {
	    var validTypes = ['string'];
	    if (shape.isJsonValue) {
	      validTypes = validTypes.concat(['number', 'object', 'boolean']);
	    }
	    if (value !== null && this.validateType(value, context, validTypes)) {
	      this.validateEnum(shape, value, context);
	      this.validateRange(shape, value.length, context, 'string length');
	      this.validatePattern(shape, value, context);
	      this.validateUri(shape, value, context);
	    }
	  },

	  validateUri: function validateUri(shape, value, context) {
	    if (shape['location'] === 'uri') {
	      if (value.length === 0) {
	        this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,'
	          + ' but found "' + value +'" for ' + context);
	      }
	    }
	  },

	  validatePattern: function validatePattern(shape, value, context) {
	    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
	      if (!(new RegExp(shape['pattern'])).test(value)) {
	        this.fail('PatternMatchError', 'Provided value "' + value + '" '
	          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
	          + context);
	      }
	    }
	  },

	  validateRange: function validateRange(shape, value, context, descriptor) {
	    if (this.validation['min']) {
	      if (shape['min'] !== undefined && value < shape['min']) {
	        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
	          + shape['min'] + ', but found ' + value + ' for ' + context);
	      }
	    }
	    if (this.validation['max']) {
	      if (shape['max'] !== undefined && value > shape['max']) {
	        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
	          + shape['max'] + ', but found ' + value + ' for ' + context);
	      }
	    }
	  },

	  validateEnum: function validateRange(shape, value, context) {
	    if (this.validation['enum'] && shape['enum'] !== undefined) {
	      // Fail if the string value is not present in the enum list
	      if (shape['enum'].indexOf(value) === -1) {
	        this.fail('EnumError', 'Found string value of ' + value + ', but '
	          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
	      }
	    }
	  },

	  validateType: function validateType(value, context, acceptedTypes, type) {
	    // We will not log an error for null or undefined, but we will return
	    // false so that callers know that the expected type was not strictly met.
	    if (value === null || value === undefined) return false;

	    var foundInvalidType = false;
	    for (var i = 0; i < acceptedTypes.length; i++) {
	      if (typeof acceptedTypes[i] === 'string') {
	        if (typeof value === acceptedTypes[i]) return true;
	      } else if (acceptedTypes[i] instanceof RegExp) {
	        if ((value || '').toString().match(acceptedTypes[i])) return true;
	      } else {
	        if (value instanceof acceptedTypes[i]) return true;
	        if (AWS.util.isType(value, acceptedTypes[i])) return true;
	        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
	        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
	      }
	      foundInvalidType = true;
	    }

	    var acceptedType = type;
	    if (!acceptedType) {
	      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
	    }

	    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
	    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
	              vowel + ' ' + acceptedType);
	    return false;
	  },

	  validateNumber: function validateNumber(shape, value, context) {
	    if (value === null || value === undefined) return;
	    if (typeof value === 'string') {
	      var castedValue = parseFloat(value);
	      if (castedValue.toString() === value) value = castedValue;
	    }
	    if (this.validateType(value, context, ['number'])) {
	      this.validateRange(shape, value, context, 'numeric value');
	    }
	  },

	  validatePayload: function validatePayload(value, context) {
	    if (value === null || value === undefined) return;
	    if (typeof value === 'string') return;
	    if (value && typeof value.byteLength === 'number') return; // typed arrays
	    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
	      var Stream = AWS.util.stream.Stream;
	      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
	    } else {
	      if (typeof Blob !== void 0 && value instanceof Blob) return;
	    }

	    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
	    if (value) {
	      for (var i = 0; i < types.length; i++) {
	        if (AWS.util.isType(value, types[i])) return;
	        if (AWS.util.typeName(value.constructor) === types[i]) return;
	      }
	    }

	    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
	      'string, Buffer, Stream, Blob, or typed array object');
	  }
	});


/***/ }),
/* 205 */
/***/ (function(module, exports) {

	module.exports = require("fs");

/***/ }),
/* 206 */
/***/ (function(module, exports) {

	module.exports = {"acm":{"name":"ACM","cors":true},"apigateway":{"name":"APIGateway","cors":true},"applicationautoscaling":{"prefix":"application-autoscaling","name":"ApplicationAutoScaling","cors":true},"appstream":{"name":"AppStream"},"autoscaling":{"name":"AutoScaling","cors":true},"batch":{"name":"Batch"},"budgets":{"name":"Budgets"},"clouddirectory":{"name":"CloudDirectory","versions":["2016-05-10*"]},"cloudformation":{"name":"CloudFormation","cors":true},"cloudfront":{"name":"CloudFront","versions":["2013-05-12*","2013-11-11*","2014-05-31*","2014-10-21*","2014-11-06*","2015-04-17*","2015-07-27*","2015-09-17*","2016-01-13*","2016-01-28*","2016-08-01*","2016-08-20*","2016-09-07*","2016-09-29*","2016-11-25*","2017-03-25*","2017-10-30*"],"cors":true},"cloudhsm":{"name":"CloudHSM","cors":true},"cloudsearch":{"name":"CloudSearch"},"cloudsearchdomain":{"name":"CloudSearchDomain"},"cloudtrail":{"name":"CloudTrail","cors":true},"cloudwatch":{"prefix":"monitoring","name":"CloudWatch","cors":true},"cloudwatchevents":{"prefix":"events","name":"CloudWatchEvents","versions":["2014-02-03*"],"cors":true},"cloudwatchlogs":{"prefix":"logs","name":"CloudWatchLogs","cors":true},"codebuild":{"name":"CodeBuild","cors":true},"codecommit":{"name":"CodeCommit","cors":true},"codedeploy":{"name":"CodeDeploy","cors":true},"codepipeline":{"name":"CodePipeline","cors":true},"cognitoidentity":{"prefix":"cognito-identity","name":"CognitoIdentity","cors":true},"cognitoidentityserviceprovider":{"prefix":"cognito-idp","name":"CognitoIdentityServiceProvider","cors":true},"cognitosync":{"prefix":"cognito-sync","name":"CognitoSync","cors":true},"configservice":{"prefix":"config","name":"ConfigService","cors":true},"cur":{"name":"CUR","cors":true},"datapipeline":{"name":"DataPipeline"},"devicefarm":{"name":"DeviceFarm","cors":true},"directconnect":{"name":"DirectConnect","cors":true},"directoryservice":{"prefix":"ds","name":"DirectoryService"},"discovery":{"name":"Discovery"},"dms":{"name":"DMS"},"dynamodb":{"name":"DynamoDB","cors":true},"dynamodbstreams":{"prefix":"streams.dynamodb","name":"DynamoDBStreams","cors":true},"ec2":{"name":"EC2","versions":["2013-06-15*","2013-10-15*","2014-02-01*","2014-05-01*","2014-06-15*","2014-09-01*","2014-10-01*","2015-03-01*","2015-04-15*","2015-10-01*","2016-04-01*","2016-09-15*"],"cors":true},"ecr":{"name":"ECR","cors":true},"ecs":{"name":"ECS","cors":true},"efs":{"prefix":"elasticfilesystem","name":"EFS","cors":true},"elasticache":{"name":"ElastiCache","versions":["2012-11-15*","2014-03-24*","2014-07-15*","2014-09-30*"],"cors":true},"elasticbeanstalk":{"name":"ElasticBeanstalk","cors":true},"elb":{"prefix":"elasticloadbalancing","name":"ELB","cors":true},"elbv2":{"prefix":"elasticloadbalancingv2","name":"ELBv2","cors":true},"emr":{"prefix":"elasticmapreduce","name":"EMR","cors":true},"es":{"name":"ES"},"elastictranscoder":{"name":"ElasticTranscoder","cors":true},"firehose":{"name":"Firehose","cors":true},"gamelift":{"name":"GameLift","cors":true},"glacier":{"name":"Glacier"},"health":{"name":"Health"},"iam":{"name":"IAM"},"importexport":{"name":"ImportExport"},"inspector":{"name":"Inspector","versions":["2015-08-18*"],"cors":true},"iot":{"name":"Iot","cors":true},"iotdata":{"prefix":"iot-data","name":"IotData","cors":true},"kinesis":{"name":"Kinesis","cors":true},"kinesisanalytics":{"name":"KinesisAnalytics"},"kms":{"name":"KMS","cors":true},"lambda":{"name":"Lambda","cors":true},"lexruntime":{"prefix":"runtime.lex","name":"LexRuntime","cors":true},"lightsail":{"name":"Lightsail"},"machinelearning":{"name":"MachineLearning","cors":true},"marketplacecommerceanalytics":{"name":"MarketplaceCommerceAnalytics","cors":true},"marketplacemetering":{"prefix":"meteringmarketplace","name":"MarketplaceMetering"},"mturk":{"prefix":"mturk-requester","name":"MTurk","cors":true},"mobileanalytics":{"name":"MobileAnalytics","cors":true},"opsworks":{"name":"OpsWorks","cors":true},"opsworkscm":{"name":"OpsWorksCM"},"organizations":{"name":"Organizations"},"pinpoint":{"name":"Pinpoint"},"polly":{"name":"Polly","cors":true},"rds":{"name":"RDS","versions":["2014-09-01*"],"cors":true},"redshift":{"name":"Redshift","cors":true},"rekognition":{"name":"Rekognition","cors":true},"resourcegroupstaggingapi":{"name":"ResourceGroupsTaggingAPI"},"route53":{"name":"Route53","cors":true},"route53domains":{"name":"Route53Domains","cors":true},"s3":{"name":"S3","dualstackAvailable":true,"cors":true},"servicecatalog":{"name":"ServiceCatalog","cors":true},"ses":{"prefix":"email","name":"SES","cors":true},"shield":{"name":"Shield"},"simpledb":{"prefix":"sdb","name":"SimpleDB"},"sms":{"name":"SMS"},"snowball":{"name":"Snowball"},"sns":{"name":"SNS","cors":true},"sqs":{"name":"SQS","cors":true},"ssm":{"name":"SSM","cors":true},"storagegateway":{"name":"StorageGateway","cors":true},"stepfunctions":{"prefix":"states","name":"StepFunctions"},"sts":{"name":"STS","cors":true},"support":{"name":"Support"},"swf":{"name":"SWF"},"xray":{"name":"XRay"},"waf":{"name":"WAF","cors":true},"wafregional":{"prefix":"waf-regional","name":"WAFRegional"},"workdocs":{"name":"WorkDocs","cors":true},"workspaces":{"name":"WorkSpaces"},"codestar":{"name":"CodeStar"},"lexmodelbuildingservice":{"prefix":"lex-models","name":"LexModelBuildingService","cors":true},"marketplaceentitlementservice":{"prefix":"entitlement.marketplace","name":"MarketplaceEntitlementService"},"athena":{"name":"Athena"},"greengrass":{"name":"Greengrass"},"dax":{"name":"DAX"},"migrationhub":{"prefix":"AWSMigrationHub","name":"MigrationHub"},"cloudhsmv2":{"name":"CloudHSMV2"},"glue":{"name":"Glue"},"mobile":{"name":"Mobile"},"pricing":{"name":"Pricing","cors":true},"costexplorer":{"prefix":"ce","name":"CostExplorer"},"mediaconvert":{"name":"MediaConvert"},"medialive":{"name":"MediaLive"},"mediapackage":{"name":"MediaPackage"},"mediastore":{"name":"MediaStore"},"mediastoredata":{"prefix":"mediastore-data","name":"MediaStoreData"},"appsync":{"name":"AppSync"},"guardduty":{"name":"GuardDuty"},"mq":{"name":"MQ"},"comprehend":{"name":"Comprehend"},"iotjobsdataplane":{"prefix":"iot-jobs-data","name":"IoTJobsDataPlane"},"kinesisvideoarchivedmedia":{"prefix":"kinesis-video-archived-media","name":"KinesisVideoArchivedMedia","cors":true},"kinesisvideomedia":{"prefix":"kinesis-video-media","name":"KinesisVideoMedia"},"kinesisvideo":{"name":"KinesisVideo","cors":true},"sagemakerruntime":{"prefix":"runtime.sagemaker","name":"SageMakerRuntime"},"sagemaker":{"name":"SageMaker"},"translate":{"name":"Translate","cors":true},"resourcegroups":{"prefix":"resource-groups","name":"ResourceGroups"},"alexaforbusiness":{"name":"AlexaForBusiness"},"cloud9":{"name":"Cloud9"},"serverlessapplicationrepository":{"prefix":"serverlessrepo","name":"ServerlessApplicationRepository"},"servicediscovery":{"name":"ServiceDiscovery"},"workmail":{"name":"WorkMail"},"autoscalingplans":{"prefix":"autoscaling-plans","name":"AutoScalingPlans"},"transcribeservice":{"prefix":"transcribe","name":"TranscribeService"},"connect":{"name":"Connect"},"acmpca":{"prefix":"acm-pca","name":"ACMPCA"},"fms":{"name":"FMS"},"secretsmanager":{"name":"SecretsManager","cors":true},"iotanalytics":{"name":"IoTAnalytics"},"iot1clickdevicesservice":{"prefix":"iot1click-devices","name":"IoT1ClickDevicesService"},"iot1clickprojects":{"prefix":"iot1click-projects","name":"IoT1ClickProjects"},"pi":{"name":"PI"},"neptune":{"name":"Neptune"},"mediatailor":{"name":"MediaTailor"},"eks":{"name":"EKS"},"macie":{"name":"Macie"},"dlm":{"name":"DLM"},"signer":{"name":"Signer"}}

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	var v1 = __webpack_require__(208);
	var v4 = __webpack_require__(212);

	var uuid = v4;
	uuid.v1 = v1;
	uuid.v4 = v4;

	module.exports = uuid;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	var rng = __webpack_require__(209);
	var bytesToUuid = __webpack_require__(211);

	// **`v1()` - Generate time-based UUID**
	//
	// Inspired by https://github.com/LiosK/UUID.js
	// and http://docs.python.org/library/uuid.html

	// random #'s we need to init node and clockseq
	var _seedBytes = rng();

	// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	var _nodeId = [
	  _seedBytes[0] | 0x01,
	  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	];

	// Per 4.2.2, randomize (14 bit) clockseq
	var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	// Previous uuid creation time
	var _lastMSecs = 0, _lastNSecs = 0;

	// See https://github.com/broofa/node-uuid for API details
	function v1(options, buf, offset) {
	  var i = buf && offset || 0;
	  var b = buf || [];

	  options = options || {};

	  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

	  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

	  // Per 4.2.1.2, use count of uuid's generated during the current clock
	  // cycle to simulate higher resolution clock
	  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

	  // Time since last uuid creation (in msecs)
	  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	  // Per 4.2.1.2, Bump clockseq on clock regression
	  if (dt < 0 && options.clockseq === undefined) {
	    clockseq = clockseq + 1 & 0x3fff;
	  }

	  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	  // time interval
	  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
	    nsecs = 0;
	  }

	  // Per 4.2.1.2 Throw error if too many uuids are requested
	  if (nsecs >= 10000) {
	    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	  }

	  _lastMSecs = msecs;
	  _lastNSecs = nsecs;
	  _clockseq = clockseq;

	  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	  msecs += 12219292800000;

	  // `time_low`
	  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	  b[i++] = tl >>> 24 & 0xff;
	  b[i++] = tl >>> 16 & 0xff;
	  b[i++] = tl >>> 8 & 0xff;
	  b[i++] = tl & 0xff;

	  // `time_mid`
	  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	  b[i++] = tmh >>> 8 & 0xff;
	  b[i++] = tmh & 0xff;

	  // `time_high_and_version`
	  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	  b[i++] = tmh >>> 16 & 0xff;

	  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	  b[i++] = clockseq >>> 8 | 0x80;

	  // `clock_seq_low`
	  b[i++] = clockseq & 0xff;

	  // `node`
	  var node = options.node || _nodeId;
	  for (var n = 0; n < 6; ++n) {
	    b[i + n] = node[n];
	  }

	  return buf ? buf : bytesToUuid(b);
	}

	module.exports = v1;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	// Unique ID creation requires a high quality random # generator.  In node.js
	// this is pretty straight-forward - we use the crypto API.

	var rb = __webpack_require__(210).randomBytes;

	function rng() {
	  return rb(16);
	}

	module.exports = rng;


/***/ }),
/* 210 */
/***/ (function(module, exports) {

	module.exports = require("crypto");

/***/ }),
/* 211 */
/***/ (function(module, exports) {

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */
	var byteToHex = [];
	for (var i = 0; i < 256; ++i) {
	  byteToHex[i] = (i + 0x100).toString(16).substr(1);
	}

	function bytesToUuid(buf, offset) {
	  var i = offset || 0;
	  var bth = byteToHex;
	  return bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]];
	}

	module.exports = bytesToUuid;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	var rng = __webpack_require__(209);
	var bytesToUuid = __webpack_require__(211);

	function v4(options, buf, offset) {
	  var i = buf && offset || 0;

	  if (typeof(options) == 'string') {
	    buf = options == 'binary' ? new Array(16) : null;
	    options = null;
	  }
	  options = options || {};

	  var rnds = options.random || (options.rng || rng)();

	  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	  rnds[6] = (rnds[6] & 0x0f) | 0x40;
	  rnds[8] = (rnds[8] & 0x3f) | 0x80;

	  // Copy bytes to buffer, if provided
	  if (buf) {
	    for (var ii = 0; ii < 16; ++ii) {
	      buf[i + ii] = rnds[ii];
	    }
	  }

	  return buf || bytesToUuid(rnds);
	}

	module.exports = v4;


/***/ }),
/* 213 */
/***/ (function(module, exports) {

	module.exports = require("buffer");

/***/ }),
/* 214 */
/***/ (function(module, exports) {

	module.exports = require("domain");

/***/ }),
/* 215 */
/***/ (function(module, exports) {

	module.exports = require("stream");

/***/ }),
/* 216 */
/***/ (function(module, exports) {

	module.exports = require("url");

/***/ }),
/* 217 */
/***/ (function(module, exports) {

	module.exports = require("querystring");

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * What is necessary to create an event stream in node?
	 *  - http response stream
	 *  - parser
	 *  - event stream model
	 */

	var EventMessageChunkerStream = __webpack_require__(219).EventMessageChunkerStream;
	var EventUnmarshallerStream = __webpack_require__(221).EventUnmarshallerStream;

	function createEventStream(stream, parser, model) {
	    var eventStream = new EventUnmarshallerStream({
	        parser: parser,
	        eventStreamModel: model
	    });

	    var eventMessageChunker = new EventMessageChunkerStream();

	    stream.pipe(
	        eventMessageChunker
	    ).pipe(eventStream);

	    stream.on('error', function(err) {
	        eventMessageChunker.emit('error', err);
	    });

	    eventMessageChunker.on('error', function(err) {
	        eventStream.emit('error', err);
	    });

	    return eventStream;
	}

	/**
	 * @api private
	 */
	module.exports = {
	    createEventStream: createEventStream
	};

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	var Transform = __webpack_require__(215).Transform;
	var allocBuffer = __webpack_require__(220).allocBuffer;

	/** @type {Transform} */
	function EventMessageChunkerStream(options) {
	    Transform.call(this, options);

	    this.currentMessageTotalLength = 0;
	    this.currentMessagePendingLength = 0;
	    /** @type {Buffer} */
	    this.currentMessage = null;

	    /** @type {Buffer} */
	    this.messageLengthBuffer = null;
	}

	EventMessageChunkerStream.prototype = Object.create(Transform.prototype);

	/**
	 *
	 * @param {Buffer} chunk
	 * @param {string} encoding
	 * @param {*} callback
	 */
	EventMessageChunkerStream.prototype._transform = function(chunk, encoding, callback) {
	    var chunkLength = chunk.length;
	    var currentOffset = 0;

	    while (currentOffset < chunkLength) {
	        // create new message if necessary
	        if (!this.currentMessage) {
	            // working on a new message, determine total length
	            var bytesRemaining = chunkLength - currentOffset;
	            // prevent edge case where total length spans 2 chunks
	            if (!this.messageLengthBuffer) {
	                this.messageLengthBuffer = allocBuffer(4);
	            }
	            var numBytesForTotal = Math.min(
	                4 - this.currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer
	                bytesRemaining // bytes left in chunk
	            );

	            chunk.copy(
	                this.messageLengthBuffer,
	                this.currentMessagePendingLength,
	                currentOffset,
	                currentOffset + numBytesForTotal
	            );

	            this.currentMessagePendingLength += numBytesForTotal;
	            currentOffset += numBytesForTotal;

	            if (this.currentMessagePendingLength < 4) {
	                // not enough information to create the current message
	                break;
	            }
	            this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));
	            this.messageLengthBuffer = null;
	        }

	        // write data into current message
	        var numBytesToWrite = Math.min(
	            this.currentMessageTotalLength - this.currentMessagePendingLength, // number of bytes left to complete message
	            chunkLength - currentOffset // number of bytes left in the original chunk
	        );
	        chunk.copy(
	            this.currentMessage, // target buffer
	            this.currentMessagePendingLength, // target offset
	            currentOffset, // chunk offset
	            currentOffset + numBytesToWrite // chunk end to write
	        );
	        this.currentMessagePendingLength += numBytesToWrite;
	        currentOffset += numBytesToWrite;

	        // check if a message is ready to be pushed
	        if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {
	            // push out the message
	            this.push(this.currentMessage);
	            // cleanup
	            this.currentMessage = null;
	            this.currentMessageTotalLength = 0;
	            this.currentMessagePendingLength = 0;
	        }
	    }

	    callback();
	};

	EventMessageChunkerStream.prototype._flush = function(callback) {
	    if (this.currentMessageTotalLength) {
	        if (this.currentMessageTotalLength === this.currentMessagePendingLength) {
	            callback(null, this.currentMessage);
	        } else {
	            callback(new Error('Truncated event message received.'));
	        }
	    } else {
	        callback();
	    }
	}

	/**
	 * @param {number} size Size of the message to be allocated.
	 * @api private
	 */
	EventMessageChunkerStream.prototype.allocateMessage = function(size) {
	    if (typeof size !== 'number') {
	        throw new Error('Attempted to allocate an event message where size was not a number: ' + size);
	    }
	    this.currentMessageTotalLength = size;
	    this.currentMessagePendingLength = 4;
	    this.currentMessage = allocBuffer(size);
	    this.currentMessage.writeUInt32BE(size, 0);
	};

	/**
	 * @api private
	 */
	module.exports = {
	    EventMessageChunkerStream: EventMessageChunkerStream
	};

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(160).util.Buffer;
	/**
	 * Allocates a buffer.
	 * @param {number} size Number of bytes to allocate for the buffer.
	 * @returns {Buffer}
	 */
	function allocBuffer(size) {
	    if (typeof size !== 'number') {
	        throw new Error('size passed to allocBuffer must be a number.');
	    }
	    var buffer = typeof Buffer.alloc === 'function' ? Buffer.alloc(size) : new Buffer(size);
	    buffer.fill(0);
	    return buffer;
	}

	/**
	 * @api private
	 */
	module.exports = {
	    allocBuffer: allocBuffer
	};

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	var Transform = __webpack_require__(215).Transform;
	var parseEvent = __webpack_require__(222).parseEvent;

	/** @type {Transform} */
	function EventUnmarshallerStream(options) {
	    options = options || {};
	    // set output to object mode
	    options.readableObjectMode = true;
	    Transform.call(this, options);
	    this._readableState.objectMode = true;

	    this.parser = options.parser;
	    this.eventStreamModel = options.eventStreamModel;
	}

	EventUnmarshallerStream.prototype = Object.create(Transform.prototype);

	/**
	 *
	 * @param {Buffer} chunk
	 * @param {string} encoding
	 * @param {*} callback
	 */
	EventUnmarshallerStream.prototype._transform = function(chunk, encoding, callback) {
	    try {
	        var event = parseEvent(this.parser, chunk, this.eventStreamModel);
	        this.push(event);
	        return callback();
	    } catch (err) {
	        callback(err);
	    }
	};

	/**
	 * @api private
	 */
	module.exports = {
	    EventUnmarshallerStream: EventUnmarshallerStream
	};

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	var parseMessage = __webpack_require__(223).parseMessage;

	/**
	 *
	 * @param {*} parser
	 * @param {Buffer} message
	 * @param {*} shape
	 * @api private
	 */
	function parseEvent(parser, message, shape) {
	    var parsedMessage = parseMessage(message);

	    // check if message is an event or error
	    var messageType = parsedMessage.headers[':message-type'];
	    if (messageType) {
	        if (messageType.value === 'error') {
	            throw parseError(parsedMessage);
	        } else if (messageType.value !== 'event') {
	            // not sure how to parse non-events/non-errors, ignore for now
	            return;
	        }
	    }

	    // determine event type
	    var eventType = parsedMessage.headers[':event-type'];
	    // check that the event type is modeled
	    var eventModel = shape.members[eventType.value];
	    if (!eventModel) {
	        return;
	    }

	    var result = {};
	    // check if an event payload exists
	    var eventPayloadMemberName = eventModel.eventPayloadMemberName;
	    if (eventPayloadMemberName) {
	        var payloadShape = eventModel.members[eventPayloadMemberName];
	        // if the shape is binary, return the byte array
	        if (payloadShape.type === 'binary') {
	            result[eventPayloadMemberName] = parsedMessage.body;
	        } else {
	            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
	        }
	    }

	    // read event headers
	    var eventHeaderNames = eventModel.eventHeaderMemberNames;
	    for (var i = 0; i < eventHeaderNames.length; i++) {
	        var name = eventHeaderNames[i];
	        if (parsedMessage.headers[name]) {
	            // parse the header!
	            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
	        }
	    }

	    var output = {};
	    output[eventType.value] = result;
	    return output;
	}

	function parseError(message) {
	    var errorCode = message.headers[':error-code'];
	    var errorMessage = message.headers[':error-message'];
	    var error = new Error(errorMessage.value || errorMessage);
	    error.code = error.name = errorCode.value || errorCode;
	    return error;
	}

	/**
	 * @api private
	 */
	module.exports = {
	    parseEvent: parseEvent
	};

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	var Int64 = __webpack_require__(224).Int64;

	var splitMessage = __webpack_require__(226).splitMessage;

	var BOOLEAN_TAG = 'boolean';
	var BYTE_TAG = 'byte';
	var SHORT_TAG = 'short';
	var INT_TAG = 'integer';
	var LONG_TAG = 'long';
	var BINARY_TAG = 'binary';
	var STRING_TAG = 'string';
	var TIMESTAMP_TAG = 'timestamp';
	var UUID_TAG = 'uuid';

	/**
	 * @api private
	 *
	 * @param {Buffer} headers
	 */
	function parseHeaders(headers) {
	    var out = {};
	    var position = 0;
	    while (position < headers.length) {
	        var nameLength = headers.readUInt8(position++);
	        var name = headers.slice(position, position + nameLength).toString();
	        position += nameLength;
	        switch (headers.readUInt8(position++)) {
	            case 0 /* boolTrue */:
	                out[name] = {
	                    type: BOOLEAN_TAG,
	                    value: true
	                };
	                break;
	            case 1 /* boolFalse */:
	                out[name] = {
	                    type: BOOLEAN_TAG,
	                    value: false
	                };
	                break;
	            case 2 /* byte */:
	                out[name] = {
	                    type: BYTE_TAG,
	                    value: headers.readInt8(position++)
	                };
	                break;
	            case 3 /* short */:
	                out[name] = {
	                    type: SHORT_TAG,
	                    value: headers.readInt16BE(position)
	                };
	                position += 2;
	                break;
	            case 4 /* integer */:
	                out[name] = {
	                    type: INT_TAG,
	                    value: headers.readInt32BE(position)
	                };
	                position += 4;
	                break;
	            case 5 /* long */:
	                out[name] = {
	                    type: LONG_TAG,
	                    value: new Int64(headers.slice(position, position + 8))
	                };
	                position += 8;
	                break;
	            case 6 /* byteArray */:
	                var binaryLength = headers.readUInt16BE(position);
	                position += 2;
	                out[name] = {
	                    type: BINARY_TAG,
	                    value: headers.slice(position, position + binaryLength)
	                };
	                position += binaryLength;
	                break;
	            case 7 /* string */:
	                var stringLength = headers.readUInt16BE(position);
	                position += 2;
	                out[name] = {
	                    type: STRING_TAG,
	                    value: headers.slice(
	                        position,
	                        position + stringLength
	                    ).toString()
	                };
	                position += stringLength;
	                break;
	            case 8 /* timestamp */:
	                out[name] = {
	                    type: TIMESTAMP_TAG,
	                    value: new Date(
	                        new Int64(headers.slice(position, position + 8))
	                            .valueOf()
	                    )
	                };
	                position += 8;
	                break;
	            case 9 /* uuid */:
	                var uuidChars = headers.slice(position, position + 16)
	                    .toString('hex');
	                position += 16;
	                out[name] = {
	                    type: UUID_TAG,
	                    value: uuidChars.substr(0, 8) + '-' +
	                        uuidChars.substr(8, 4) + '-' +
	                        uuidChars.substr(12, 4) + '-' +
	                        uuidChars.substr(16, 4) + '-' +
	                        uuidChars.substr(20)
	                };
	                break;
	            default:
	                throw new Error('Unrecognized header type tag');
	        }
	    }
	    return out;
	}

	function parseMessage(message) {
	    var parsed = splitMessage(message);
	    return { headers: parseHeaders(parsed.headers), body: parsed.body };
	}

	/**
	 * @api private
	 */
	module.exports = {
	    parseMessage: parseMessage
	};

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(160).util;
	var toBuffer = __webpack_require__(225).toBuffer;

	/**
	 * A lossless representation of a signed, 64-bit integer. Instances of this
	 * class may be used in arithmetic expressions as if they were numeric
	 * primitives, but the binary representation will be preserved unchanged as the
	 * `bytes` property of the object. The bytes should be encoded as big-endian,
	 * two's complement integers.
	 * @param {Buffer} bytes
	 *
	 * @api private
	 */
	function Int64(bytes) {
	    if (bytes.length !== 8) {
	        throw new Error('Int64 buffers must be exactly 8 bytes');
	    }
	    if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);

	    this.bytes = bytes;
	}

	/**
	 * @param {number} number
	 * @returns {Int64}
	 *
	 * @api private
	 */
	Int64.fromNumber = function(number) {
	    if (number > 9223372036854775807 || number < -9223372036854775808) {
	        throw new Error(
	            number + ' is too large (or, if negative, too small) to represent as an Int64'
	        );
	    }

	    var bytes = new Uint8Array(8)
	    for (
	        var i = 7, remaining = Math.abs(Math.round(number));
	        i > -1 && remaining > 0;
	        i--, remaining /= 256
	    ) {
	        bytes[i] = remaining;
	    }

	    if (number < 0) {
	        negate(bytes);
	    }

	    return new Int64(bytes);
	};

	/**
	 * @returns {number}
	 *
	 * @api private
	 */
	Int64.prototype.valueOf = function() {
	    var bytes = this.bytes.slice(0);
	    var negative = bytes[0] & 128;
	    if (negative) {
	        negate(bytes);
	    }

	    return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
	};

	Int64.prototype.toString = function() {
	    return String(this.valueOf());
	};

	/**
	 * @param {Buffer} bytes
	 *
	 * @api private
	 */
	function negate(bytes) {
	    for (var i = 0; i < 8; i++) {
	        bytes[i] ^= 0xFF;
	    }
	    for (var i = 7; i > -1; i--) {
	        bytes[i]++;
	        if (bytes[i] !== 0) {
	            break;
	        }
	    }
	}

	/**
	 * @api private
	 */
	module.exports = {
	    Int64: Int64
	};

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(160).util.Buffer;
	/**
	 * Converts data into Buffer.
	 * @param {ArrayBuffer|string|number[]|Buffer} data Data to convert to a Buffer
	 * @param {string} [encoding] String encoding
	 * @returns {Buffer}
	 */
	function toBuffer(data, encoding) {
	    return (typeof Buffer.from === 'function' && Buffer.from !== Uint8Array.from) ?
	        Buffer.from(data, encoding) : new Buffer(data, encoding);
	}

	/**
	 * @api private
	 */
	module.exports = {
	    toBuffer: toBuffer
	};

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(160).util;
	var toBuffer = __webpack_require__(225).toBuffer;

	// All prelude components are unsigned, 32-bit integers
	var PRELUDE_MEMBER_LENGTH = 4;
	// The prelude consists of two components
	var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
	// Checksums are always CRC32 hashes.
	var CHECKSUM_LENGTH = 4;
	// Messages must include a full prelude, a prelude checksum, and a message checksum
	var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

	/**
	 * @api private
	 *
	 * @param {Buffer} message
	 */
	function splitMessage(message) {
	    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);

	    if (message.length < MINIMUM_MESSAGE_LENGTH) {
	        throw new Error('Provided message too short to accommodate event stream message overhead');
	    }

	    if (message.length !== message.readUInt32BE(0)) {
	        throw new Error('Reported message length does not match received message length');
	    }

	    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);

	    if (
	        expectedPreludeChecksum !== util.crypto.crc32(
	            message.slice(0, PRELUDE_LENGTH)
	        )
	    ) {
	        throw new Error(
	            'The prelude checksum specified in the message (' +
	            expectedPreludeChecksum +
	            ') does not match the calculated CRC32 checksum.'
	        );
	    }

	    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);

	    if (
	        expectedMessageChecksum !== util.crypto.crc32(
	            message.slice(0, message.length - CHECKSUM_LENGTH)
	        )
	    ) {
	        throw new Error(
	            'The message checksum did not match the expected value of ' +
	                expectedMessageChecksum
	        );
	    }

	    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
	    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);

	    return {
	        headers: message.slice(headersStart, headersEnd),
	        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),
	    };
	}

	/**
	 * @api private
	 */
	module.exports = {
	    splitMessage: splitMessage
	};

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	var eventMessageChunker = __webpack_require__(228).eventMessageChunker;
	var parseEvent = __webpack_require__(222).parseEvent;

	function createEventStream(body, parser, model) {
	    var eventMessages = eventMessageChunker(body);

	    var events = [];

	    for (var i = 0; i < eventMessages.length; i++) {
	        events.push(parseEvent(parser, eventMessages[i], model));
	    }

	    return events;
	}

	/**
	 * @api private
	 */
	module.exports = {
	    createEventStream: createEventStream
	};

/***/ }),
/* 228 */
/***/ (function(module, exports) {

	/**
	 * Takes in a buffer of event messages and splits them into individual messages.
	 * @param {Buffer} buffer
	 * @api private
	 */
	function eventMessageChunker(buffer) {
	    /** @type Buffer[] */
	    var messages = [];
	    var offset = 0;

	    while (offset < buffer.length) {
	        var totalLength = buffer.readInt32BE(offset);

	        // create new buffer for individual message (shares memory with original)
	        var message = buffer.slice(offset, totalLength + offset);
	        // increment offset to it starts at the next message
	        offset += totalLength;

	        messages.push(message);
	    }

	    return messages;
	}

	/**
	 * @api private
	 */
	module.exports = {
	    eventMessageChunker: eventMessageChunker
	};

/***/ }),
/* 229 */
/***/ (function(module, exports) {

	module.exports = {
	  //provide realtime clock for performance measurement
	  now: function now() {
	    var second = process.hrtime();
	    return second[0] * 1000 + (second[1] / 1000000);
	  }
	}


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	var dgram = __webpack_require__(231);
	var stringToBuffer = __webpack_require__(232).stringToBuffer;

	var MAX_MESSAGE_SIZE = 1024 * 8; // 8 KB

	/**
	 * Publishes metrics via udp.
	 * @param {object} options Paramters for Publisher constructor
	 * @param {number} [options.port = 31000] Port number
	 * @param {string} [options.clientId = ''] Client Identifier
	 * @param {boolean} [options.enabled = false] enable sending metrics datagram
	 * @api private
	 */
	function Publisher(options) {
	    // handle configuration
	    options = options || {};
	    this.enabled = options.enabled || false;
	    this.port = options.port || 31000;
	    this.clientId = options.clientId || '';
	    if (this.clientId.length > 255) {
	        // ClientId has a max length of 255
	        this.clientId = this.clientId.substr(0, 255);
	    }
	    this.messagesInFlight = 0;
	    this.address = 'localhost';
	}

	Publisher.prototype.fieldsToTrim = {
	    UserAgent: 256,
	    SdkException: 128,
	    SdkExceptionMessage: 512,
	    AwsException: 128,
	    AwsExceptionMessage: 512
	};

	/**
	 * Trims fields that have a specified max length.
	 * @param {object} event ApiCall or ApiCallAttempt event.
	 * @returns {object}
	 * @api private
	 */
	Publisher.prototype.trimFields = function(event) {
	    var trimmableFields = Object.keys(this.fieldsToTrim);
	    for (var i = 0, iLen = trimmableFields.length; i < iLen; i++) {
	        var field = trimmableFields[i];
	        if (event.hasOwnProperty(field)) {
	            var maxLength = this.fieldsToTrim[field];
	            var value = event[field];
	            if (value && value.length > maxLength) {
	                event[field] = value.substr(0, maxLength);
	            }
	        }
	    }
	    return event;
	}

	/**
	 * Handles ApiCall and ApiCallAttempt events.
	 * @param {Object} event apiCall or apiCallAttempt event.
	 * @api private
	 */
	Publisher.prototype.eventHandler = function(event) {
	    // set the clientId
	    event.ClientId = this.clientId;

	    this.trimFields(event);

	    var message = stringToBuffer(JSON.stringify(event));
	    if (!this.enabled || message.length > MAX_MESSAGE_SIZE) {
	        // drop the message if publisher not enabled or it is too large
	        return;
	    }

	    this.publishDatagram(message);
	}

	/**
	 * Publishes message to an agent.
	 * @param {Buffer} message JSON message to send to agent.
	 * @api private
	 */
	Publisher.prototype.publishDatagram = function(message) {
	    var self = this;
	    var client = this.getClient();

	    this.messagesInFlight++;
	    this.client.send(message, 0, message.length, this.port, this.address, function(err, bytes) {
	        if (--self.messagesInFlight <= 0) {
	            // destroy existing client so the event loop isn't kept open
	            self.destroyClient()
	        }
	    });
	}

	/**
	 * Returns an existing udp socket, or creates one if it doesn't already exist.
	 * @api private
	 */
	Publisher.prototype.getClient = function() {
	    if (!this.client) {
	        this.client = dgram.createSocket('udp4');
	    }
	    return this.client;
	}

	/**
	 * Destroys the udp socket.
	 * @api private
	 */
	Publisher.prototype.destroyClient = function() {
	    if (this.client) {
	        this.client.close();
	        this.client = void 0;
	    }
	}

	module.exports = {
	    Publisher: Publisher
	};


/***/ }),
/* 231 */
/***/ (function(module, exports) {

	module.exports = require("dgram");

/***/ }),
/* 232 */
/***/ (function(module, exports) {

	/**
	 * Converts a UTF8 string into a Buffer.
	 * @param {string} data Some string to convert to a Buffer
	 * @returns {Buffer}
	 */
	function stringToBuffer(data) {
	    return (typeof Buffer.from === 'function' && Buffer.from !== Uint8Array.from) ?
	        Buffer.from(data) : new Buffer(data);
	}

	module.exports = {
	    stringToBuffer: stringToBuffer
	};

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var SharedIniFile = __webpack_require__(234);
	/**
	 * Resolve client-side monitoring configuration from either environmental variables
	 * or shared config file. Configurations from environmental variables have higher priority
	 * than those from shared config file. The resolver will try to read the shared config file
	 * no matter whether the AWS_SDK_LOAD_CONFIG variable is set.
	 * @api private
	 */
	function resolveMonitoringConfig() {
	  var config = {
	    port: undefined,
	    clientId: undefined,
	    enabled: undefined,
	  };
	  if (fromEnvironment(config) || fromConfigFile(config)) return toJSType(config);
	  return toJSType(config);
	}

	/**
	 * Resolve configurations from environmental variables.
	 * @param {object} client side monitoring config object needs to be resolved
	 * @returns {boolean} whether resolving configurations is done
	 * @api private
	 */
	function fromEnvironment(config) {
	  config.port = config.port || process.env.AWS_CSM_PORT;
	  config.enabled = config.enabled || process.env.AWS_CSM_ENABLED;
	  config.clientId = config.clientId || process.env.AWS_CSM_CLIENT_ID;
	  return config.port && config.enabled && config.clientId ||
	    ['false', '0'].indexOf(config.enabled) >= 0; //no need to read shared config file if explicitely disabled
	}

	/**
	 * Resolve cofigurations from shared config file with specified role name
	 * @param {object} client side monitoring config object needs to be resolved
	 * @returns {boolean} whether resolving configurations is done
	 * @api private
	 */
	function fromConfigFile(config) {
	  var profile = process.env.AWS_PROFILE || AWS.util.defaultProfile;
	  var file = process.env[AWS.util.sharedConfigFileEnv]
	  var sharedFileConfig;
	  try {
	    var configFile = new SharedIniFile({
	      isConfig: true,
	      filename: file
	    });
	    var sharedFileConfig = configFile.getProfile(profile);
	  } catch (err) {
	    return false;
	  }
	  if (!sharedFileConfig) return config;
	  config.port = config.port || sharedFileConfig.csm_port;
	  config.enabled = config.enabled || sharedFileConfig.csm_enabled;
	  config.clientId = config.clientId || sharedFileConfig.csm_client_id;
	  return config.port && config.enabled && config.clientId;
	}

	/**
	 * Transfer the resolved configuration value to proper types: port as number, enabled
	 * as boolean and clientId as string. The 'enabled' flag is valued to false when set
	 * to 'false' or '0'.
	 * @param {object} resolved client side monitoring config
	 * @api private
	 */
	function toJSType(config) {
	    //config.XXX is either undefined or string
	  var falsyNotations = ['false', '0', undefined];
	  if (!config.enabled || falsyNotations.indexOf(config.enabled.toLowerCase()) >= 0) {
	    config.enabled = false;
	  } else {
	    config.enabled = true;
	  }
	  config.port = config.port ? parseInt(config.port, 10) : undefined;
	  return config;
	}

	module.exports = resolveMonitoringConfig;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var os = __webpack_require__(235);
	var path = __webpack_require__(236);

	/**
	 * @api private
	 */
	module.exports = AWS.util.inherit({
	  constructor: function SharedIniFile(options) {
	    options = options || {};

	    this.isConfig = options.isConfig === true;
	    this.filename = options.filename || this.getDefaultFilepath();
	  },

	  ensureFileLoaded: function loadFile() {
	    if (!this.parsedContents) {
	      this.parsedContents = AWS.util.ini.parse(
	        AWS.util.readFileSync(this.filename)
	      );
	    }
	  },

	  getDefaultFilepath: function getDefaultFilepath() {
	    return path.join(
	      this.getHomeDir(),
	      '.aws',
	      this.isConfig ? 'config' : 'credentials'
	    );
	  },

	  getHomeDir: function getHomeDir() {
	    var env = process.env;
	    var home = env.HOME ||
	      env.USERPROFILE ||
	      (env.HOMEPATH ? ((env.HOMEDRIVE || 'C:/') + env.HOMEPATH) : null);

	    if (home) {
	      return home;
	    }

	    if (typeof os.homedir === 'function') {
	      return os.homedir();
	    }

	    throw AWS.util.error(
	      new Error('Cannot load credentials, HOME path not set')
	    );
	  },

	  getProfile: function loadProfile(profile) {
	    this.ensureFileLoaded();

	    var profileIndex = profile !== AWS.util.defaultProfile && this.isConfig ?
	      'profile ' + profile : profile;

	    return this.parsedContents[profileIndex];
	  },

	  getProfiles: function loadProfileNames() {
	    this.ensureFileLoaded();
	    var isConfig = this.isConfig;

	    return Object.keys(this.parsedContents).map(function(profileName) {
	      if (isConfig) {
	        return profileName.replace(/^profile\s/, '');
	      }

	      return profileName;
	    });
	  }
	});


/***/ }),
/* 235 */
/***/ (function(module, exports) {

	module.exports = require("os");

/***/ }),
/* 236 */
/***/ (function(module, exports) {

	module.exports = require("path");

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var STS = __webpack_require__(238);

	/**
	 * Represents temporary credentials retrieved from {AWS.STS}. Without any
	 * extra parameters, credentials will be fetched from the
	 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
	 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
	 * role instead.
	 *
	 * To setup temporary credentials, configure a set of master credentials
	 * using the standard credentials providers (environment, EC2 instance metadata,
	 * or from the filesystem), then set the global credentials to a new
	 * temporary credentials object:
	 *
	 * ```javascript
	 * // Note that environment credentials are loaded by default,
	 * // the following line is shown for clarity:
	 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
	 *
	 * // Now set temporary credentials seeded from the master credentials
	 * AWS.config.credentials = new AWS.TemporaryCredentials();
	 *
	 * // subsequent requests will now use temporary credentials from AWS STS.
	 * new AWS.S3().listBucket(function(err, data) { ... });
	 * ```
	 *
	 * @!attribute masterCredentials
	 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
	 *     get and refresh temporary credentials from AWS STS.
	 * @note (see constructor)
	 */
	AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new temporary credentials object.
	   *
	   * @note In order to create temporary credentials, you first need to have
	   *   "master" credentials configured in {AWS.Config.credentials}. These
	   *   master credentials are necessary to retrieve the temporary credentials,
	   *   as well as refresh the credentials when they expire.
	   * @param params [map] a map of options that are passed to the
	   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
	   *   If a `RoleArn` parameter is passed in, credentials will be based on the
	   *   IAM role.
	   * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
	   *  used to get and refresh temporary credentials from AWS STS.
	   * @example Creating a new credentials object for generic temporary credentials
	   *   AWS.config.credentials = new AWS.TemporaryCredentials();
	   * @example Creating a new credentials object for an IAM role
	   *   AWS.config.credentials = new AWS.TemporaryCredentials({
	   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
	   *   });
	   * @see AWS.STS.assumeRole
	   * @see AWS.STS.getSessionToken
	   */
	  constructor: function TemporaryCredentials(params, masterCredentials) {
	    AWS.Credentials.call(this);
	    this.loadMasterCredentials(masterCredentials);
	    this.expired = true;

	    this.params = params || {};
	    if (this.params.RoleArn) {
	      this.params.RoleSessionName =
	        this.params.RoleSessionName || 'temporary-credentials';
	    }
	  },

	  /**
	   * Refreshes credentials using {AWS.STS.assumeRole} or
	   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
	   * to the credentials {constructor}.
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.masterCredentials.get(function() {
	      self.service.config.credentials = self.masterCredentials;
	      var operation = self.params.RoleArn ?
	        self.service.assumeRole : self.service.getSessionToken;
	      operation.call(self.service, function (err, data) {
	        if (!err) {
	          self.service.credentialsFrom(data, self);
	        }
	        callback(err);
	      });
	    });
	  },

	  /**
	   * @api private
	   */
	  loadMasterCredentials: function loadMasterCredentials(masterCredentials) {
	    this.masterCredentials = masterCredentials || AWS.config.credentials;
	    while (this.masterCredentials.masterCredentials) {
	      this.masterCredentials = this.masterCredentials.masterCredentials;
	    }

	    if (typeof this.masterCredentials.get !== 'function') {
	      this.masterCredentials = new AWS.Credentials(this.masterCredentials);
	    }
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    this.service = this.service || new STS({params: this.params});
	  }

	});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(158);
	var AWS = __webpack_require__(160);
	var Service = AWS.Service;
	var apiLoader = AWS.apiLoader;

	apiLoader.services['sts'] = {};
	AWS.STS = Service.defineService('sts', ['2011-06-15']);
	__webpack_require__(239);
	Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
	  get: function get() {
	    var model = __webpack_require__(240);
	    model.paginators = __webpack_require__(241).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.STS;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	AWS.util.update(AWS.STS.prototype, {
	  /**
	   * @overload credentialsFrom(data, credentials = null)
	   *   Creates a credentials object from STS response data containing
	   *   credentials information. Useful for quickly setting AWS credentials.
	   *
	   *   @note This is a low-level utility function. If you want to load temporary
	   *     credentials into your process for subsequent requests to AWS resources,
	   *     you should use {AWS.TemporaryCredentials} instead.
	   *   @param data [map] data retrieved from a call to {getFederatedToken},
	   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
	   *   @param credentials [AWS.Credentials] an optional credentials object to
	   *     fill instead of creating a new object. Useful when modifying an
	   *     existing credentials object from a refresh call.
	   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
	   *     loaded from a raw STS operation response.
	   *   @example Using credentialsFrom to load global AWS credentials
	   *     var sts = new AWS.STS();
	   *     sts.getSessionToken(function (err, data) {
	   *       if (err) console.log("Error getting credentials");
	   *       else {
	   *         AWS.config.credentials = sts.credentialsFrom(data);
	   *       }
	   *     });
	   *   @see AWS.TemporaryCredentials
	   */
	  credentialsFrom: function credentialsFrom(data, credentials) {
	    if (!data) return null;
	    if (!credentials) credentials = new AWS.TemporaryCredentials();
	    credentials.expired = false;
	    credentials.accessKeyId = data.Credentials.AccessKeyId;
	    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
	    credentials.sessionToken = data.Credentials.SessionToken;
	    credentials.expireTime = data.Credentials.Expiration;
	    return credentials;
	  },

	  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
	    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
	  },

	  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
	    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
	  }
	});


/***/ }),
/* 240 */
/***/ (function(module, exports) {

	module.exports = {"version":"2.0","metadata":{"apiVersion":"2011-06-15","endpointPrefix":"sts","globalEndpoint":"sts.amazonaws.com","protocol":"query","serviceAbbreviation":"AWS STS","serviceFullName":"AWS Security Token Service","serviceId":"STS","signatureVersion":"v4","uid":"sts-2011-06-15","xmlNamespace":"https://sts.amazonaws.com/doc/2011-06-15/"},"operations":{"AssumeRole":{"input":{"type":"structure","required":["RoleArn","RoleSessionName"],"members":{"RoleArn":{},"RoleSessionName":{},"Policy":{},"DurationSeconds":{"type":"integer"},"ExternalId":{},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"AssumeRoleResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"AssumedRoleUser":{"shape":"Sf"},"PackedPolicySize":{"type":"integer"}}}},"AssumeRoleWithSAML":{"input":{"type":"structure","required":["RoleArn","PrincipalArn","SAMLAssertion"],"members":{"RoleArn":{},"PrincipalArn":{},"SAMLAssertion":{},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithSAMLResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"AssumedRoleUser":{"shape":"Sf"},"PackedPolicySize":{"type":"integer"},"Subject":{},"SubjectType":{},"Issuer":{},"Audience":{},"NameQualifier":{}}}},"AssumeRoleWithWebIdentity":{"input":{"type":"structure","required":["RoleArn","RoleSessionName","WebIdentityToken"],"members":{"RoleArn":{},"RoleSessionName":{},"WebIdentityToken":{},"ProviderId":{},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithWebIdentityResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"SubjectFromWebIdentityToken":{},"AssumedRoleUser":{"shape":"Sf"},"PackedPolicySize":{"type":"integer"},"Provider":{},"Audience":{}}}},"DecodeAuthorizationMessage":{"input":{"type":"structure","required":["EncodedMessage"],"members":{"EncodedMessage":{}}},"output":{"resultWrapper":"DecodeAuthorizationMessageResult","type":"structure","members":{"DecodedMessage":{}}}},"GetCallerIdentity":{"input":{"type":"structure","members":{}},"output":{"resultWrapper":"GetCallerIdentityResult","type":"structure","members":{"UserId":{},"Account":{},"Arn":{}}}},"GetFederationToken":{"input":{"type":"structure","required":["Name"],"members":{"Name":{},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"GetFederationTokenResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"FederatedUser":{"type":"structure","required":["FederatedUserId","Arn"],"members":{"FederatedUserId":{},"Arn":{}}},"PackedPolicySize":{"type":"integer"}}}},"GetSessionToken":{"input":{"type":"structure","members":{"DurationSeconds":{"type":"integer"},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"GetSessionTokenResult","type":"structure","members":{"Credentials":{"shape":"Sa"}}}}},"shapes":{"Sa":{"type":"structure","required":["AccessKeyId","SecretAccessKey","SessionToken","Expiration"],"members":{"AccessKeyId":{},"SecretAccessKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}},"Sf":{"type":"structure","required":["AssumedRoleId","Arn"],"members":{"AssumedRoleId":{},"Arn":{}}}}}

/***/ }),
/* 241 */
/***/ (function(module, exports) {

	module.exports = {"pagination":{}}

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var STS = __webpack_require__(238);

	/**
	 * Represents credentials retrieved from STS Web Identity Federation support.
	 *
	 * By default this provider gets credentials using the
	 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
	 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
	 * application for which credentials will be given. In addition, the
	 * `WebIdentityToken` must be set to the token provided by the identity
	 * provider. See {constructor} for an example on creating a credentials
	 * object with proper `RoleArn` and `WebIdentityToken` values.
	 *
	 * ## Refreshing Credentials from Identity Service
	 *
	 * In addition to AWS credentials expiring after a given amount of time, the
	 * login token from the identity provider will also expire. Once this token
	 * expires, it will not be usable to refresh AWS credentials, and another
	 * token will be needed. The SDK does not manage refreshing of the token value,
	 * but this can be done through a "refresh token" supported by most identity
	 * providers. Consult the documentation for the identity provider for refreshing
	 * tokens. Once the refreshed token is acquired, you should make sure to update
	 * this new token in the credentials object's {params} property. The following
	 * code will update the WebIdentityToken, assuming you have retrieved an updated
	 * token from the identity provider:
	 *
	 * ```javascript
	 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
	 * ```
	 *
	 * Future calls to `credentials.refresh()` will now use the new token.
	 *
	 * @!attribute params
	 *   @return [map] the map of params passed to
	 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
	 *     `params.WebIdentityToken` property.
	 * @!attribute data
	 *   @return [map] the raw data response from the call to
	 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
	 *     access to other properties from the response.
	 */
	AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new credentials object.
	   * @param (see AWS.STS.assumeRoleWithWebIdentity)
	   * @example Creating a new credentials object
	   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
	   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
	   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
	   *     RoleSessionName: 'web' // optional name, defaults to web-identity
	   *   }, {
	   *     // optionally provide configuration to apply to the underlying AWS.STS service client
	   *     // if configuration is not provided, then configuration will be pulled from AWS.config
	   *
	   *     // specify timeout options
	   *     httpOptions: {
	   *       timeout: 100
	   *     }
	   *   });
	   * @see AWS.STS.assumeRoleWithWebIdentity
	   * @see AWS.Config
	   */
	  constructor: function WebIdentityCredentials(params, clientConfig) {
	    AWS.Credentials.call(this);
	    this.expired = true;
	    this.params = params;
	    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
	    this.data = null;
	    this._clientConfig = AWS.util.copy(clientConfig || {});
	  },

	  /**
	   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.service.assumeRoleWithWebIdentity(function (err, data) {
	      self.data = null;
	      if (!err) {
	        self.data = data;
	        self.service.credentialsFrom(data, self);
	      }
	      callback(err);
	    });
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    if (!this.service) {
	      var stsConfig = AWS.util.merge({}, this._clientConfig);
	      stsConfig.params = this.params;
	      this.service = new STS(stsConfig);
	    }
	  }

	});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var CognitoIdentity = __webpack_require__(244);
	var STS = __webpack_require__(238);

	/**
	 * Represents credentials retrieved from STS Web Identity Federation using
	 * the Amazon Cognito Identity service.
	 *
	 * By default this provider gets credentials using the
	 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
	 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
	 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
	 * obtain an `IdentityId`. If the identity or identity pool is not configured in
	 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
	 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
	 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
	 * is provided, then this provider gets credentials using the
	 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
	 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
	 *
	 * In addition, if this credential provider is used to provide authenticated
	 * login, the `Logins` map may be set to the tokens provided by the respective
	 * identity providers. See {constructor} for an example on creating a credentials
	 * object with proper property values.
	 *
	 * ## Refreshing Credentials from Identity Service
	 *
	 * In addition to AWS credentials expiring after a given amount of time, the
	 * login token from the identity provider will also expire. Once this token
	 * expires, it will not be usable to refresh AWS credentials, and another
	 * token will be needed. The SDK does not manage refreshing of the token value,
	 * but this can be done through a "refresh token" supported by most identity
	 * providers. Consult the documentation for the identity provider for refreshing
	 * tokens. Once the refreshed token is acquired, you should make sure to update
	 * this new token in the credentials object's {params} property. The following
	 * code will update the WebIdentityToken, assuming you have retrieved an updated
	 * token from the identity provider:
	 *
	 * ```javascript
	 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
	 * ```
	 *
	 * Future calls to `credentials.refresh()` will now use the new token.
	 *
	 * @!attribute params
	 *   @return [map] the map of params passed to
	 *     {AWS.CognitoIdentity.getId},
	 *     {AWS.CognitoIdentity.getOpenIdToken}, and
	 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
	 *     `params.WebIdentityToken` property.
	 * @!attribute data
	 *   @return [map] the raw data response from the call to
	 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
	 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
	 *     access to other properties from the response.
	 * @!attribute identityId
	 *   @return [String] the Cognito ID returned by the last call to
	 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
	 *     final resolved identity ID from Amazon Cognito.
	 */
	AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * @api private
	   */
	  localStorageKey: {
	    id: 'aws.cognito.identity-id.',
	    providers: 'aws.cognito.identity-providers.'
	  },

	  /**
	   * Creates a new credentials object.
	   * @example Creating a new credentials object
	   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
	   *
	   *     // either IdentityPoolId or IdentityId is required
	   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
	   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
	   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
	   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
	   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
	   *
	   *     // optional, only necessary when the identity pool is not configured
	   *     // to use IAM roles in the Amazon Cognito Console
	   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
	   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
	   *
	   *     // optional tokens, used for authenticated login
	   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
	   *     Logins: {
	   *       'graph.facebook.com': 'FBTOKEN',
	   *       'www.amazon.com': 'AMAZONTOKEN',
	   *       'accounts.google.com': 'GOOGLETOKEN',
	   *       'api.twitter.com': 'TWITTERTOKEN',
	   *       'www.digits.com': 'DIGITSTOKEN'
	   *     },
	   *
	   *     // optional name, defaults to web-identity
	   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
	   *     RoleSessionName: 'web',
	   *
	   *     // optional, only necessary when application runs in a browser
	   *     // and multiple users are signed in at once, used for caching
	   *     LoginId: 'example@gmail.com'
	   *
	   *   }, {
	   *      // optionally provide configuration to apply to the underlying service clients
	   *      // if configuration is not provided, then configuration will be pulled from AWS.config
	   *
	   *      // region should match the region your identity pool is located in
	   *      region: 'us-east-1',
	   *
	   *      // specify timeout options
	   *      httpOptions: {
	   *        timeout: 100
	   *      }
	   *   });
	   * @see AWS.CognitoIdentity.getId
	   * @see AWS.CognitoIdentity.getCredentialsForIdentity
	   * @see AWS.STS.assumeRoleWithWebIdentity
	   * @see AWS.CognitoIdentity.getOpenIdToken
	   * @see AWS.Config
	   * @note If a region is not provided in the global AWS.config, or
	   *   specified in the `clientConfig` to the CognitoIdentityCredentials
	   *   constructor, you may encounter a 'Missing credentials in config' error
	   *   when calling making a service call.
	   */
	  constructor: function CognitoIdentityCredentials(params, clientConfig) {
	    AWS.Credentials.call(this);
	    this.expired = true;
	    this.params = params;
	    this.data = null;
	    this._identityId = null;
	    this._clientConfig = AWS.util.copy(clientConfig || {});
	    this.loadCachedId();
	    var self = this;
	    Object.defineProperty(this, 'identityId', {
	      get: function() {
	        self.loadCachedId();
	        return self._identityId || self.params.IdentityId;
	      },
	      set: function(identityId) {
	        self._identityId = identityId;
	      }
	    });
	  },

	  /**
	   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
	   * or {AWS.STS.assumeRoleWithWebIdentity}.
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see AWS.Credentials.get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    self.data = null;
	    self._identityId = null;
	    self.getId(function(err) {
	      if (!err) {
	        if (!self.params.RoleArn) {
	          self.getCredentialsForIdentity(callback);
	        } else {
	          self.getCredentialsFromSTS(callback);
	        }
	      } else {
	        self.clearIdOnNotAuthorized(err);
	        callback(err);
	      }
	    });
	  },

	  /**
	   * Clears the cached Cognito ID associated with the currently configured
	   * identity pool ID. Use this to manually invalidate your cache if
	   * the identity pool ID was deleted.
	   */
	  clearCachedId: function clearCache() {
	    this._identityId = null;
	    delete this.params.IdentityId;

	    var poolId = this.params.IdentityPoolId;
	    var loginId = this.params.LoginId || '';
	    delete this.storage[this.localStorageKey.id + poolId + loginId];
	    delete this.storage[this.localStorageKey.providers + poolId + loginId];
	  },

	  /**
	   * @api private
	   */
	  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
	    var self = this;
	    if (err.code == 'NotAuthorizedException') {
	      self.clearCachedId();
	    }
	  },

	  /**
	   * Retrieves a Cognito ID, loading from cache if it was already retrieved
	   * on this device.
	   *
	   * @callback callback function(err, identityId)
	   *   @param err [Error, null] an error object if the call failed or null if
	   *     it succeeded.
	   *   @param identityId [String, null] if successful, the callback will return
	   *     the Cognito ID.
	   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
	   *   localStorage in the browser environment of a device.
	   * @api private
	   */
	  getId: function getId(callback) {
	    var self = this;
	    if (typeof self.params.IdentityId === 'string') {
	      return callback(null, self.params.IdentityId);
	    }

	    self.cognito.getId(function(err, data) {
	      if (!err && data.IdentityId) {
	        self.params.IdentityId = data.IdentityId;
	        callback(null, data.IdentityId);
	      } else {
	        callback(err);
	      }
	    });
	  },


	  /**
	   * @api private
	   */
	  loadCredentials: function loadCredentials(data, credentials) {
	    if (!data || !credentials) return;
	    credentials.expired = false;
	    credentials.accessKeyId = data.Credentials.AccessKeyId;
	    credentials.secretAccessKey = data.Credentials.SecretKey;
	    credentials.sessionToken = data.Credentials.SessionToken;
	    credentials.expireTime = data.Credentials.Expiration;
	  },

	  /**
	   * @api private
	   */
	  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
	    var self = this;
	    self.cognito.getCredentialsForIdentity(function(err, data) {
	      if (!err) {
	        self.cacheId(data);
	        self.data = data;
	        self.loadCredentials(self.data, self);
	      } else {
	        self.clearIdOnNotAuthorized(err);
	      }
	      callback(err);
	    });
	  },

	  /**
	   * @api private
	   */
	  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
	    var self = this;
	    self.cognito.getOpenIdToken(function(err, data) {
	      if (!err) {
	        self.cacheId(data);
	        self.params.WebIdentityToken = data.Token;
	        self.webIdentityCredentials.refresh(function(webErr) {
	          if (!webErr) {
	            self.data = self.webIdentityCredentials.data;
	            self.sts.credentialsFrom(self.data, self);
	          }
	          callback(webErr);
	        });
	      } else {
	        self.clearIdOnNotAuthorized(err);
	        callback(err);
	      }
	    });
	  },

	  /**
	   * @api private
	   */
	  loadCachedId: function loadCachedId() {
	    var self = this;

	    // in the browser we source default IdentityId from localStorage
	    if (AWS.util.isBrowser() && !self.params.IdentityId) {
	      var id = self.getStorage('id');
	      if (id && self.params.Logins) {
	        var actualProviders = Object.keys(self.params.Logins);
	        var cachedProviders =
	          (self.getStorage('providers') || '').split(',');

	        // only load ID if at least one provider used this ID before
	        var intersect = cachedProviders.filter(function(n) {
	          return actualProviders.indexOf(n) !== -1;
	        });
	        if (intersect.length !== 0) {
	          self.params.IdentityId = id;
	        }
	      } else if (id) {
	        self.params.IdentityId = id;
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    var clientConfig = this._clientConfig;
	    this.webIdentityCredentials = this.webIdentityCredentials ||
	      new AWS.WebIdentityCredentials(this.params, clientConfig);
	    if (!this.cognito) {
	      var cognitoConfig = AWS.util.merge({}, clientConfig);
	      cognitoConfig.params = this.params;
	      this.cognito = new CognitoIdentity(cognitoConfig);
	    }
	    this.sts = this.sts || new STS(clientConfig);
	  },

	  /**
	   * @api private
	   */
	  cacheId: function cacheId(data) {
	    this._identityId = data.IdentityId;
	    this.params.IdentityId = this._identityId;

	    // cache this IdentityId in browser localStorage if possible
	    if (AWS.util.isBrowser()) {
	      this.setStorage('id', data.IdentityId);

	      if (this.params.Logins) {
	        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  getStorage: function getStorage(key) {
	    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
	  },

	  /**
	   * @api private
	   */
	  setStorage: function setStorage(key, val) {
	    try {
	      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
	    } catch (_) {}
	  },

	  /**
	   * @api private
	   */
	  storage: (function() {
	    try {
	      var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
	          window.localStorage : {};

	      // Test set/remove which would throw an error in Safari's private browsing
	      storage['aws.test-storage'] = 'foobar';
	      delete storage['aws.test-storage'];

	      return storage;
	    } catch (_) {
	      return {};
	    }
	  })()
	});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(158);
	var AWS = __webpack_require__(160);
	var Service = AWS.Service;
	var apiLoader = AWS.apiLoader;

	apiLoader.services['cognitoidentity'] = {};
	AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
	__webpack_require__(245);
	Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
	  get: function get() {
	    var model = __webpack_require__(246);
	    model.paginators = __webpack_require__(247).pagination;
	    return model;
	  },
	  enumerable: true,
	  configurable: true
	});

	module.exports = AWS.CognitoIdentity;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	AWS.util.update(AWS.CognitoIdentity.prototype, {
	  getOpenIdToken: function getOpenIdToken(params, callback) {
	    return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);
	  },

	  getId: function getId(params, callback) {
	    return this.makeUnauthenticatedRequest('getId', params, callback);
	  },

	  getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {
	    return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);
	  }
	});


/***/ }),
/* 246 */
/***/ (function(module, exports) {

	module.exports = {"version":"2.0","metadata":{"apiVersion":"2014-06-30","endpointPrefix":"cognito-identity","jsonVersion":"1.1","protocol":"json","serviceFullName":"Amazon Cognito Identity","serviceId":"Cognito Identity","signatureVersion":"v4","targetPrefix":"AWSCognitoIdentityService","uid":"cognito-identity-2014-06-30"},"operations":{"CreateIdentityPool":{"input":{"type":"structure","required":["IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S4"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S8"},"CognitoIdentityProviders":{"shape":"Sa"},"SamlProviderARNs":{"shape":"Sf"}}},"output":{"shape":"Sg"}},"DeleteIdentities":{"input":{"type":"structure","required":["IdentityIdsToDelete"],"members":{"IdentityIdsToDelete":{"type":"list","member":{}}}},"output":{"type":"structure","members":{"UnprocessedIdentityIds":{"type":"list","member":{"type":"structure","members":{"IdentityId":{},"ErrorCode":{}}}}}}},"DeleteIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}}},"DescribeIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{}}},"output":{"shape":"Sr"}},"DescribeIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"shape":"Sg"}},"GetCredentialsForIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"Sw"},"CustomRoleArn":{}}},"output":{"type":"structure","members":{"IdentityId":{},"Credentials":{"type":"structure","members":{"AccessKeyId":{},"SecretKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}}}}},"GetId":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"AccountId":{},"IdentityPoolId":{},"Logins":{"shape":"Sw"}}},"output":{"type":"structure","members":{"IdentityId":{}}}},"GetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Roles":{"shape":"S18"},"RoleMappings":{"shape":"S1a"}}}},"GetOpenIdToken":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"Sw"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}}},"GetOpenIdTokenForDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId","Logins"],"members":{"IdentityPoolId":{},"IdentityId":{},"Logins":{"shape":"Sw"},"TokenDuration":{"type":"long"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}}},"ListIdentities":{"input":{"type":"structure","required":["IdentityPoolId","MaxResults"],"members":{"IdentityPoolId":{},"MaxResults":{"type":"integer"},"NextToken":{},"HideDisabled":{"type":"boolean"}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Identities":{"type":"list","member":{"shape":"Sr"}},"NextToken":{}}}},"ListIdentityPools":{"input":{"type":"structure","required":["MaxResults"],"members":{"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityPools":{"type":"list","member":{"type":"structure","members":{"IdentityPoolId":{},"IdentityPoolName":{}}}},"NextToken":{}}}},"LookupDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{},"IdentityId":{},"DeveloperUserIdentifier":{},"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityId":{},"DeveloperUserIdentifierList":{"type":"list","member":{}},"NextToken":{}}}},"MergeDeveloperIdentities":{"input":{"type":"structure","required":["SourceUserIdentifier","DestinationUserIdentifier","DeveloperProviderName","IdentityPoolId"],"members":{"SourceUserIdentifier":{},"DestinationUserIdentifier":{},"DeveloperProviderName":{},"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityId":{}}}},"SetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId","Roles"],"members":{"IdentityPoolId":{},"Roles":{"shape":"S18"},"RoleMappings":{"shape":"S1a"}}}},"UnlinkDeveloperIdentity":{"input":{"type":"structure","required":["IdentityId","IdentityPoolId","DeveloperProviderName","DeveloperUserIdentifier"],"members":{"IdentityId":{},"IdentityPoolId":{},"DeveloperProviderName":{},"DeveloperUserIdentifier":{}}}},"UnlinkIdentity":{"input":{"type":"structure","required":["IdentityId","Logins","LoginsToRemove"],"members":{"IdentityId":{},"Logins":{"shape":"Sw"},"LoginsToRemove":{"shape":"Ss"}}}},"UpdateIdentityPool":{"input":{"shape":"Sg"},"output":{"shape":"Sg"}}},"shapes":{"S4":{"type":"map","key":{},"value":{}},"S8":{"type":"list","member":{}},"Sa":{"type":"list","member":{"type":"structure","members":{"ProviderName":{},"ClientId":{},"ServerSideTokenCheck":{"type":"boolean"}}}},"Sf":{"type":"list","member":{}},"Sg":{"type":"structure","required":["IdentityPoolId","IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolId":{},"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S4"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S8"},"CognitoIdentityProviders":{"shape":"Sa"},"SamlProviderARNs":{"shape":"Sf"}}},"Sr":{"type":"structure","members":{"IdentityId":{},"Logins":{"shape":"Ss"},"CreationDate":{"type":"timestamp"},"LastModifiedDate":{"type":"timestamp"}}},"Ss":{"type":"list","member":{}},"Sw":{"type":"map","key":{},"value":{}},"S18":{"type":"map","key":{},"value":{}},"S1a":{"type":"map","key":{},"value":{"type":"structure","required":["Type"],"members":{"Type":{},"AmbiguousRoleResolution":{},"RulesConfiguration":{"type":"structure","required":["Rules"],"members":{"Rules":{"type":"list","member":{"type":"structure","required":["Claim","MatchType","Value","RoleARN"],"members":{"Claim":{},"MatchType":{},"Value":{},"RoleARN":{}}}}}}}}}}}

/***/ }),
/* 247 */
/***/ (function(module, exports) {

	module.exports = {"pagination":{}}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var STS = __webpack_require__(238);

	/**
	 * Represents credentials retrieved from STS SAML support.
	 *
	 * By default this provider gets credentials using the
	 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
	 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
	 * application for which credentials will be given, as well as a `PrincipalArn`
	 * representing the ARN for the SAML identity provider. In addition, the
	 * `SAMLAssertion` must be set to the token provided by the identity
	 * provider. See {constructor} for an example on creating a credentials
	 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
	 *
	 * ## Refreshing Credentials from Identity Service
	 *
	 * In addition to AWS credentials expiring after a given amount of time, the
	 * login token from the identity provider will also expire. Once this token
	 * expires, it will not be usable to refresh AWS credentials, and another
	 * token will be needed. The SDK does not manage refreshing of the token value,
	 * but this can be done through a "refresh token" supported by most identity
	 * providers. Consult the documentation for the identity provider for refreshing
	 * tokens. Once the refreshed token is acquired, you should make sure to update
	 * this new token in the credentials object's {params} property. The following
	 * code will update the SAMLAssertion, assuming you have retrieved an updated
	 * token from the identity provider:
	 *
	 * ```javascript
	 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
	 * ```
	 *
	 * Future calls to `credentials.refresh()` will now use the new token.
	 *
	 * @!attribute params
	 *   @return [map] the map of params passed to
	 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
	 *     `params.SAMLAssertion` property.
	 */
	AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new credentials object.
	   * @param (see AWS.STS.assumeRoleWithSAML)
	   * @example Creating a new credentials object
	   *   AWS.config.credentials = new AWS.SAMLCredentials({
	   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
	   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
	   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
	   *   });
	   * @see AWS.STS.assumeRoleWithSAML
	   */
	  constructor: function SAMLCredentials(params) {
	    AWS.Credentials.call(this);
	    this.expired = true;
	    this.params = params;
	  },

	  /**
	   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
	   *
	   * @callback callback function(err)
	   *   Called when the STS service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    self.createClients();
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.service.assumeRoleWithSAML(function (err, data) {
	      if (!err) {
	        self.service.credentialsFrom(data, self);
	      }
	      callback(err);
	    });
	  },

	  /**
	   * @api private
	   */
	  createClients: function() {
	    this.service = this.service || new STS({params: this.params});
	  }

	});


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var util = AWS.util;
	var Shape = AWS.Model.Shape;

	var xml2js = __webpack_require__(250);

	/**
	 * @api private
	 */
	var options = {  // options passed to xml2js parser
	  explicitCharkey: false, // undocumented
	  trim: false,            // trim the leading/trailing whitespace from text nodes
	  normalize: false,       // trim interior whitespace inside text nodes
	  explicitRoot: false,    // return the root node in the resulting object?
	  emptyTag: null,         // the default value for empty nodes
	  explicitArray: true,    // always put child nodes in an array
	  ignoreAttrs: false,     // ignore attributes, only create text nodes
	  mergeAttrs: false,      // merge attributes and child elements
	  validator: null         // a callable validator
	};

	function NodeXmlParser() { }

	NodeXmlParser.prototype.parse = function(xml, shape) {
	  shape = shape || {};

	  var result = null;
	  var error = null;

	  var parser = new xml2js.Parser(options);
	  parser.parseString(xml, function (e, r) {
	    error = e;
	    result = r;
	  });

	  if (result) {
	    var data = parseXml(result, shape);
	    if (result.ResponseMetadata) {
	      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});
	    }
	    return data;
	  } else if (error) {
	    throw util.error(error, {code: 'XMLParserError', retryable: true});
	  } else { // empty xml document
	    return parseXml({}, shape);
	  }
	};

	function parseXml(xml, shape) {
	  switch (shape.type) {
	    case 'structure': return parseStructure(xml, shape);
	    case 'map': return parseMap(xml, shape);
	    case 'list': return parseList(xml, shape);
	    case undefined: case null: return parseUnknown(xml);
	    default: return parseScalar(xml, shape);
	  }
	}

	function parseStructure(xml, shape) {
	  var data = {};
	  if (xml === null) return data;

	  util.each(shape.members, function(memberName, memberShape) {
	    var xmlName = memberShape.name;
	    if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {
	      var xmlChild = xml[xmlName];
	      if (!memberShape.flattened) xmlChild = xmlChild[0];

	      data[memberName] = parseXml(xmlChild, memberShape);
	    } else if (memberShape.isXmlAttribute &&
	               xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {
	      data[memberName] = parseScalar(xml.$[xmlName], memberShape);
	    } else if (memberShape.type === 'list') {
	      data[memberName] = memberShape.defaultValue;
	    }
	  });

	  return data;
	}

	function parseMap(xml, shape) {
	  var data = {};
	  if (xml === null) return data;

	  var xmlKey = shape.key.name || 'key';
	  var xmlValue = shape.value.name || 'value';
	  var iterable = shape.flattened ? xml : xml.entry;

	  if (Array.isArray(iterable)) {
	    util.arrayEach(iterable, function(child) {
	      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);
	    });
	  }

	  return data;
	}

	function parseList(xml, shape) {
	  var data = [];
	  var name = shape.member.name || 'member';
	  if (shape.flattened) {
	    util.arrayEach(xml, function(xmlChild) {
	      data.push(parseXml(xmlChild, shape.member));
	    });
	  } else if (xml && Array.isArray(xml[name])) {
	    util.arrayEach(xml[name], function(child) {
	      data.push(parseXml(child, shape.member));
	    });
	  }

	  return data;
	}

	function parseScalar(text, shape) {
	  if (text && text.$ && text.$.encoding === 'base64') {
	    shape = new Shape.create({type: text.$.encoding});
	  }
	  if (text && text._) text = text._;

	  if (typeof shape.toType === 'function') {
	    return shape.toType(text);
	  } else {
	    return text;
	  }
	}

	function parseUnknown(xml) {
	  if (xml === undefined || xml === null) return '';
	  if (typeof xml === 'string') return xml;

	  // parse a list
	  if (Array.isArray(xml)) {
	    var arr = [];
	    for (i = 0; i < xml.length; i++) {
	      arr.push(parseXml(xml[i], {}));
	    }
	    return arr;
	  }

	  // empty object
	  var keys = Object.keys(xml), i;
	  if (keys.length === 0 || keys === ['$']) {
	    return {};
	  }

	  // object, parse as structure
	  var data = {};
	  for (i = 0; i < keys.length; i++) {
	    var key = keys[i], value = xml[key];
	    if (key === '$') continue;
	    if (value.length > 1) { // this member is a list
	      data[key] = parseList(value, {member: {}});
	    } else { // this member is a single item
	      data[key] = parseXml(value[0], {});
	    }
	  }
	  return data;
	}

	/**
	 * @api private
	 */
	module.exports = NodeXmlParser;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  "use strict";
	  var builder, defaults, parser, processors,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  defaults = __webpack_require__(251);

	  builder = __webpack_require__(252);

	  parser = __webpack_require__(275);

	  processors = __webpack_require__(280);

	  exports.defaults = defaults.defaults;

	  exports.processors = processors;

	  exports.ValidationError = (function(superClass) {
	    extend(ValidationError, superClass);

	    function ValidationError(message) {
	      this.message = message;
	    }

	    return ValidationError;

	  })(Error);

	  exports.Builder = builder.Builder;

	  exports.Parser = parser.Parser;

	  exports.parseString = parser.parseString;

	}).call(this);


/***/ }),
/* 251 */
/***/ (function(module, exports) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  exports.defaults = {
	    "0.1": {
	      explicitCharkey: false,
	      trim: true,
	      normalize: true,
	      normalizeTags: false,
	      attrkey: "@",
	      charkey: "#",
	      explicitArray: false,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: false,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      childkey: '@@',
	      charsAsChildren: false,
	      includeWhiteChars: false,
	      async: false,
	      strict: true,
	      attrNameProcessors: null,
	      attrValueProcessors: null,
	      tagNameProcessors: null,
	      valueProcessors: null,
	      emptyTag: ''
	    },
	    "0.2": {
	      explicitCharkey: false,
	      trim: false,
	      normalize: false,
	      normalizeTags: false,
	      attrkey: "$",
	      charkey: "_",
	      explicitArray: true,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: true,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      preserveChildrenOrder: false,
	      childkey: '$$',
	      charsAsChildren: false,
	      includeWhiteChars: false,
	      async: false,
	      strict: true,
	      attrNameProcessors: null,
	      attrValueProcessors: null,
	      tagNameProcessors: null,
	      valueProcessors: null,
	      rootName: 'root',
	      xmldec: {
	        'version': '1.0',
	        'encoding': 'UTF-8',
	        'standalone': true
	      },
	      doctype: null,
	      renderOpts: {
	        'pretty': true,
	        'indent': '  ',
	        'newline': '\n'
	      },
	      headless: false,
	      chunkSize: 10000,
	      emptyTag: '',
	      cdata: false
	    }
	  };

	}).call(this);


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  "use strict";
	  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
	    hasProp = {}.hasOwnProperty;

	  builder = __webpack_require__(253);

	  defaults = __webpack_require__(251).defaults;

	  requiresCDATA = function(entry) {
	    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
	  };

	  wrapCDATA = function(entry) {
	    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
	  };

	  escapeCDATA = function(entry) {
	    return entry.replace(']]>', ']]]]><![CDATA[>');
	  };

	  exports.Builder = (function() {
	    function Builder(opts) {
	      var key, ref, value;
	      this.options = {};
	      ref = defaults["0.2"];
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	    }

	    Builder.prototype.buildObject = function(rootObj) {
	      var attrkey, charkey, render, rootElement, rootName;
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
	        rootName = Object.keys(rootObj)[0];
	        rootObj = rootObj[rootName];
	      } else {
	        rootName = this.options.rootName;
	      }
	      render = (function(_this) {
	        return function(element, obj) {
	          var attr, child, entry, index, key, value;
	          if (typeof obj !== 'object') {
	            if (_this.options.cdata && requiresCDATA(obj)) {
	              element.raw(wrapCDATA(obj));
	            } else {
	              element.txt(obj);
	            }
	          } else if (Array.isArray(obj)) {
	            for (index in obj) {
	              if (!hasProp.call(obj, index)) continue;
	              child = obj[index];
	              for (key in child) {
	                entry = child[key];
	                element = render(element.ele(key), entry).up();
	              }
	            }
	          } else {
	            for (key in obj) {
	              if (!hasProp.call(obj, key)) continue;
	              child = obj[key];
	              if (key === attrkey) {
	                if (typeof child === "object") {
	                  for (attr in child) {
	                    value = child[attr];
	                    element = element.att(attr, value);
	                  }
	                }
	              } else if (key === charkey) {
	                if (_this.options.cdata && requiresCDATA(child)) {
	                  element = element.raw(wrapCDATA(child));
	                } else {
	                  element = element.txt(child);
	                }
	              } else if (Array.isArray(child)) {
	                for (index in child) {
	                  if (!hasProp.call(child, index)) continue;
	                  entry = child[index];
	                  if (typeof entry === 'string') {
	                    if (_this.options.cdata && requiresCDATA(entry)) {
	                      element = element.ele(key).raw(wrapCDATA(entry)).up();
	                    } else {
	                      element = element.ele(key, entry).up();
	                    }
	                  } else {
	                    element = render(element.ele(key), entry).up();
	                  }
	                }
	              } else if (typeof child === "object") {
	                element = render(element.ele(key), child).up();
	              } else {
	                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
	                  element = element.ele(key).raw(wrapCDATA(child)).up();
	                } else {
	                  if (child == null) {
	                    child = '';
	                  }
	                  element = element.ele(key, child.toString()).up();
	                }
	              }
	            }
	          }
	          return element;
	        };
	      })(this);
	      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
	        headless: this.options.headless,
	        allowSurrogateChars: this.options.allowSurrogateChars
	      });
	      return render(rootElement, rootObj).end(this.options.renderOpts);
	    };

	    return Builder;

	  })();

	}).call(this);


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

	  ref = __webpack_require__(254), assign = ref.assign, isFunction = ref.isFunction;

	  XMLDocument = __webpack_require__(255);

	  XMLDocumentCB = __webpack_require__(273);

	  XMLStringWriter = __webpack_require__(271);

	  XMLStreamWriter = __webpack_require__(274);

	  module.exports.create = function(name, xmldec, doctype, options) {
	    var doc, root;
	    if (name == null) {
	      throw new Error("Root element needs a name");
	    }
	    options = assign({}, xmldec, doctype, options);
	    doc = new XMLDocument(options);
	    root = doc.element(name);
	    if (!options.headless) {
	      doc.declaration(options);
	      if ((options.pubID != null) || (options.sysID != null)) {
	        doc.doctype(options);
	      }
	    }
	    return root;
	  };

	  module.exports.begin = function(options, onData, onEnd) {
	    var ref1;
	    if (isFunction(options)) {
	      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
	      options = {};
	    }
	    if (onData) {
	      return new XMLDocumentCB(options, onData, onEnd);
	    } else {
	      return new XMLDocument(options);
	    }
	  };

	  module.exports.stringWriter = function(options) {
	    return new XMLStringWriter(options);
	  };

	  module.exports.streamWriter = function(stream, options) {
	    return new XMLStreamWriter(stream, options);
	  };

	}).call(this);


/***/ }),
/* 254 */
/***/ (function(module, exports) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,
	    slice = [].slice,
	    hasProp = {}.hasOwnProperty;

	  assign = function() {
	    var i, key, len, source, sources, target;
	    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (isFunction(Object.assign)) {
	      Object.assign.apply(null, arguments);
	    } else {
	      for (i = 0, len = sources.length; i < len; i++) {
	        source = sources[i];
	        if (source != null) {
	          for (key in source) {
	            if (!hasProp.call(source, key)) continue;
	            target[key] = source[key];
	          }
	        }
	      }
	    }
	    return target;
	  };

	  isFunction = function(val) {
	    return !!val && Object.prototype.toString.call(val) === '[object Function]';
	  };

	  isObject = function(val) {
	    var ref;
	    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
	  };

	  isArray = function(val) {
	    if (isFunction(Array.isArray)) {
	      return Array.isArray(val);
	    } else {
	      return Object.prototype.toString.call(val) === '[object Array]';
	    }
	  };

	  isEmpty = function(val) {
	    var key;
	    if (isArray(val)) {
	      return !val.length;
	    } else {
	      for (key in val) {
	        if (!hasProp.call(val, key)) continue;
	        return false;
	      }
	      return true;
	    }
	  };

	  isPlainObject = function(val) {
	    var ctor, proto;
	    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
	  };

	  module.exports.assign = assign;

	  module.exports.isFunction = isFunction;

	  module.exports.isObject = isObject;

	  module.exports.isArray = isArray;

	  module.exports.isEmpty = isEmpty;

	  module.exports.isPlainObject = isPlainObject;

	}).call(this);


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  isPlainObject = __webpack_require__(254).isPlainObject;

	  XMLNode = __webpack_require__(256);

	  XMLStringifier = __webpack_require__(270);

	  XMLStringWriter = __webpack_require__(271);

	  module.exports = XMLDocument = (function(superClass) {
	    extend(XMLDocument, superClass);

	    function XMLDocument(options) {
	      XMLDocument.__super__.constructor.call(this, null);
	      options || (options = {});
	      if (!options.writer) {
	        options.writer = new XMLStringWriter();
	      }
	      this.options = options;
	      this.stringify = new XMLStringifier(options);
	      this.isDocument = true;
	    }

	    XMLDocument.prototype.end = function(writer) {
	      var writerOptions;
	      if (!writer) {
	        writer = this.options.writer;
	      } else if (isPlainObject(writer)) {
	        writerOptions = writer;
	        writer = this.options.writer.set(writerOptions);
	      }
	      return writer.document(this);
	    };

	    XMLDocument.prototype.toString = function(options) {
	      return this.options.writer.set(options).document(this);
	    };

	    return XMLDocument;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,
	    hasProp = {}.hasOwnProperty;

	  ref = __webpack_require__(254), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;

	  XMLElement = null;

	  XMLCData = null;

	  XMLComment = null;

	  XMLDeclaration = null;

	  XMLDocType = null;

	  XMLRaw = null;

	  XMLText = null;

	  XMLProcessingInstruction = null;

	  module.exports = XMLNode = (function() {
	    function XMLNode(parent) {
	      this.parent = parent;
	      if (this.parent) {
	        this.options = this.parent.options;
	        this.stringify = this.parent.stringify;
	      }
	      this.children = [];
	      if (!XMLElement) {
	        XMLElement = __webpack_require__(257);
	        XMLCData = __webpack_require__(259);
	        XMLComment = __webpack_require__(260);
	        XMLDeclaration = __webpack_require__(261);
	        XMLDocType = __webpack_require__(262);
	        XMLRaw = __webpack_require__(267);
	        XMLText = __webpack_require__(268);
	        XMLProcessingInstruction = __webpack_require__(269);
	      }
	    }

	    XMLNode.prototype.element = function(name, attributes, text) {
	      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
	      lastChild = null;
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
	      }
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (Array.isArray(name)) {
	        for (j = 0, len = name.length; j < len; j++) {
	          item = name[j];
	          lastChild = this.element(item);
	        }
	      } else if (isFunction(name)) {
	        lastChild = this.element(name.apply());
	      } else if (isObject(name)) {
	        for (key in name) {
	          if (!hasProp.call(name, key)) continue;
	          val = name[key];
	          if (isFunction(val)) {
	            val = val.apply();
	          }
	          if ((isObject(val)) && (isEmpty(val))) {
	            val = null;
	          }
	          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
	            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
	          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
	            for (k = 0, len1 = val.length; k < len1; k++) {
	              item = val[k];
	              childNode = {};
	              childNode[key] = item;
	              lastChild = this.element(childNode);
	            }
	          } else if (isObject(val)) {
	            lastChild = this.element(key);
	            lastChild.element(val);
	          } else {
	            lastChild = this.element(key, val);
	          }
	        }
	      } else {
	        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
	          lastChild = this.text(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
	          lastChild = this.cdata(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
	          lastChild = this.comment(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
	          lastChild = this.raw(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
	          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
	        } else {
	          lastChild = this.node(name, attributes, text);
	        }
	      }
	      if (lastChild == null) {
	        throw new Error("Could not create any elements with: " + name);
	      }
	      return lastChild;
	    };

	    XMLNode.prototype.insertBefore = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };

	    XMLNode.prototype.insertAfter = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };

	    XMLNode.prototype.remove = function() {
	      var i, ref1;
	      if (this.isRoot) {
	        throw new Error("Cannot remove the root element");
	      }
	      i = this.parent.children.indexOf(this);
	      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
	      return this.parent;
	    };

	    XMLNode.prototype.node = function(name, attributes, text) {
	      var child, ref1;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      attributes || (attributes = {});
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
	      }
	      child = new XMLElement(this, name, attributes);
	      if (text != null) {
	        child.text(text);
	      }
	      this.children.push(child);
	      return child;
	    };

	    XMLNode.prototype.text = function(value) {
	      var child;
	      child = new XMLText(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.cdata = function(value) {
	      var child;
	      child = new XMLCData(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.comment = function(value) {
	      var child;
	      child = new XMLComment(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.commentBefore = function(value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.comment(value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };

	    XMLNode.prototype.commentAfter = function(value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.comment(value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };

	    XMLNode.prototype.raw = function(value) {
	      var child;
	      child = new XMLRaw(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.instruction = function(target, value) {
	      var insTarget, insValue, instruction, j, len;
	      if (target != null) {
	        target = target.valueOf();
	      }
	      if (value != null) {
	        value = value.valueOf();
	      }
	      if (Array.isArray(target)) {
	        for (j = 0, len = target.length; j < len; j++) {
	          insTarget = target[j];
	          this.instruction(insTarget);
	        }
	      } else if (isObject(target)) {
	        for (insTarget in target) {
	          if (!hasProp.call(target, insTarget)) continue;
	          insValue = target[insTarget];
	          this.instruction(insTarget, insValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        instruction = new XMLProcessingInstruction(this, target, value);
	        this.children.push(instruction);
	      }
	      return this;
	    };

	    XMLNode.prototype.instructionBefore = function(target, value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.instruction(target, value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };

	    XMLNode.prototype.instructionAfter = function(target, value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.instruction(target, value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };

	    XMLNode.prototype.declaration = function(version, encoding, standalone) {
	      var doc, xmldec;
	      doc = this.document();
	      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
	      if (doc.children[0] instanceof XMLDeclaration) {
	        doc.children[0] = xmldec;
	      } else {
	        doc.children.unshift(xmldec);
	      }
	      return doc.root() || doc;
	    };

	    XMLNode.prototype.doctype = function(pubID, sysID) {
	      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
	      doc = this.document();
	      doctype = new XMLDocType(doc, pubID, sysID);
	      ref1 = doc.children;
	      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
	        child = ref1[i];
	        if (child instanceof XMLDocType) {
	          doc.children[i] = doctype;
	          return doctype;
	        }
	      }
	      ref2 = doc.children;
	      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
	        child = ref2[i];
	        if (child.isRoot) {
	          doc.children.splice(i, 0, doctype);
	          return doctype;
	        }
	      }
	      doc.children.push(doctype);
	      return doctype;
	    };

	    XMLNode.prototype.up = function() {
	      if (this.isRoot) {
	        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
	      }
	      return this.parent;
	    };

	    XMLNode.prototype.root = function() {
	      var node;
	      node = this;
	      while (node) {
	        if (node.isDocument) {
	          return node.rootObject;
	        } else if (node.isRoot) {
	          return node;
	        } else {
	          node = node.parent;
	        }
	      }
	    };

	    XMLNode.prototype.document = function() {
	      var node;
	      node = this;
	      while (node) {
	        if (node.isDocument) {
	          return node;
	        } else {
	          node = node.parent;
	        }
	      }
	    };

	    XMLNode.prototype.end = function(options) {
	      return this.document().end(options);
	    };

	    XMLNode.prototype.prev = function() {
	      var i;
	      i = this.parent.children.indexOf(this);
	      if (i < 1) {
	        throw new Error("Already at the first node");
	      }
	      return this.parent.children[i - 1];
	    };

	    XMLNode.prototype.next = function() {
	      var i;
	      i = this.parent.children.indexOf(this);
	      if (i === -1 || i === this.parent.children.length - 1) {
	        throw new Error("Already at the last node");
	      }
	      return this.parent.children[i + 1];
	    };

	    XMLNode.prototype.importDocument = function(doc) {
	      var clonedRoot;
	      clonedRoot = doc.root().clone();
	      clonedRoot.parent = this;
	      clonedRoot.isRoot = false;
	      this.children.push(clonedRoot);
	      return this;
	    };

	    XMLNode.prototype.ele = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };

	    XMLNode.prototype.nod = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLNode.prototype.txt = function(value) {
	      return this.text(value);
	    };

	    XMLNode.prototype.dat = function(value) {
	      return this.cdata(value);
	    };

	    XMLNode.prototype.com = function(value) {
	      return this.comment(value);
	    };

	    XMLNode.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLNode.prototype.doc = function() {
	      return this.document();
	    };

	    XMLNode.prototype.dec = function(version, encoding, standalone) {
	      return this.declaration(version, encoding, standalone);
	    };

	    XMLNode.prototype.dtd = function(pubID, sysID) {
	      return this.doctype(pubID, sysID);
	    };

	    XMLNode.prototype.e = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };

	    XMLNode.prototype.n = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLNode.prototype.t = function(value) {
	      return this.text(value);
	    };

	    XMLNode.prototype.d = function(value) {
	      return this.cdata(value);
	    };

	    XMLNode.prototype.c = function(value) {
	      return this.comment(value);
	    };

	    XMLNode.prototype.r = function(value) {
	      return this.raw(value);
	    };

	    XMLNode.prototype.i = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLNode.prototype.u = function() {
	      return this.up();
	    };

	    XMLNode.prototype.importXMLBuilder = function(doc) {
	      return this.importDocument(doc);
	    };

	    return XMLNode;

	  })();

	}).call(this);


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  ref = __webpack_require__(254), isObject = ref.isObject, isFunction = ref.isFunction;

	  XMLNode = __webpack_require__(256);

	  XMLAttribute = __webpack_require__(258);

	  module.exports = XMLElement = (function(superClass) {
	    extend(XMLElement, superClass);

	    function XMLElement(parent, name, attributes) {
	      XMLElement.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing element name");
	      }
	      this.name = this.stringify.eleName(name);
	      this.attributes = {};
	      if (attributes != null) {
	        this.attribute(attributes);
	      }
	      if (parent.isDocument) {
	        this.isRoot = true;
	        this.documentObject = parent;
	        parent.rootObject = this;
	      }
	    }

	    XMLElement.prototype.clone = function() {
	      var att, attName, clonedSelf, ref1;
	      clonedSelf = Object.create(this);
	      if (clonedSelf.isRoot) {
	        clonedSelf.documentObject = null;
	      }
	      clonedSelf.attributes = {};
	      ref1 = this.attributes;
	      for (attName in ref1) {
	        if (!hasProp.call(ref1, attName)) continue;
	        att = ref1[attName];
	        clonedSelf.attributes[attName] = att.clone();
	      }
	      clonedSelf.children = [];
	      this.children.forEach(function(child) {
	        var clonedChild;
	        clonedChild = child.clone();
	        clonedChild.parent = clonedSelf;
	        return clonedSelf.children.push(clonedChild);
	      });
	      return clonedSelf;
	    };

	    XMLElement.prototype.attribute = function(name, value) {
	      var attName, attValue;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (isObject(name)) {
	        for (attName in name) {
	          if (!hasProp.call(name, attName)) continue;
	          attValue = name[attName];
	          this.attribute(attName, attValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        if (!this.options.skipNullAttributes || (value != null)) {
	          this.attributes[name] = new XMLAttribute(this, name, value);
	        }
	      }
	      return this;
	    };

	    XMLElement.prototype.removeAttribute = function(name) {
	      var attName, i, len;
	      if (name == null) {
	        throw new Error("Missing attribute name");
	      }
	      name = name.valueOf();
	      if (Array.isArray(name)) {
	        for (i = 0, len = name.length; i < len; i++) {
	          attName = name[i];
	          delete this.attributes[attName];
	        }
	      } else {
	        delete this.attributes[name];
	      }
	      return this;
	    };

	    XMLElement.prototype.toString = function(options) {
	      return this.options.writer.set(options).element(this);
	    };

	    XMLElement.prototype.att = function(name, value) {
	      return this.attribute(name, value);
	    };

	    XMLElement.prototype.a = function(name, value) {
	      return this.attribute(name, value);
	    };

	    return XMLElement;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 258 */
/***/ (function(module, exports) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLAttribute;

	  module.exports = XMLAttribute = (function() {
	    function XMLAttribute(parent, name, value) {
	      this.options = parent.options;
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing attribute name of element " + parent.name);
	      }
	      if (value == null) {
	        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
	      }
	      this.name = this.stringify.attName(name);
	      this.value = this.stringify.attValue(value);
	    }

	    XMLAttribute.prototype.clone = function() {
	      return Object.create(this);
	    };

	    XMLAttribute.prototype.toString = function(options) {
	      return this.options.writer.set(options).attribute(this);
	    };

	    return XMLAttribute;

	  })();

	}).call(this);


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLCData, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLCData = (function(superClass) {
	    extend(XMLCData, superClass);

	    function XMLCData(parent, text) {
	      XMLCData.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing CDATA text");
	      }
	      this.text = this.stringify.cdata(text);
	    }

	    XMLCData.prototype.clone = function() {
	      return Object.create(this);
	    };

	    XMLCData.prototype.toString = function(options) {
	      return this.options.writer.set(options).cdata(this);
	    };

	    return XMLCData;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLComment, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLComment = (function(superClass) {
	    extend(XMLComment, superClass);

	    function XMLComment(parent, text) {
	      XMLComment.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing comment text");
	      }
	      this.text = this.stringify.comment(text);
	    }

	    XMLComment.prototype.clone = function() {
	      return Object.create(this);
	    };

	    XMLComment.prototype.toString = function(options) {
	      return this.options.writer.set(options).comment(this);
	    };

	    return XMLComment;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDeclaration, XMLNode, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  isObject = __webpack_require__(254).isObject;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLDeclaration = (function(superClass) {
	    extend(XMLDeclaration, superClass);

	    function XMLDeclaration(parent, version, encoding, standalone) {
	      var ref;
	      XMLDeclaration.__super__.constructor.call(this, parent);
	      if (isObject(version)) {
	        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
	      }
	      if (!version) {
	        version = '1.0';
	      }
	      this.version = this.stringify.xmlVersion(version);
	      if (encoding != null) {
	        this.encoding = this.stringify.xmlEncoding(encoding);
	      }
	      if (standalone != null) {
	        this.standalone = this.stringify.xmlStandalone(standalone);
	      }
	    }

	    XMLDeclaration.prototype.toString = function(options) {
	      return this.options.writer.set(options).declaration(this);
	    };

	    return XMLDeclaration;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  isObject = __webpack_require__(254).isObject;

	  XMLNode = __webpack_require__(256);

	  XMLDTDAttList = __webpack_require__(263);

	  XMLDTDEntity = __webpack_require__(264);

	  XMLDTDElement = __webpack_require__(265);

	  XMLDTDNotation = __webpack_require__(266);

	  module.exports = XMLDocType = (function(superClass) {
	    extend(XMLDocType, superClass);

	    function XMLDocType(parent, pubID, sysID) {
	      var ref, ref1;
	      XMLDocType.__super__.constructor.call(this, parent);
	      this.documentObject = parent;
	      if (isObject(pubID)) {
	        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
	      }
	      if (sysID == null) {
	        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
	      }
	      if (pubID != null) {
	        this.pubID = this.stringify.dtdPubID(pubID);
	      }
	      if (sysID != null) {
	        this.sysID = this.stringify.dtdSysID(sysID);
	      }
	    }

	    XMLDocType.prototype.element = function(name, value) {
	      var child;
	      child = new XMLDTDElement(this, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      var child;
	      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.entity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, false, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.pEntity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, true, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.notation = function(name, value) {
	      var child;
	      child = new XMLDTDNotation(this, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.toString = function(options) {
	      return this.options.writer.set(options).docType(this);
	    };

	    XMLDocType.prototype.ele = function(name, value) {
	      return this.element(name, value);
	    };

	    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
	    };

	    XMLDocType.prototype.ent = function(name, value) {
	      return this.entity(name, value);
	    };

	    XMLDocType.prototype.pent = function(name, value) {
	      return this.pEntity(name, value);
	    };

	    XMLDocType.prototype.not = function(name, value) {
	      return this.notation(name, value);
	    };

	    XMLDocType.prototype.up = function() {
	      return this.root() || this.documentObject;
	    };

	    return XMLDocType;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDTDAttList, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLDTDAttList = (function(superClass) {
	    extend(XMLDTDAttList, superClass);

	    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      XMLDTDAttList.__super__.constructor.call(this, parent);
	      if (elementName == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (attributeName == null) {
	        throw new Error("Missing DTD attribute name");
	      }
	      if (!attributeType) {
	        throw new Error("Missing DTD attribute type");
	      }
	      if (!defaultValueType) {
	        throw new Error("Missing DTD attribute default");
	      }
	      if (defaultValueType.indexOf('#') !== 0) {
	        defaultValueType = '#' + defaultValueType;
	      }
	      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
	        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
	      }
	      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
	        throw new Error("Default value only applies to #FIXED or #DEFAULT");
	      }
	      this.elementName = this.stringify.eleName(elementName);
	      this.attributeName = this.stringify.attName(attributeName);
	      this.attributeType = this.stringify.dtdAttType(attributeType);
	      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
	      this.defaultValueType = defaultValueType;
	    }

	    XMLDTDAttList.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdAttList(this);
	    };

	    return XMLDTDAttList;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDTDEntity, XMLNode, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  isObject = __webpack_require__(254).isObject;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLDTDEntity = (function(superClass) {
	    extend(XMLDTDEntity, superClass);

	    function XMLDTDEntity(parent, pe, name, value) {
	      XMLDTDEntity.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing entity name");
	      }
	      if (value == null) {
	        throw new Error("Missing entity value");
	      }
	      this.pe = !!pe;
	      this.name = this.stringify.eleName(name);
	      if (!isObject(value)) {
	        this.value = this.stringify.dtdEntityValue(value);
	      } else {
	        if (!value.pubID && !value.sysID) {
	          throw new Error("Public and/or system identifiers are required for an external entity");
	        }
	        if (value.pubID && !value.sysID) {
	          throw new Error("System identifier is required for a public external entity");
	        }
	        if (value.pubID != null) {
	          this.pubID = this.stringify.dtdPubID(value.pubID);
	        }
	        if (value.sysID != null) {
	          this.sysID = this.stringify.dtdSysID(value.sysID);
	        }
	        if (value.nData != null) {
	          this.nData = this.stringify.dtdNData(value.nData);
	        }
	        if (this.pe && this.nData) {
	          throw new Error("Notation declaration is not allowed in a parameter entity");
	        }
	      }
	    }

	    XMLDTDEntity.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdEntity(this);
	    };

	    return XMLDTDEntity;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDTDElement, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLDTDElement = (function(superClass) {
	    extend(XMLDTDElement, superClass);

	    function XMLDTDElement(parent, name, value) {
	      XMLDTDElement.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (!value) {
	        value = '(#PCDATA)';
	      }
	      if (Array.isArray(value)) {
	        value = '(' + value.join(',') + ')';
	      }
	      this.name = this.stringify.eleName(name);
	      this.value = this.stringify.dtdElementValue(value);
	    }

	    XMLDTDElement.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdElement(this);
	    };

	    return XMLDTDElement;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLDTDNotation, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLDTDNotation = (function(superClass) {
	    extend(XMLDTDNotation, superClass);

	    function XMLDTDNotation(parent, name, value) {
	      XMLDTDNotation.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing notation name");
	      }
	      if (!value.pubID && !value.sysID) {
	        throw new Error("Public or system identifiers are required for an external entity");
	      }
	      this.name = this.stringify.eleName(name);
	      if (value.pubID != null) {
	        this.pubID = this.stringify.dtdPubID(value.pubID);
	      }
	      if (value.sysID != null) {
	        this.sysID = this.stringify.dtdSysID(value.sysID);
	      }
	    }

	    XMLDTDNotation.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdNotation(this);
	    };

	    return XMLDTDNotation;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLNode, XMLRaw,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLRaw = (function(superClass) {
	    extend(XMLRaw, superClass);

	    function XMLRaw(parent, text) {
	      XMLRaw.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing raw text");
	      }
	      this.value = this.stringify.raw(text);
	    }

	    XMLRaw.prototype.clone = function() {
	      return Object.create(this);
	    };

	    XMLRaw.prototype.toString = function(options) {
	      return this.options.writer.set(options).raw(this);
	    };

	    return XMLRaw;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLNode, XMLText,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLText = (function(superClass) {
	    extend(XMLText, superClass);

	    function XMLText(parent, text) {
	      XMLText.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing element text");
	      }
	      this.value = this.stringify.eleText(text);
	    }

	    XMLText.prototype.clone = function() {
	      return Object.create(this);
	    };

	    XMLText.prototype.toString = function(options) {
	      return this.options.writer.set(options).text(this);
	    };

	    return XMLText;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLNode, XMLProcessingInstruction,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLNode = __webpack_require__(256);

	  module.exports = XMLProcessingInstruction = (function(superClass) {
	    extend(XMLProcessingInstruction, superClass);

	    function XMLProcessingInstruction(parent, target, value) {
	      XMLProcessingInstruction.__super__.constructor.call(this, parent);
	      if (target == null) {
	        throw new Error("Missing instruction target");
	      }
	      this.target = this.stringify.insTarget(target);
	      if (value) {
	        this.value = this.stringify.insValue(value);
	      }
	    }

	    XMLProcessingInstruction.prototype.clone = function() {
	      return Object.create(this);
	    };

	    XMLProcessingInstruction.prototype.toString = function(options) {
	      return this.options.writer.set(options).processingInstruction(this);
	    };

	    return XMLProcessingInstruction;

	  })(XMLNode);

	}).call(this);


/***/ }),
/* 270 */
/***/ (function(module, exports) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLStringifier,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    hasProp = {}.hasOwnProperty;

	  module.exports = XMLStringifier = (function() {
	    function XMLStringifier(options) {
	      this.assertLegalChar = bind(this.assertLegalChar, this);
	      var key, ref, value;
	      options || (options = {});
	      this.noDoubleEncoding = options.noDoubleEncoding;
	      ref = options.stringify || {};
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this[key] = value;
	      }
	    }

	    XMLStringifier.prototype.eleName = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.eleText = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(this.elEscape(val));
	    };

	    XMLStringifier.prototype.cdata = function(val) {
	      val = '' + val || '';
	      val = val.replace(']]>', ']]]]><![CDATA[>');
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.comment = function(val) {
	      val = '' + val || '';
	      if (val.match(/--/)) {
	        throw new Error("Comment text cannot contain double-hypen: " + val);
	      }
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.raw = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.attName = function(val) {
	      return val = '' + val || '';
	    };

	    XMLStringifier.prototype.attValue = function(val) {
	      val = '' + val || '';
	      return this.attEscape(val);
	    };

	    XMLStringifier.prototype.insTarget = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.insValue = function(val) {
	      val = '' + val || '';
	      if (val.match(/\?>/)) {
	        throw new Error("Invalid processing instruction value: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlVersion = function(val) {
	      val = '' + val || '';
	      if (!val.match(/1\.[0-9]+/)) {
	        throw new Error("Invalid version number: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlEncoding = function(val) {
	      val = '' + val || '';
	      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
	        throw new Error("Invalid encoding: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlStandalone = function(val) {
	      if (val) {
	        return "yes";
	      } else {
	        return "no";
	      }
	    };

	    XMLStringifier.prototype.dtdPubID = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdSysID = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdElementValue = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdAttType = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdAttDefault = function(val) {
	      if (val != null) {
	        return '' + val || '';
	      } else {
	        return val;
	      }
	    };

	    XMLStringifier.prototype.dtdEntityValue = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdNData = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.convertAttKey = '@';

	    XMLStringifier.prototype.convertPIKey = '?';

	    XMLStringifier.prototype.convertTextKey = '#text';

	    XMLStringifier.prototype.convertCDataKey = '#cdata';

	    XMLStringifier.prototype.convertCommentKey = '#comment';

	    XMLStringifier.prototype.convertRawKey = '#raw';

	    XMLStringifier.prototype.assertLegalChar = function(str) {
	      var res;
	      res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
	      if (res) {
	        throw new Error("Invalid character in string: " + str + " at index " + res.index);
	      }
	      return str;
	    };

	    XMLStringifier.prototype.elEscape = function(str) {
	      var ampregex;
	      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
	      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
	    };

	    XMLStringifier.prototype.attEscape = function(str) {
	      var ampregex;
	      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
	      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
	    };

	    return XMLStringifier;

	  })();

	}).call(this);


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLDeclaration = __webpack_require__(261);

	  XMLDocType = __webpack_require__(262);

	  XMLCData = __webpack_require__(259);

	  XMLComment = __webpack_require__(260);

	  XMLElement = __webpack_require__(257);

	  XMLRaw = __webpack_require__(267);

	  XMLText = __webpack_require__(268);

	  XMLProcessingInstruction = __webpack_require__(269);

	  XMLDTDAttList = __webpack_require__(263);

	  XMLDTDElement = __webpack_require__(265);

	  XMLDTDEntity = __webpack_require__(264);

	  XMLDTDNotation = __webpack_require__(266);

	  XMLWriterBase = __webpack_require__(272);

	  module.exports = XMLStringWriter = (function(superClass) {
	    extend(XMLStringWriter, superClass);

	    function XMLStringWriter(options) {
	      XMLStringWriter.__super__.constructor.call(this, options);
	    }

	    XMLStringWriter.prototype.document = function(doc) {
	      var child, i, len, r, ref;
	      this.textispresent = false;
	      r = '';
	      ref = doc.children;
	      for (i = 0, len = ref.length; i < len; i++) {
	        child = ref[i];
	        r += (function() {
	          switch (false) {
	            case !(child instanceof XMLDeclaration):
	              return this.declaration(child);
	            case !(child instanceof XMLDocType):
	              return this.docType(child);
	            case !(child instanceof XMLComment):
	              return this.comment(child);
	            case !(child instanceof XMLProcessingInstruction):
	              return this.processingInstruction(child);
	            default:
	              return this.element(child, 0);
	          }
	        }).call(this);
	      }
	      if (this.pretty && r.slice(-this.newline.length) === this.newline) {
	        r = r.slice(0, -this.newline.length);
	      }
	      return r;
	    };

	    XMLStringWriter.prototype.attribute = function(att) {
	      return ' ' + att.name + '="' + att.value + '"';
	    };

	    XMLStringWriter.prototype.cdata = function(node, level) {
	      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
	    };

	    XMLStringWriter.prototype.comment = function(node, level) {
	      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
	    };

	    XMLStringWriter.prototype.declaration = function(node, level) {
	      var r;
	      r = this.space(level);
	      r += '<?xml version="' + node.version + '"';
	      if (node.encoding != null) {
	        r += ' encoding="' + node.encoding + '"';
	      }
	      if (node.standalone != null) {
	        r += ' standalone="' + node.standalone + '"';
	      }
	      r += this.spacebeforeslash + '?>';
	      r += this.newline;
	      return r;
	    };

	    XMLStringWriter.prototype.docType = function(node, level) {
	      var child, i, len, r, ref;
	      level || (level = 0);
	      r = this.space(level);
	      r += '<!DOCTYPE ' + node.root().name;
	      if (node.pubID && node.sysID) {
	        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	      } else if (node.sysID) {
	        r += ' SYSTEM "' + node.sysID + '"';
	      }
	      if (node.children.length > 0) {
	        r += ' [';
	        r += this.newline;
	        ref = node.children;
	        for (i = 0, len = ref.length; i < len; i++) {
	          child = ref[i];
	          r += (function() {
	            switch (false) {
	              case !(child instanceof XMLDTDAttList):
	                return this.dtdAttList(child, level + 1);
	              case !(child instanceof XMLDTDElement):
	                return this.dtdElement(child, level + 1);
	              case !(child instanceof XMLDTDEntity):
	                return this.dtdEntity(child, level + 1);
	              case !(child instanceof XMLDTDNotation):
	                return this.dtdNotation(child, level + 1);
	              case !(child instanceof XMLCData):
	                return this.cdata(child, level + 1);
	              case !(child instanceof XMLComment):
	                return this.comment(child, level + 1);
	              case !(child instanceof XMLProcessingInstruction):
	                return this.processingInstruction(child, level + 1);
	              default:
	                throw new Error("Unknown DTD node type: " + child.constructor.name);
	            }
	          }).call(this);
	        }
	        r += ']';
	      }
	      r += this.spacebeforeslash + '>';
	      r += this.newline;
	      return r;
	    };

	    XMLStringWriter.prototype.element = function(node, level) {
	      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
	      level || (level = 0);
	      textispresentwasset = false;
	      if (this.textispresent) {
	        this.newline = '';
	        this.pretty = false;
	      } else {
	        this.newline = this.newlinedefault;
	        this.pretty = this.prettydefault;
	      }
	      space = this.space(level);
	      r = '';
	      r += space + '<' + node.name;
	      ref = node.attributes;
	      for (name in ref) {
	        if (!hasProp.call(ref, name)) continue;
	        att = ref[name];
	        r += this.attribute(att);
	      }
	      if (node.children.length === 0 || node.children.every(function(e) {
	        return e.value === '';
	      })) {
	        if (this.allowEmpty) {
	          r += '></' + node.name + '>' + this.newline;
	        } else {
	          r += this.spacebeforeslash + '/>' + this.newline;
	        }
	      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
	        r += '>';
	        r += node.children[0].value;
	        r += '</' + node.name + '>' + this.newline;
	      } else {
	        if (this.dontprettytextnodes) {
	          ref1 = node.children;
	          for (i = 0, len = ref1.length; i < len; i++) {
	            child = ref1[i];
	            if (child.value != null) {
	              this.textispresent++;
	              textispresentwasset = true;
	              break;
	            }
	          }
	        }
	        if (this.textispresent) {
	          this.newline = '';
	          this.pretty = false;
	          space = this.space(level);
	        }
	        r += '>' + this.newline;
	        ref2 = node.children;
	        for (j = 0, len1 = ref2.length; j < len1; j++) {
	          child = ref2[j];
	          r += (function() {
	            switch (false) {
	              case !(child instanceof XMLCData):
	                return this.cdata(child, level + 1);
	              case !(child instanceof XMLComment):
	                return this.comment(child, level + 1);
	              case !(child instanceof XMLElement):
	                return this.element(child, level + 1);
	              case !(child instanceof XMLRaw):
	                return this.raw(child, level + 1);
	              case !(child instanceof XMLText):
	                return this.text(child, level + 1);
	              case !(child instanceof XMLProcessingInstruction):
	                return this.processingInstruction(child, level + 1);
	              default:
	                throw new Error("Unknown XML node type: " + child.constructor.name);
	            }
	          }).call(this);
	        }
	        if (textispresentwasset) {
	          this.textispresent--;
	        }
	        if (!this.textispresent) {
	          this.newline = this.newlinedefault;
	          this.pretty = this.prettydefault;
	        }
	        r += space + '</' + node.name + '>' + this.newline;
	      }
	      return r;
	    };

	    XMLStringWriter.prototype.processingInstruction = function(node, level) {
	      var r;
	      r = this.space(level) + '<?' + node.target;
	      if (node.value) {
	        r += ' ' + node.value;
	      }
	      r += this.spacebeforeslash + '?>' + this.newline;
	      return r;
	    };

	    XMLStringWriter.prototype.raw = function(node, level) {
	      return this.space(level) + node.value + this.newline;
	    };

	    XMLStringWriter.prototype.text = function(node, level) {
	      return this.space(level) + node.value + this.newline;
	    };

	    XMLStringWriter.prototype.dtdAttList = function(node, level) {
	      var r;
	      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
	      if (node.defaultValueType !== '#DEFAULT') {
	        r += ' ' + node.defaultValueType;
	      }
	      if (node.defaultValue) {
	        r += ' "' + node.defaultValue + '"';
	      }
	      r += this.spacebeforeslash + '>' + this.newline;
	      return r;
	    };

	    XMLStringWriter.prototype.dtdElement = function(node, level) {
	      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
	    };

	    XMLStringWriter.prototype.dtdEntity = function(node, level) {
	      var r;
	      r = this.space(level) + '<!ENTITY';
	      if (node.pe) {
	        r += ' %';
	      }
	      r += ' ' + node.name;
	      if (node.value) {
	        r += ' "' + node.value + '"';
	      } else {
	        if (node.pubID && node.sysID) {
	          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	        } else if (node.sysID) {
	          r += ' SYSTEM "' + node.sysID + '"';
	        }
	        if (node.nData) {
	          r += ' NDATA ' + node.nData;
	        }
	      }
	      r += this.spacebeforeslash + '>' + this.newline;
	      return r;
	    };

	    XMLStringWriter.prototype.dtdNotation = function(node, level) {
	      var r;
	      r = this.space(level) + '<!NOTATION ' + node.name;
	      if (node.pubID && node.sysID) {
	        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	      } else if (node.pubID) {
	        r += ' PUBLIC "' + node.pubID + '"';
	      } else if (node.sysID) {
	        r += ' SYSTEM "' + node.sysID + '"';
	      }
	      r += this.spacebeforeslash + '>' + this.newline;
	      return r;
	    };

	    XMLStringWriter.prototype.openNode = function(node, level) {
	      var att, name, r, ref;
	      level || (level = 0);
	      if (node instanceof XMLElement) {
	        r = this.space(level) + '<' + node.name;
	        ref = node.attributes;
	        for (name in ref) {
	          if (!hasProp.call(ref, name)) continue;
	          att = ref[name];
	          r += this.attribute(att);
	        }
	        r += (node.children ? '>' : '/>') + this.newline;
	        return r;
	      } else {
	        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
	        if (node.pubID && node.sysID) {
	          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	        } else if (node.sysID) {
	          r += ' SYSTEM "' + node.sysID + '"';
	        }
	        r += (node.children ? ' [' : '>') + this.newline;
	        return r;
	      }
	    };

	    XMLStringWriter.prototype.closeNode = function(node, level) {
	      level || (level = 0);
	      switch (false) {
	        case !(node instanceof XMLElement):
	          return this.space(level) + '</' + node.name + '>' + this.newline;
	        case !(node instanceof XMLDocType):
	          return this.space(level) + ']>' + this.newline;
	      }
	    };

	    return XMLStringWriter;

	  })(XMLWriterBase);

	}).call(this);


/***/ }),
/* 272 */
/***/ (function(module, exports) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLWriterBase,
	    hasProp = {}.hasOwnProperty;

	  module.exports = XMLWriterBase = (function() {
	    function XMLWriterBase(options) {
	      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
	      options || (options = {});
	      this.pretty = options.pretty || false;
	      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
	      if (this.pretty) {
	        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
	        this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
	        this.offset = (ref3 = options.offset) != null ? ref3 : 0;
	        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
	      } else {
	        this.indent = '';
	        this.newline = '';
	        this.offset = 0;
	        this.dontprettytextnodes = 0;
	      }
	      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
	      if (this.spacebeforeslash === true) {
	        this.spacebeforeslash = ' ';
	      }
	      this.newlinedefault = this.newline;
	      this.prettydefault = this.pretty;
	      ref6 = options.writer || {};
	      for (key in ref6) {
	        if (!hasProp.call(ref6, key)) continue;
	        value = ref6[key];
	        this[key] = value;
	      }
	    }

	    XMLWriterBase.prototype.set = function(options) {
	      var key, ref, value;
	      options || (options = {});
	      if ("pretty" in options) {
	        this.pretty = options.pretty;
	      }
	      if ("allowEmpty" in options) {
	        this.allowEmpty = options.allowEmpty;
	      }
	      if (this.pretty) {
	        this.indent = "indent" in options ? options.indent : '  ';
	        this.newline = "newline" in options ? options.newline : '\n';
	        this.offset = "offset" in options ? options.offset : 0;
	        this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
	      } else {
	        this.indent = '';
	        this.newline = '';
	        this.offset = 0;
	        this.dontprettytextnodes = 0;
	      }
	      this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : '';
	      if (this.spacebeforeslash === true) {
	        this.spacebeforeslash = ' ';
	      }
	      this.newlinedefault = this.newline;
	      this.prettydefault = this.pretty;
	      ref = options.writer || {};
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this[key] = value;
	      }
	      return this;
	    };

	    XMLWriterBase.prototype.space = function(level) {
	      var indent;
	      if (this.pretty) {
	        indent = (level || 0) + this.offset + 1;
	        if (indent > 0) {
	          return new Array(indent).join(this.indent);
	        } else {
	          return '';
	        }
	      } else {
	        return '';
	      }
	    };

	    return XMLWriterBase;

	  })();

	}).call(this);


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,
	    hasProp = {}.hasOwnProperty;

	  ref = __webpack_require__(254), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

	  XMLElement = __webpack_require__(257);

	  XMLCData = __webpack_require__(259);

	  XMLComment = __webpack_require__(260);

	  XMLRaw = __webpack_require__(267);

	  XMLText = __webpack_require__(268);

	  XMLProcessingInstruction = __webpack_require__(269);

	  XMLDeclaration = __webpack_require__(261);

	  XMLDocType = __webpack_require__(262);

	  XMLDTDAttList = __webpack_require__(263);

	  XMLDTDEntity = __webpack_require__(264);

	  XMLDTDElement = __webpack_require__(265);

	  XMLDTDNotation = __webpack_require__(266);

	  XMLAttribute = __webpack_require__(258);

	  XMLStringifier = __webpack_require__(270);

	  XMLStringWriter = __webpack_require__(271);

	  module.exports = XMLDocumentCB = (function() {
	    function XMLDocumentCB(options, onData, onEnd) {
	      var writerOptions;
	      options || (options = {});
	      if (!options.writer) {
	        options.writer = new XMLStringWriter(options);
	      } else if (isPlainObject(options.writer)) {
	        writerOptions = options.writer;
	        options.writer = new XMLStringWriter(writerOptions);
	      }
	      this.options = options;
	      this.writer = options.writer;
	      this.stringify = new XMLStringifier(options);
	      this.onDataCallback = onData || function() {};
	      this.onEndCallback = onEnd || function() {};
	      this.currentNode = null;
	      this.currentLevel = -1;
	      this.openTags = {};
	      this.documentStarted = false;
	      this.documentCompleted = false;
	      this.root = null;
	    }

	    XMLDocumentCB.prototype.node = function(name, attributes, text) {
	      var ref1;
	      if (name == null) {
	        throw new Error("Missing node name");
	      }
	      if (this.root && this.currentLevel === -1) {
	        throw new Error("Document can only have one root node");
	      }
	      this.openCurrent();
	      name = name.valueOf();
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
	      }
	      this.currentNode = new XMLElement(this, name, attributes);
	      this.currentNode.children = false;
	      this.currentLevel++;
	      this.openTags[this.currentLevel] = this.currentNode;
	      if (text != null) {
	        this.text(text);
	      }
	      return this;
	    };

	    XMLDocumentCB.prototype.element = function(name, attributes, text) {
	      if (this.currentNode && this.currentNode instanceof XMLDocType) {
	        return this.dtdElement.apply(this, arguments);
	      } else {
	        return this.node(name, attributes, text);
	      }
	    };

	    XMLDocumentCB.prototype.attribute = function(name, value) {
	      var attName, attValue;
	      if (!this.currentNode || this.currentNode.children) {
	        throw new Error("att() can only be used immediately after an ele() call in callback mode");
	      }
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (isObject(name)) {
	        for (attName in name) {
	          if (!hasProp.call(name, attName)) continue;
	          attValue = name[attName];
	          this.attribute(attName, attValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        if (!this.options.skipNullAttributes || (value != null)) {
	          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
	        }
	      }
	      return this;
	    };

	    XMLDocumentCB.prototype.text = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLText(this, value);
	      this.onData(this.writer.text(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.cdata = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLCData(this, value);
	      this.onData(this.writer.cdata(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.comment = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLComment(this, value);
	      this.onData(this.writer.comment(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.raw = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLRaw(this, value);
	      this.onData(this.writer.raw(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.instruction = function(target, value) {
	      var i, insTarget, insValue, len, node;
	      this.openCurrent();
	      if (target != null) {
	        target = target.valueOf();
	      }
	      if (value != null) {
	        value = value.valueOf();
	      }
	      if (Array.isArray(target)) {
	        for (i = 0, len = target.length; i < len; i++) {
	          insTarget = target[i];
	          this.instruction(insTarget);
	        }
	      } else if (isObject(target)) {
	        for (insTarget in target) {
	          if (!hasProp.call(target, insTarget)) continue;
	          insValue = target[insTarget];
	          this.instruction(insTarget, insValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        node = new XMLProcessingInstruction(this, target, value);
	        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
	      }
	      return this;
	    };

	    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
	      var node;
	      this.openCurrent();
	      if (this.documentStarted) {
	        throw new Error("declaration() must be the first node");
	      }
	      node = new XMLDeclaration(this, version, encoding, standalone);
	      this.onData(this.writer.declaration(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
	      this.openCurrent();
	      if (root == null) {
	        throw new Error("Missing root node name");
	      }
	      if (this.root) {
	        throw new Error("dtd() must come before the root node");
	      }
	      this.currentNode = new XMLDocType(this, pubID, sysID);
	      this.currentNode.rootNodeName = root;
	      this.currentNode.children = false;
	      this.currentLevel++;
	      this.openTags[this.currentLevel] = this.currentNode;
	      return this;
	    };

	    XMLDocumentCB.prototype.dtdElement = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDElement(this, name, value);
	      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
	      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.entity = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDEntity(this, false, name, value);
	      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.pEntity = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDEntity(this, true, name, value);
	      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.notation = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDNotation(this, name, value);
	      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
	      return this;
	    };

	    XMLDocumentCB.prototype.up = function() {
	      if (this.currentLevel < 0) {
	        throw new Error("The document node has no parent");
	      }
	      if (this.currentNode) {
	        if (this.currentNode.children) {
	          this.closeNode(this.currentNode);
	        } else {
	          this.openNode(this.currentNode);
	        }
	        this.currentNode = null;
	      } else {
	        this.closeNode(this.openTags[this.currentLevel]);
	      }
	      delete this.openTags[this.currentLevel];
	      this.currentLevel--;
	      return this;
	    };

	    XMLDocumentCB.prototype.end = function() {
	      while (this.currentLevel >= 0) {
	        this.up();
	      }
	      return this.onEnd();
	    };

	    XMLDocumentCB.prototype.openCurrent = function() {
	      if (this.currentNode) {
	        this.currentNode.children = true;
	        return this.openNode(this.currentNode);
	      }
	    };

	    XMLDocumentCB.prototype.openNode = function(node) {
	      if (!node.isOpen) {
	        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
	          this.root = node;
	        }
	        this.onData(this.writer.openNode(node, this.currentLevel));
	        return node.isOpen = true;
	      }
	    };

	    XMLDocumentCB.prototype.closeNode = function(node) {
	      if (!node.isClosed) {
	        this.onData(this.writer.closeNode(node, this.currentLevel));
	        return node.isClosed = true;
	      }
	    };

	    XMLDocumentCB.prototype.onData = function(chunk) {
	      this.documentStarted = true;
	      return this.onDataCallback(chunk);
	    };

	    XMLDocumentCB.prototype.onEnd = function() {
	      this.documentCompleted = true;
	      return this.onEndCallback();
	    };

	    XMLDocumentCB.prototype.ele = function() {
	      return this.element.apply(this, arguments);
	    };

	    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLDocumentCB.prototype.txt = function(value) {
	      return this.text(value);
	    };

	    XMLDocumentCB.prototype.dat = function(value) {
	      return this.cdata(value);
	    };

	    XMLDocumentCB.prototype.com = function(value) {
	      return this.comment(value);
	    };

	    XMLDocumentCB.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
	      return this.declaration(version, encoding, standalone);
	    };

	    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
	      return this.doctype(root, pubID, sysID);
	    };

	    XMLDocumentCB.prototype.e = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };

	    XMLDocumentCB.prototype.n = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLDocumentCB.prototype.t = function(value) {
	      return this.text(value);
	    };

	    XMLDocumentCB.prototype.d = function(value) {
	      return this.cdata(value);
	    };

	    XMLDocumentCB.prototype.c = function(value) {
	      return this.comment(value);
	    };

	    XMLDocumentCB.prototype.r = function(value) {
	      return this.raw(value);
	    };

	    XMLDocumentCB.prototype.i = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLDocumentCB.prototype.att = function() {
	      if (this.currentNode && this.currentNode instanceof XMLDocType) {
	        return this.attList.apply(this, arguments);
	      } else {
	        return this.attribute.apply(this, arguments);
	      }
	    };

	    XMLDocumentCB.prototype.a = function() {
	      if (this.currentNode && this.currentNode instanceof XMLDocType) {
	        return this.attList.apply(this, arguments);
	      } else {
	        return this.attribute.apply(this, arguments);
	      }
	    };

	    XMLDocumentCB.prototype.ent = function(name, value) {
	      return this.entity(name, value);
	    };

	    XMLDocumentCB.prototype.pent = function(name, value) {
	      return this.pEntity(name, value);
	    };

	    XMLDocumentCB.prototype.not = function(name, value) {
	      return this.notation(name, value);
	    };

	    return XMLDocumentCB;

	  })();

	}).call(this);


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  XMLDeclaration = __webpack_require__(261);

	  XMLDocType = __webpack_require__(262);

	  XMLCData = __webpack_require__(259);

	  XMLComment = __webpack_require__(260);

	  XMLElement = __webpack_require__(257);

	  XMLRaw = __webpack_require__(267);

	  XMLText = __webpack_require__(268);

	  XMLProcessingInstruction = __webpack_require__(269);

	  XMLDTDAttList = __webpack_require__(263);

	  XMLDTDElement = __webpack_require__(265);

	  XMLDTDEntity = __webpack_require__(264);

	  XMLDTDNotation = __webpack_require__(266);

	  XMLWriterBase = __webpack_require__(272);

	  module.exports = XMLStreamWriter = (function(superClass) {
	    extend(XMLStreamWriter, superClass);

	    function XMLStreamWriter(stream, options) {
	      XMLStreamWriter.__super__.constructor.call(this, options);
	      this.stream = stream;
	    }

	    XMLStreamWriter.prototype.document = function(doc) {
	      var child, i, j, len, len1, ref, ref1, results;
	      ref = doc.children;
	      for (i = 0, len = ref.length; i < len; i++) {
	        child = ref[i];
	        child.isLastRootNode = false;
	      }
	      doc.children[doc.children.length - 1].isLastRootNode = true;
	      ref1 = doc.children;
	      results = [];
	      for (j = 0, len1 = ref1.length; j < len1; j++) {
	        child = ref1[j];
	        switch (false) {
	          case !(child instanceof XMLDeclaration):
	            results.push(this.declaration(child));
	            break;
	          case !(child instanceof XMLDocType):
	            results.push(this.docType(child));
	            break;
	          case !(child instanceof XMLComment):
	            results.push(this.comment(child));
	            break;
	          case !(child instanceof XMLProcessingInstruction):
	            results.push(this.processingInstruction(child));
	            break;
	          default:
	            results.push(this.element(child));
	        }
	      }
	      return results;
	    };

	    XMLStreamWriter.prototype.attribute = function(att) {
	      return this.stream.write(' ' + att.name + '="' + att.value + '"');
	    };

	    XMLStreamWriter.prototype.cdata = function(node, level) {
	      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
	    };

	    XMLStreamWriter.prototype.comment = function(node, level) {
	      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
	    };

	    XMLStreamWriter.prototype.declaration = function(node, level) {
	      this.stream.write(this.space(level));
	      this.stream.write('<?xml version="' + node.version + '"');
	      if (node.encoding != null) {
	        this.stream.write(' encoding="' + node.encoding + '"');
	      }
	      if (node.standalone != null) {
	        this.stream.write(' standalone="' + node.standalone + '"');
	      }
	      this.stream.write(this.spacebeforeslash + '?>');
	      return this.stream.write(this.endline(node));
	    };

	    XMLStreamWriter.prototype.docType = function(node, level) {
	      var child, i, len, ref;
	      level || (level = 0);
	      this.stream.write(this.space(level));
	      this.stream.write('<!DOCTYPE ' + node.root().name);
	      if (node.pubID && node.sysID) {
	        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
	      } else if (node.sysID) {
	        this.stream.write(' SYSTEM "' + node.sysID + '"');
	      }
	      if (node.children.length > 0) {
	        this.stream.write(' [');
	        this.stream.write(this.endline(node));
	        ref = node.children;
	        for (i = 0, len = ref.length; i < len; i++) {
	          child = ref[i];
	          switch (false) {
	            case !(child instanceof XMLDTDAttList):
	              this.dtdAttList(child, level + 1);
	              break;
	            case !(child instanceof XMLDTDElement):
	              this.dtdElement(child, level + 1);
	              break;
	            case !(child instanceof XMLDTDEntity):
	              this.dtdEntity(child, level + 1);
	              break;
	            case !(child instanceof XMLDTDNotation):
	              this.dtdNotation(child, level + 1);
	              break;
	            case !(child instanceof XMLCData):
	              this.cdata(child, level + 1);
	              break;
	            case !(child instanceof XMLComment):
	              this.comment(child, level + 1);
	              break;
	            case !(child instanceof XMLProcessingInstruction):
	              this.processingInstruction(child, level + 1);
	              break;
	            default:
	              throw new Error("Unknown DTD node type: " + child.constructor.name);
	          }
	        }
	        this.stream.write(']');
	      }
	      this.stream.write(this.spacebeforeslash + '>');
	      return this.stream.write(this.endline(node));
	    };

	    XMLStreamWriter.prototype.element = function(node, level) {
	      var att, child, i, len, name, ref, ref1, space;
	      level || (level = 0);
	      space = this.space(level);
	      this.stream.write(space + '<' + node.name);
	      ref = node.attributes;
	      for (name in ref) {
	        if (!hasProp.call(ref, name)) continue;
	        att = ref[name];
	        this.attribute(att);
	      }
	      if (node.children.length === 0 || node.children.every(function(e) {
	        return e.value === '';
	      })) {
	        if (this.allowEmpty) {
	          this.stream.write('></' + node.name + '>');
	        } else {
	          this.stream.write(this.spacebeforeslash + '/>');
	        }
	      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
	        this.stream.write('>');
	        this.stream.write(node.children[0].value);
	        this.stream.write('</' + node.name + '>');
	      } else {
	        this.stream.write('>' + this.newline);
	        ref1 = node.children;
	        for (i = 0, len = ref1.length; i < len; i++) {
	          child = ref1[i];
	          switch (false) {
	            case !(child instanceof XMLCData):
	              this.cdata(child, level + 1);
	              break;
	            case !(child instanceof XMLComment):
	              this.comment(child, level + 1);
	              break;
	            case !(child instanceof XMLElement):
	              this.element(child, level + 1);
	              break;
	            case !(child instanceof XMLRaw):
	              this.raw(child, level + 1);
	              break;
	            case !(child instanceof XMLText):
	              this.text(child, level + 1);
	              break;
	            case !(child instanceof XMLProcessingInstruction):
	              this.processingInstruction(child, level + 1);
	              break;
	            default:
	              throw new Error("Unknown XML node type: " + child.constructor.name);
	          }
	        }
	        this.stream.write(space + '</' + node.name + '>');
	      }
	      return this.stream.write(this.endline(node));
	    };

	    XMLStreamWriter.prototype.processingInstruction = function(node, level) {
	      this.stream.write(this.space(level) + '<?' + node.target);
	      if (node.value) {
	        this.stream.write(' ' + node.value);
	      }
	      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
	    };

	    XMLStreamWriter.prototype.raw = function(node, level) {
	      return this.stream.write(this.space(level) + node.value + this.endline(node));
	    };

	    XMLStreamWriter.prototype.text = function(node, level) {
	      return this.stream.write(this.space(level) + node.value + this.endline(node));
	    };

	    XMLStreamWriter.prototype.dtdAttList = function(node, level) {
	      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
	      if (node.defaultValueType !== '#DEFAULT') {
	        this.stream.write(' ' + node.defaultValueType);
	      }
	      if (node.defaultValue) {
	        this.stream.write(' "' + node.defaultValue + '"');
	      }
	      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
	    };

	    XMLStreamWriter.prototype.dtdElement = function(node, level) {
	      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
	      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
	    };

	    XMLStreamWriter.prototype.dtdEntity = function(node, level) {
	      this.stream.write(this.space(level) + '<!ENTITY');
	      if (node.pe) {
	        this.stream.write(' %');
	      }
	      this.stream.write(' ' + node.name);
	      if (node.value) {
	        this.stream.write(' "' + node.value + '"');
	      } else {
	        if (node.pubID && node.sysID) {
	          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
	        } else if (node.sysID) {
	          this.stream.write(' SYSTEM "' + node.sysID + '"');
	        }
	        if (node.nData) {
	          this.stream.write(' NDATA ' + node.nData);
	        }
	      }
	      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
	    };

	    XMLStreamWriter.prototype.dtdNotation = function(node, level) {
	      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
	      if (node.pubID && node.sysID) {
	        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
	      } else if (node.pubID) {
	        this.stream.write(' PUBLIC "' + node.pubID + '"');
	      } else if (node.sysID) {
	        this.stream.write(' SYSTEM "' + node.sysID + '"');
	      }
	      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
	    };

	    XMLStreamWriter.prototype.endline = function(node) {
	      if (!node.isLastRootNode) {
	        return this.newline;
	      } else {
	        return '';
	      }
	    };

	    return XMLStreamWriter;

	  })(XMLWriterBase);

	}).call(this);


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  "use strict";
	  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  sax = __webpack_require__(276);

	  events = __webpack_require__(278);

	  bom = __webpack_require__(279);

	  processors = __webpack_require__(280);

	  setImmediate = __webpack_require__(281).setImmediate;

	  defaults = __webpack_require__(251).defaults;

	  isEmpty = function(thing) {
	    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
	  };

	  processItem = function(processors, item, key) {
	    var i, len, process;
	    for (i = 0, len = processors.length; i < len; i++) {
	      process = processors[i];
	      item = process(item, key);
	    }
	    return item;
	  };

	  exports.Parser = (function(superClass) {
	    extend(Parser, superClass);

	    function Parser(opts) {
	      this.parseString = bind(this.parseString, this);
	      this.reset = bind(this.reset, this);
	      this.assignOrPush = bind(this.assignOrPush, this);
	      this.processAsync = bind(this.processAsync, this);
	      var key, ref, value;
	      if (!(this instanceof exports.Parser)) {
	        return new exports.Parser(opts);
	      }
	      this.options = {};
	      ref = defaults["0.2"];
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	      if (this.options.xmlns) {
	        this.options.xmlnskey = this.options.attrkey + "ns";
	      }
	      if (this.options.normalizeTags) {
	        if (!this.options.tagNameProcessors) {
	          this.options.tagNameProcessors = [];
	        }
	        this.options.tagNameProcessors.unshift(processors.normalize);
	      }
	      this.reset();
	    }

	    Parser.prototype.processAsync = function() {
	      var chunk, err;
	      try {
	        if (this.remaining.length <= this.options.chunkSize) {
	          chunk = this.remaining;
	          this.remaining = '';
	          this.saxParser = this.saxParser.write(chunk);
	          return this.saxParser.close();
	        } else {
	          chunk = this.remaining.substr(0, this.options.chunkSize);
	          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
	          this.saxParser = this.saxParser.write(chunk);
	          return setImmediate(this.processAsync);
	        }
	      } catch (error1) {
	        err = error1;
	        if (!this.saxParser.errThrown) {
	          this.saxParser.errThrown = true;
	          return this.emit(err);
	        }
	      }
	    };

	    Parser.prototype.assignOrPush = function(obj, key, newValue) {
	      if (!(key in obj)) {
	        if (!this.options.explicitArray) {
	          return obj[key] = newValue;
	        } else {
	          return obj[key] = [newValue];
	        }
	      } else {
	        if (!(obj[key] instanceof Array)) {
	          obj[key] = [obj[key]];
	        }
	        return obj[key].push(newValue);
	      }
	    };

	    Parser.prototype.reset = function() {
	      var attrkey, charkey, ontext, stack;
	      this.removeAllListeners();
	      this.saxParser = sax.parser(this.options.strict, {
	        trim: false,
	        normalize: false,
	        xmlns: this.options.xmlns
	      });
	      this.saxParser.errThrown = false;
	      this.saxParser.onerror = (function(_this) {
	        return function(error) {
	          _this.saxParser.resume();
	          if (!_this.saxParser.errThrown) {
	            _this.saxParser.errThrown = true;
	            return _this.emit("error", error);
	          }
	        };
	      })(this);
	      this.saxParser.onend = (function(_this) {
	        return function() {
	          if (!_this.saxParser.ended) {
	            _this.saxParser.ended = true;
	            return _this.emit("end", _this.resultObject);
	          }
	        };
	      })(this);
	      this.saxParser.ended = false;
	      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
	      this.resultObject = null;
	      stack = [];
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      this.saxParser.onopentag = (function(_this) {
	        return function(node) {
	          var key, newValue, obj, processedKey, ref;
	          obj = {};
	          obj[charkey] = "";
	          if (!_this.options.ignoreAttrs) {
	            ref = node.attributes;
	            for (key in ref) {
	              if (!hasProp.call(ref, key)) continue;
	              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
	                obj[attrkey] = {};
	              }
	              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
	              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
	              if (_this.options.mergeAttrs) {
	                _this.assignOrPush(obj, processedKey, newValue);
	              } else {
	                obj[attrkey][processedKey] = newValue;
	              }
	            }
	          }
	          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
	          if (_this.options.xmlns) {
	            obj[_this.options.xmlnskey] = {
	              uri: node.uri,
	              local: node.local
	            };
	          }
	          return stack.push(obj);
	        };
	      })(this);
	      this.saxParser.onclosetag = (function(_this) {
	        return function() {
	          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
	          obj = stack.pop();
	          nodeName = obj["#name"];
	          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
	            delete obj["#name"];
	          }
	          if (obj.cdata === true) {
	            cdata = obj.cdata;
	            delete obj.cdata;
	          }
	          s = stack[stack.length - 1];
	          if (obj[charkey].match(/^\s*$/) && !cdata) {
	            emptyStr = obj[charkey];
	            delete obj[charkey];
	          } else {
	            if (_this.options.trim) {
	              obj[charkey] = obj[charkey].trim();
	            }
	            if (_this.options.normalize) {
	              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
	            }
	            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
	            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	              obj = obj[charkey];
	            }
	          }
	          if (isEmpty(obj)) {
	            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
	          }
	          if (_this.options.validator != null) {
	            xpath = "/" + ((function() {
	              var i, len, results;
	              results = [];
	              for (i = 0, len = stack.length; i < len; i++) {
	                node = stack[i];
	                results.push(node["#name"]);
	              }
	              return results;
	            })()).concat(nodeName).join("/");
	            (function() {
	              var err;
	              try {
	                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
	              } catch (error1) {
	                err = error1;
	                return _this.emit("error", err);
	              }
	            })();
	          }
	          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
	            if (!_this.options.preserveChildrenOrder) {
	              node = {};
	              if (_this.options.attrkey in obj) {
	                node[_this.options.attrkey] = obj[_this.options.attrkey];
	                delete obj[_this.options.attrkey];
	              }
	              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
	                node[_this.options.charkey] = obj[_this.options.charkey];
	                delete obj[_this.options.charkey];
	              }
	              if (Object.getOwnPropertyNames(obj).length > 0) {
	                node[_this.options.childkey] = obj;
	              }
	              obj = node;
	            } else if (s) {
	              s[_this.options.childkey] = s[_this.options.childkey] || [];
	              objClone = {};
	              for (key in obj) {
	                if (!hasProp.call(obj, key)) continue;
	                objClone[key] = obj[key];
	              }
	              s[_this.options.childkey].push(objClone);
	              delete obj["#name"];
	              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	                obj = obj[charkey];
	              }
	            }
	          }
	          if (stack.length > 0) {
	            return _this.assignOrPush(s, nodeName, obj);
	          } else {
	            if (_this.options.explicitRoot) {
	              old = obj;
	              obj = {};
	              obj[nodeName] = old;
	            }
	            _this.resultObject = obj;
	            _this.saxParser.ended = true;
	            return _this.emit("end", _this.resultObject);
	          }
	        };
	      })(this);
	      ontext = (function(_this) {
	        return function(text) {
	          var charChild, s;
	          s = stack[stack.length - 1];
	          if (s) {
	            s[charkey] += text;
	            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
	              s[_this.options.childkey] = s[_this.options.childkey] || [];
	              charChild = {
	                '#name': '__text__'
	              };
	              charChild[charkey] = text;
	              if (_this.options.normalize) {
	                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
	              }
	              s[_this.options.childkey].push(charChild);
	            }
	            return s;
	          }
	        };
	      })(this);
	      this.saxParser.ontext = ontext;
	      return this.saxParser.oncdata = (function(_this) {
	        return function(text) {
	          var s;
	          s = ontext(text);
	          if (s) {
	            return s.cdata = true;
	          }
	        };
	      })(this);
	    };

	    Parser.prototype.parseString = function(str, cb) {
	      var err;
	      if ((cb != null) && typeof cb === "function") {
	        this.on("end", function(result) {
	          this.reset();
	          return cb(null, result);
	        });
	        this.on("error", function(err) {
	          this.reset();
	          return cb(err);
	        });
	      }
	      try {
	        str = str.toString();
	        if (str.trim() === '') {
	          this.emit("end", null);
	          return true;
	        }
	        str = bom.stripBOM(str);
	        if (this.options.async) {
	          this.remaining = str;
	          setImmediate(this.processAsync);
	          return this.saxParser;
	        }
	        return this.saxParser.write(str).close();
	      } catch (error1) {
	        err = error1;
	        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
	          this.emit('error', err);
	          return this.saxParser.errThrown = true;
	        } else if (this.saxParser.ended) {
	          throw err;
	        }
	      }
	    };

	    return Parser;

	  })(events.EventEmitter);

	  exports.parseString = function(str, a, b) {
	    var cb, options, parser;
	    if (b != null) {
	      if (typeof b === 'function') {
	        cb = b;
	      }
	      if (typeof a === 'object') {
	        options = a;
	      }
	    } else {
	      if (typeof a === 'function') {
	        cb = a;
	      }
	      options = {};
	    }
	    parser = new exports.Parser(options);
	    return parser.parseString(str, cb);
	  };

	}).call(this);


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	;(function (sax) { // wrapper for non-node envs
	  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
	  sax.SAXParser = SAXParser
	  sax.SAXStream = SAXStream
	  sax.createStream = createStream

	  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
	  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
	  // since that's the earliest that a buffer overrun could occur.  This way, checks are
	  // as rare as required, but as often as necessary to ensure never crossing this bound.
	  // Furthermore, buffers are only tested at most once per write(), so passing a very
	  // large string into write() might have undesirable effects, but this is manageable by
	  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
	  // edge case, result in creating at most one complete copy of the string passed in.
	  // Set to Infinity to have unlimited buffers.
	  sax.MAX_BUFFER_LENGTH = 64 * 1024

	  var buffers = [
	    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
	    'procInstName', 'procInstBody', 'entity', 'attribName',
	    'attribValue', 'cdata', 'script'
	  ]

	  sax.EVENTS = [
	    'text',
	    'processinginstruction',
	    'sgmldeclaration',
	    'doctype',
	    'comment',
	    'opentagstart',
	    'attribute',
	    'opentag',
	    'closetag',
	    'opencdata',
	    'cdata',
	    'closecdata',
	    'error',
	    'end',
	    'ready',
	    'script',
	    'opennamespace',
	    'closenamespace'
	  ]

	  function SAXParser (strict, opt) {
	    if (!(this instanceof SAXParser)) {
	      return new SAXParser(strict, opt)
	    }

	    var parser = this
	    clearBuffers(parser)
	    parser.q = parser.c = ''
	    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
	    parser.opt = opt || {}
	    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
	    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
	    parser.tags = []
	    parser.closed = parser.closedRoot = parser.sawRoot = false
	    parser.tag = parser.error = null
	    parser.strict = !!strict
	    parser.noscript = !!(strict || parser.opt.noscript)
	    parser.state = S.BEGIN
	    parser.strictEntities = parser.opt.strictEntities
	    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
	    parser.attribList = []

	    // namespaces form a prototype chain.
	    // it always points at the current tag,
	    // which protos to its parent tag.
	    if (parser.opt.xmlns) {
	      parser.ns = Object.create(rootNS)
	    }

	    // mostly just for error reporting
	    parser.trackPosition = parser.opt.position !== false
	    if (parser.trackPosition) {
	      parser.position = parser.line = parser.column = 0
	    }
	    emit(parser, 'onready')
	  }

	  if (!Object.create) {
	    Object.create = function (o) {
	      function F () {}
	      F.prototype = o
	      var newf = new F()
	      return newf
	    }
	  }

	  if (!Object.keys) {
	    Object.keys = function (o) {
	      var a = []
	      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
	      return a
	    }
	  }

	  function checkBufferLength (parser) {
	    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
	    var maxActual = 0
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      var len = parser[buffers[i]].length
	      if (len > maxAllowed) {
	        // Text/cdata nodes can get big, and since they're buffered,
	        // we can get here under normal conditions.
	        // Avoid issues by emitting the text node now,
	        // so at least it won't get any bigger.
	        switch (buffers[i]) {
	          case 'textNode':
	            closeText(parser)
	            break

	          case 'cdata':
	            emitNode(parser, 'oncdata', parser.cdata)
	            parser.cdata = ''
	            break

	          case 'script':
	            emitNode(parser, 'onscript', parser.script)
	            parser.script = ''
	            break

	          default:
	            error(parser, 'Max buffer length exceeded: ' + buffers[i])
	        }
	      }
	      maxActual = Math.max(maxActual, len)
	    }
	    // schedule the next check for the earliest possible buffer overrun.
	    var m = sax.MAX_BUFFER_LENGTH - maxActual
	    parser.bufferCheckPosition = m + parser.position
	  }

	  function clearBuffers (parser) {
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      parser[buffers[i]] = ''
	    }
	  }

	  function flushBuffers (parser) {
	    closeText(parser)
	    if (parser.cdata !== '') {
	      emitNode(parser, 'oncdata', parser.cdata)
	      parser.cdata = ''
	    }
	    if (parser.script !== '') {
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }
	  }

	  SAXParser.prototype = {
	    end: function () { end(this) },
	    write: write,
	    resume: function () { this.error = null; return this },
	    close: function () { return this.write(null) },
	    flush: function () { flushBuffers(this) }
	  }

	  var Stream
	  try {
	    Stream = __webpack_require__(215).Stream
	  } catch (ex) {
	    Stream = function () {}
	  }

	  var streamWraps = sax.EVENTS.filter(function (ev) {
	    return ev !== 'error' && ev !== 'end'
	  })

	  function createStream (strict, opt) {
	    return new SAXStream(strict, opt)
	  }

	  function SAXStream (strict, opt) {
	    if (!(this instanceof SAXStream)) {
	      return new SAXStream(strict, opt)
	    }

	    Stream.apply(this)

	    this._parser = new SAXParser(strict, opt)
	    this.writable = true
	    this.readable = true

	    var me = this

	    this._parser.onend = function () {
	      me.emit('end')
	    }

	    this._parser.onerror = function (er) {
	      me.emit('error', er)

	      // if didn't throw, then means error was handled.
	      // go ahead and clear error, so we can write again.
	      me._parser.error = null
	    }

	    this._decoder = null

	    streamWraps.forEach(function (ev) {
	      Object.defineProperty(me, 'on' + ev, {
	        get: function () {
	          return me._parser['on' + ev]
	        },
	        set: function (h) {
	          if (!h) {
	            me.removeAllListeners(ev)
	            me._parser['on' + ev] = h
	            return h
	          }
	          me.on(ev, h)
	        },
	        enumerable: true,
	        configurable: false
	      })
	    })
	  }

	  SAXStream.prototype = Object.create(Stream.prototype, {
	    constructor: {
	      value: SAXStream
	    }
	  })

	  SAXStream.prototype.write = function (data) {
	    if (typeof Buffer === 'function' &&
	      typeof Buffer.isBuffer === 'function' &&
	      Buffer.isBuffer(data)) {
	      if (!this._decoder) {
	        var SD = __webpack_require__(277).StringDecoder
	        this._decoder = new SD('utf8')
	      }
	      data = this._decoder.write(data)
	    }

	    this._parser.write(data.toString())
	    this.emit('data', data)
	    return true
	  }

	  SAXStream.prototype.end = function (chunk) {
	    if (chunk && chunk.length) {
	      this.write(chunk)
	    }
	    this._parser.end()
	    return true
	  }

	  SAXStream.prototype.on = function (ev, handler) {
	    var me = this
	    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
	      me._parser['on' + ev] = function () {
	        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
	        args.splice(0, 0, ev)
	        me.emit.apply(me, args)
	      }
	    }

	    return Stream.prototype.on.call(me, ev, handler)
	  }

	  // character classes and tokens
	  var whitespace = '\r\n\t '

	  // this really needs to be replaced with character classes.
	  // XML allows all manner of ridiculous numbers and digits.
	  var number = '0124356789'
	  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

	  // (Letter | "_" | ":")
	  var quote = '\'"'
	  var attribEnd = whitespace + '>'
	  var CDATA = '[CDATA['
	  var DOCTYPE = 'DOCTYPE'
	  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
	  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
	  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

	  // turn all the string character sets into character class objects.
	  whitespace = charClass(whitespace)
	  number = charClass(number)
	  letter = charClass(letter)

	  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
	  // This implementation works on strings, a single character at a time
	  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
	  // without a significant breaking change to either this  parser, or the
	  // JavaScript language.  Implementation of an emoji-capable xml parser
	  // is left as an exercise for the reader.
	  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

	  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

	  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
	  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

	  quote = charClass(quote)
	  attribEnd = charClass(attribEnd)

	  function charClass (str) {
	    return str.split('').reduce(function (s, c) {
	      s[c] = true
	      return s
	    }, {})
	  }

	  function isRegExp (c) {
	    return Object.prototype.toString.call(c) === '[object RegExp]'
	  }

	  function is (charclass, c) {
	    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
	  }

	  function not (charclass, c) {
	    return !is(charclass, c)
	  }

	  var S = 0
	  sax.STATE = {
	    BEGIN: S++, // leading byte order mark or whitespace
	    BEGIN_WHITESPACE: S++, // leading whitespace
	    TEXT: S++, // general stuff
	    TEXT_ENTITY: S++, // &amp and such.
	    OPEN_WAKA: S++, // <
	    SGML_DECL: S++, // <!BLARG
	    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
	    DOCTYPE: S++, // <!DOCTYPE
	    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
	    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
	    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
	    COMMENT_STARTING: S++, // <!-
	    COMMENT: S++, // <!--
	    COMMENT_ENDING: S++, // <!-- blah -
	    COMMENT_ENDED: S++, // <!-- blah --
	    CDATA: S++, // <![CDATA[ something
	    CDATA_ENDING: S++, // ]
	    CDATA_ENDING_2: S++, // ]]
	    PROC_INST: S++, // <?hi
	    PROC_INST_BODY: S++, // <?hi there
	    PROC_INST_ENDING: S++, // <?hi "there" ?
	    OPEN_TAG: S++, // <strong
	    OPEN_TAG_SLASH: S++, // <strong /
	    ATTRIB: S++, // <a
	    ATTRIB_NAME: S++, // <a foo
	    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
	    ATTRIB_VALUE: S++, // <a foo=
	    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
	    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
	    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
	    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
	    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
	    CLOSE_TAG: S++, // </a
	    CLOSE_TAG_SAW_WHITE: S++, // </a   >
	    SCRIPT: S++, // <script> ...
	    SCRIPT_ENDING: S++ // <script> ... <
	  }

	  sax.XML_ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'"
	  }

	  sax.ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'",
	    'AElig': 198,
	    'Aacute': 193,
	    'Acirc': 194,
	    'Agrave': 192,
	    'Aring': 197,
	    'Atilde': 195,
	    'Auml': 196,
	    'Ccedil': 199,
	    'ETH': 208,
	    'Eacute': 201,
	    'Ecirc': 202,
	    'Egrave': 200,
	    'Euml': 203,
	    'Iacute': 205,
	    'Icirc': 206,
	    'Igrave': 204,
	    'Iuml': 207,
	    'Ntilde': 209,
	    'Oacute': 211,
	    'Ocirc': 212,
	    'Ograve': 210,
	    'Oslash': 216,
	    'Otilde': 213,
	    'Ouml': 214,
	    'THORN': 222,
	    'Uacute': 218,
	    'Ucirc': 219,
	    'Ugrave': 217,
	    'Uuml': 220,
	    'Yacute': 221,
	    'aacute': 225,
	    'acirc': 226,
	    'aelig': 230,
	    'agrave': 224,
	    'aring': 229,
	    'atilde': 227,
	    'auml': 228,
	    'ccedil': 231,
	    'eacute': 233,
	    'ecirc': 234,
	    'egrave': 232,
	    'eth': 240,
	    'euml': 235,
	    'iacute': 237,
	    'icirc': 238,
	    'igrave': 236,
	    'iuml': 239,
	    'ntilde': 241,
	    'oacute': 243,
	    'ocirc': 244,
	    'ograve': 242,
	    'oslash': 248,
	    'otilde': 245,
	    'ouml': 246,
	    'szlig': 223,
	    'thorn': 254,
	    'uacute': 250,
	    'ucirc': 251,
	    'ugrave': 249,
	    'uuml': 252,
	    'yacute': 253,
	    'yuml': 255,
	    'copy': 169,
	    'reg': 174,
	    'nbsp': 160,
	    'iexcl': 161,
	    'cent': 162,
	    'pound': 163,
	    'curren': 164,
	    'yen': 165,
	    'brvbar': 166,
	    'sect': 167,
	    'uml': 168,
	    'ordf': 170,
	    'laquo': 171,
	    'not': 172,
	    'shy': 173,
	    'macr': 175,
	    'deg': 176,
	    'plusmn': 177,
	    'sup1': 185,
	    'sup2': 178,
	    'sup3': 179,
	    'acute': 180,
	    'micro': 181,
	    'para': 182,
	    'middot': 183,
	    'cedil': 184,
	    'ordm': 186,
	    'raquo': 187,
	    'frac14': 188,
	    'frac12': 189,
	    'frac34': 190,
	    'iquest': 191,
	    'times': 215,
	    'divide': 247,
	    'OElig': 338,
	    'oelig': 339,
	    'Scaron': 352,
	    'scaron': 353,
	    'Yuml': 376,
	    'fnof': 402,
	    'circ': 710,
	    'tilde': 732,
	    'Alpha': 913,
	    'Beta': 914,
	    'Gamma': 915,
	    'Delta': 916,
	    'Epsilon': 917,
	    'Zeta': 918,
	    'Eta': 919,
	    'Theta': 920,
	    'Iota': 921,
	    'Kappa': 922,
	    'Lambda': 923,
	    'Mu': 924,
	    'Nu': 925,
	    'Xi': 926,
	    'Omicron': 927,
	    'Pi': 928,
	    'Rho': 929,
	    'Sigma': 931,
	    'Tau': 932,
	    'Upsilon': 933,
	    'Phi': 934,
	    'Chi': 935,
	    'Psi': 936,
	    'Omega': 937,
	    'alpha': 945,
	    'beta': 946,
	    'gamma': 947,
	    'delta': 948,
	    'epsilon': 949,
	    'zeta': 950,
	    'eta': 951,
	    'theta': 952,
	    'iota': 953,
	    'kappa': 954,
	    'lambda': 955,
	    'mu': 956,
	    'nu': 957,
	    'xi': 958,
	    'omicron': 959,
	    'pi': 960,
	    'rho': 961,
	    'sigmaf': 962,
	    'sigma': 963,
	    'tau': 964,
	    'upsilon': 965,
	    'phi': 966,
	    'chi': 967,
	    'psi': 968,
	    'omega': 969,
	    'thetasym': 977,
	    'upsih': 978,
	    'piv': 982,
	    'ensp': 8194,
	    'emsp': 8195,
	    'thinsp': 8201,
	    'zwnj': 8204,
	    'zwj': 8205,
	    'lrm': 8206,
	    'rlm': 8207,
	    'ndash': 8211,
	    'mdash': 8212,
	    'lsquo': 8216,
	    'rsquo': 8217,
	    'sbquo': 8218,
	    'ldquo': 8220,
	    'rdquo': 8221,
	    'bdquo': 8222,
	    'dagger': 8224,
	    'Dagger': 8225,
	    'bull': 8226,
	    'hellip': 8230,
	    'permil': 8240,
	    'prime': 8242,
	    'Prime': 8243,
	    'lsaquo': 8249,
	    'rsaquo': 8250,
	    'oline': 8254,
	    'frasl': 8260,
	    'euro': 8364,
	    'image': 8465,
	    'weierp': 8472,
	    'real': 8476,
	    'trade': 8482,
	    'alefsym': 8501,
	    'larr': 8592,
	    'uarr': 8593,
	    'rarr': 8594,
	    'darr': 8595,
	    'harr': 8596,
	    'crarr': 8629,
	    'lArr': 8656,
	    'uArr': 8657,
	    'rArr': 8658,
	    'dArr': 8659,
	    'hArr': 8660,
	    'forall': 8704,
	    'part': 8706,
	    'exist': 8707,
	    'empty': 8709,
	    'nabla': 8711,
	    'isin': 8712,
	    'notin': 8713,
	    'ni': 8715,
	    'prod': 8719,
	    'sum': 8721,
	    'minus': 8722,
	    'lowast': 8727,
	    'radic': 8730,
	    'prop': 8733,
	    'infin': 8734,
	    'ang': 8736,
	    'and': 8743,
	    'or': 8744,
	    'cap': 8745,
	    'cup': 8746,
	    'int': 8747,
	    'there4': 8756,
	    'sim': 8764,
	    'cong': 8773,
	    'asymp': 8776,
	    'ne': 8800,
	    'equiv': 8801,
	    'le': 8804,
	    'ge': 8805,
	    'sub': 8834,
	    'sup': 8835,
	    'nsub': 8836,
	    'sube': 8838,
	    'supe': 8839,
	    'oplus': 8853,
	    'otimes': 8855,
	    'perp': 8869,
	    'sdot': 8901,
	    'lceil': 8968,
	    'rceil': 8969,
	    'lfloor': 8970,
	    'rfloor': 8971,
	    'lang': 9001,
	    'rang': 9002,
	    'loz': 9674,
	    'spades': 9824,
	    'clubs': 9827,
	    'hearts': 9829,
	    'diams': 9830
	  }

	  Object.keys(sax.ENTITIES).forEach(function (key) {
	    var e = sax.ENTITIES[key]
	    var s = typeof e === 'number' ? String.fromCharCode(e) : e
	    sax.ENTITIES[key] = s
	  })

	  for (var s in sax.STATE) {
	    sax.STATE[sax.STATE[s]] = s
	  }

	  // shorthand
	  S = sax.STATE

	  function emit (parser, event, data) {
	    parser[event] && parser[event](data)
	  }

	  function emitNode (parser, nodeType, data) {
	    if (parser.textNode) closeText(parser)
	    emit(parser, nodeType, data)
	  }

	  function closeText (parser) {
	    parser.textNode = textopts(parser.opt, parser.textNode)
	    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
	    parser.textNode = ''
	  }

	  function textopts (opt, text) {
	    if (opt.trim) text = text.trim()
	    if (opt.normalize) text = text.replace(/\s+/g, ' ')
	    return text
	  }

	  function error (parser, er) {
	    closeText(parser)
	    if (parser.trackPosition) {
	      er += '\nLine: ' + parser.line +
	        '\nColumn: ' + parser.column +
	        '\nChar: ' + parser.c
	    }
	    er = new Error(er)
	    parser.error = er
	    emit(parser, 'onerror', er)
	    return parser
	  }

	  function end (parser) {
	    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
	    if ((parser.state !== S.BEGIN) &&
	      (parser.state !== S.BEGIN_WHITESPACE) &&
	      (parser.state !== S.TEXT)) {
	      error(parser, 'Unexpected end')
	    }
	    closeText(parser)
	    parser.c = ''
	    parser.closed = true
	    emit(parser, 'onend')
	    SAXParser.call(parser, parser.strict, parser.opt)
	    return parser
	  }

	  function strictFail (parser, message) {
	    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
	      throw new Error('bad call to strictFail')
	    }
	    if (parser.strict) {
	      error(parser, message)
	    }
	  }

	  function newTag (parser) {
	    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    var tag = parser.tag = { name: parser.tagName, attributes: {} }

	    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
	    if (parser.opt.xmlns) {
	      tag.ns = parent.ns
	    }
	    parser.attribList.length = 0
	    emitNode(parser, 'onopentagstart', tag)
	  }

	  function qname (name, attribute) {
	    var i = name.indexOf(':')
	    var qualName = i < 0 ? [ '', name ] : name.split(':')
	    var prefix = qualName[0]
	    var local = qualName[1]

	    // <x "xmlns"="http://foo">
	    if (attribute && name === 'xmlns') {
	      prefix = 'xmlns'
	      local = ''
	    }

	    return { prefix: prefix, local: local }
	  }

	  function attrib (parser) {
	    if (!parser.strict) {
	      parser.attribName = parser.attribName[parser.looseCase]()
	    }

	    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
	      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
	      parser.attribName = parser.attribValue = ''
	      return
	    }

	    if (parser.opt.xmlns) {
	      var qn = qname(parser.attribName, true)
	      var prefix = qn.prefix
	      var local = qn.local

	      if (prefix === 'xmlns') {
	        // namespace binding attribute. push the binding into scope
	        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
	          strictFail(parser,
	            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
	          strictFail(parser,
	            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else {
	          var tag = parser.tag
	          var parent = parser.tags[parser.tags.length - 1] || parser
	          if (tag.ns === parent.ns) {
	            tag.ns = Object.create(parent.ns)
	          }
	          tag.ns[local] = parser.attribValue
	        }
	      }

	      // defer onattribute events until all attributes have been seen
	      // so any new bindings can take effect. preserve attribute order
	      // so deferred events can be emitted in document order
	      parser.attribList.push([parser.attribName, parser.attribValue])
	    } else {
	      // in non-xmlns mode, we can emit the event right away
	      parser.tag.attributes[parser.attribName] = parser.attribValue
	      emitNode(parser, 'onattribute', {
	        name: parser.attribName,
	        value: parser.attribValue
	      })
	    }

	    parser.attribName = parser.attribValue = ''
	  }

	  function openTag (parser, selfClosing) {
	    if (parser.opt.xmlns) {
	      // emit namespace binding events
	      var tag = parser.tag

	      // add namespace info to tag
	      var qn = qname(parser.tagName)
	      tag.prefix = qn.prefix
	      tag.local = qn.local
	      tag.uri = tag.ns[qn.prefix] || ''

	      if (tag.prefix && !tag.uri) {
	        strictFail(parser, 'Unbound namespace prefix: ' +
	          JSON.stringify(parser.tagName))
	        tag.uri = qn.prefix
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (tag.ns && parent.ns !== tag.ns) {
	        Object.keys(tag.ns).forEach(function (p) {
	          emitNode(parser, 'onopennamespace', {
	            prefix: p,
	            uri: tag.ns[p]
	          })
	        })
	      }

	      // handle deferred onattribute events
	      // Note: do not apply default ns to attributes:
	      //   http://www.w3.org/TR/REC-xml-names/#defaulting
	      for (var i = 0, l = parser.attribList.length; i < l; i++) {
	        var nv = parser.attribList[i]
	        var name = nv[0]
	        var value = nv[1]
	        var qualName = qname(name, true)
	        var prefix = qualName.prefix
	        var local = qualName.local
	        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
	        var a = {
	          name: name,
	          value: value,
	          prefix: prefix,
	          local: local,
	          uri: uri
	        }

	        // if there's any attributes with an undefined namespace,
	        // then fail on them now.
	        if (prefix && prefix !== 'xmlns' && !uri) {
	          strictFail(parser, 'Unbound namespace prefix: ' +
	            JSON.stringify(prefix))
	          a.uri = prefix
	        }
	        parser.tag.attributes[name] = a
	        emitNode(parser, 'onattribute', a)
	      }
	      parser.attribList.length = 0
	    }

	    parser.tag.isSelfClosing = !!selfClosing

	    // process the tag
	    parser.sawRoot = true
	    parser.tags.push(parser.tag)
	    emitNode(parser, 'onopentag', parser.tag)
	    if (!selfClosing) {
	      // special case for <script> in non-strict mode.
	      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
	        parser.state = S.SCRIPT
	      } else {
	        parser.state = S.TEXT
	      }
	      parser.tag = null
	      parser.tagName = ''
	    }
	    parser.attribName = parser.attribValue = ''
	    parser.attribList.length = 0
	  }

	  function closeTag (parser) {
	    if (!parser.tagName) {
	      strictFail(parser, 'Weird empty close tag.')
	      parser.textNode += '</>'
	      parser.state = S.TEXT
	      return
	    }

	    if (parser.script) {
	      if (parser.tagName !== 'script') {
	        parser.script += '</' + parser.tagName + '>'
	        parser.tagName = ''
	        parser.state = S.SCRIPT
	        return
	      }
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }

	    // first make sure that the closing tag actually exists.
	    // <a><b></c></b></a> will close everything, otherwise.
	    var t = parser.tags.length
	    var tagName = parser.tagName
	    if (!parser.strict) {
	      tagName = tagName[parser.looseCase]()
	    }
	    var closeTo = tagName
	    while (t--) {
	      var close = parser.tags[t]
	      if (close.name !== closeTo) {
	        // fail the first time in strict mode
	        strictFail(parser, 'Unexpected close tag')
	      } else {
	        break
	      }
	    }

	    // didn't find it.  we already failed for strict, so just abort.
	    if (t < 0) {
	      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
	      parser.textNode += '</' + parser.tagName + '>'
	      parser.state = S.TEXT
	      return
	    }
	    parser.tagName = tagName
	    var s = parser.tags.length
	    while (s-- > t) {
	      var tag = parser.tag = parser.tags.pop()
	      parser.tagName = parser.tag.name
	      emitNode(parser, 'onclosetag', parser.tagName)

	      var x = {}
	      for (var i in tag.ns) {
	        x[i] = tag.ns[i]
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (parser.opt.xmlns && tag.ns !== parent.ns) {
	        // remove namespace bindings introduced by tag
	        Object.keys(tag.ns).forEach(function (p) {
	          var n = tag.ns[p]
	          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
	        })
	      }
	    }
	    if (t === 0) parser.closedRoot = true
	    parser.tagName = parser.attribValue = parser.attribName = ''
	    parser.attribList.length = 0
	    parser.state = S.TEXT
	  }

	  function parseEntity (parser) {
	    var entity = parser.entity
	    var entityLC = entity.toLowerCase()
	    var num
	    var numStr = ''

	    if (parser.ENTITIES[entity]) {
	      return parser.ENTITIES[entity]
	    }
	    if (parser.ENTITIES[entityLC]) {
	      return parser.ENTITIES[entityLC]
	    }
	    entity = entityLC
	    if (entity.charAt(0) === '#') {
	      if (entity.charAt(1) === 'x') {
	        entity = entity.slice(2)
	        num = parseInt(entity, 16)
	        numStr = num.toString(16)
	      } else {
	        entity = entity.slice(1)
	        num = parseInt(entity, 10)
	        numStr = num.toString(10)
	      }
	    }
	    entity = entity.replace(/^0+/, '')
	    if (numStr.toLowerCase() !== entity) {
	      strictFail(parser, 'Invalid character entity')
	      return '&' + parser.entity + ';'
	    }

	    return String.fromCodePoint(num)
	  }

	  function beginWhiteSpace (parser, c) {
	    if (c === '<') {
	      parser.state = S.OPEN_WAKA
	      parser.startTagPosition = parser.position
	    } else if (not(whitespace, c)) {
	      // have to process this as a text node.
	      // weird, but happens.
	      strictFail(parser, 'Non-whitespace before first tag.')
	      parser.textNode = c
	      parser.state = S.TEXT
	    }
	  }

	  function charAt (chunk, i) {
	    var result = ''
	    if (i < chunk.length) {
	      result = chunk.charAt(i)
	    }
	    return result
	  }

	  function write (chunk) {
	    var parser = this
	    if (this.error) {
	      throw this.error
	    }
	    if (parser.closed) {
	      return error(parser,
	        'Cannot write after close. Assign an onready handler.')
	    }
	    if (chunk === null) {
	      return end(parser)
	    }
	    if (typeof chunk === 'object') {
	      chunk = chunk.toString()
	    }
	    var i = 0
	    var c = ''
	    while (true) {
	      c = charAt(chunk, i++)
	      parser.c = c
	      if (!c) {
	        break
	      }
	      if (parser.trackPosition) {
	        parser.position++
	        if (c === '\n') {
	          parser.line++
	          parser.column = 0
	        } else {
	          parser.column++
	        }
	      }
	      switch (parser.state) {
	        case S.BEGIN:
	          parser.state = S.BEGIN_WHITESPACE
	          if (c === '\uFEFF') {
	            continue
	          }
	          beginWhiteSpace(parser, c)
	          continue

	        case S.BEGIN_WHITESPACE:
	          beginWhiteSpace(parser, c)
	          continue

	        case S.TEXT:
	          if (parser.sawRoot && !parser.closedRoot) {
	            var starti = i - 1
	            while (c && c !== '<' && c !== '&') {
	              c = charAt(chunk, i++)
	              if (c && parser.trackPosition) {
	                parser.position++
	                if (c === '\n') {
	                  parser.line++
	                  parser.column = 0
	                } else {
	                  parser.column++
	                }
	              }
	            }
	            parser.textNode += chunk.substring(starti, i - 1)
	          }
	          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
	            parser.state = S.OPEN_WAKA
	            parser.startTagPosition = parser.position
	          } else {
	            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
	              strictFail(parser, 'Text data outside of root node.')
	            }
	            if (c === '&') {
	              parser.state = S.TEXT_ENTITY
	            } else {
	              parser.textNode += c
	            }
	          }
	          continue

	        case S.SCRIPT:
	          // only non-strict
	          if (c === '<') {
	            parser.state = S.SCRIPT_ENDING
	          } else {
	            parser.script += c
	          }
	          continue

	        case S.SCRIPT_ENDING:
	          if (c === '/') {
	            parser.state = S.CLOSE_TAG
	          } else {
	            parser.script += '<' + c
	            parser.state = S.SCRIPT
	          }
	          continue

	        case S.OPEN_WAKA:
	          // either a /, ?, !, or text is coming next.
	          if (c === '!') {
	            parser.state = S.SGML_DECL
	            parser.sgmlDecl = ''
	          } else if (is(whitespace, c)) {
	            // wait for it...
	          } else if (is(nameStart, c)) {
	            parser.state = S.OPEN_TAG
	            parser.tagName = c
	          } else if (c === '/') {
	            parser.state = S.CLOSE_TAG
	            parser.tagName = ''
	          } else if (c === '?') {
	            parser.state = S.PROC_INST
	            parser.procInstName = parser.procInstBody = ''
	          } else {
	            strictFail(parser, 'Unencoded <')
	            // if there was some whitespace, then add that in.
	            if (parser.startTagPosition + 1 < parser.position) {
	              var pad = parser.position - parser.startTagPosition
	              c = new Array(pad).join(' ') + c
	            }
	            parser.textNode += '<' + c
	            parser.state = S.TEXT
	          }
	          continue

	        case S.SGML_DECL:
	          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
	            emitNode(parser, 'onopencdata')
	            parser.state = S.CDATA
	            parser.sgmlDecl = ''
	            parser.cdata = ''
	          } else if (parser.sgmlDecl + c === '--') {
	            parser.state = S.COMMENT
	            parser.comment = ''
	            parser.sgmlDecl = ''
	          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
	            parser.state = S.DOCTYPE
	            if (parser.doctype || parser.sawRoot) {
	              strictFail(parser,
	                'Inappropriately located doctype declaration')
	            }
	            parser.doctype = ''
	            parser.sgmlDecl = ''
	          } else if (c === '>') {
	            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
	            parser.sgmlDecl = ''
	            parser.state = S.TEXT
	          } else if (is(quote, c)) {
	            parser.state = S.SGML_DECL_QUOTED
	            parser.sgmlDecl += c
	          } else {
	            parser.sgmlDecl += c
	          }
	          continue

	        case S.SGML_DECL_QUOTED:
	          if (c === parser.q) {
	            parser.state = S.SGML_DECL
	            parser.q = ''
	          }
	          parser.sgmlDecl += c
	          continue

	        case S.DOCTYPE:
	          if (c === '>') {
	            parser.state = S.TEXT
	            emitNode(parser, 'ondoctype', parser.doctype)
	            parser.doctype = true // just remember that we saw it.
	          } else {
	            parser.doctype += c
	            if (c === '[') {
	              parser.state = S.DOCTYPE_DTD
	            } else if (is(quote, c)) {
	              parser.state = S.DOCTYPE_QUOTED
	              parser.q = c
	            }
	          }
	          continue

	        case S.DOCTYPE_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.q = ''
	            parser.state = S.DOCTYPE
	          }
	          continue

	        case S.DOCTYPE_DTD:
	          parser.doctype += c
	          if (c === ']') {
	            parser.state = S.DOCTYPE
	          } else if (is(quote, c)) {
	            parser.state = S.DOCTYPE_DTD_QUOTED
	            parser.q = c
	          }
	          continue

	        case S.DOCTYPE_DTD_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.state = S.DOCTYPE_DTD
	            parser.q = ''
	          }
	          continue

	        case S.COMMENT:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDING
	          } else {
	            parser.comment += c
	          }
	          continue

	        case S.COMMENT_ENDING:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDED
	            parser.comment = textopts(parser.opt, parser.comment)
	            if (parser.comment) {
	              emitNode(parser, 'oncomment', parser.comment)
	            }
	            parser.comment = ''
	          } else {
	            parser.comment += '-' + c
	            parser.state = S.COMMENT
	          }
	          continue

	        case S.COMMENT_ENDED:
	          if (c !== '>') {
	            strictFail(parser, 'Malformed comment')
	            // allow <!-- blah -- bloo --> in non-strict mode,
	            // which is a comment of " blah -- bloo "
	            parser.comment += '--' + c
	            parser.state = S.COMMENT
	          } else {
	            parser.state = S.TEXT
	          }
	          continue

	        case S.CDATA:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING
	          } else {
	            parser.cdata += c
	          }
	          continue

	        case S.CDATA_ENDING:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING_2
	          } else {
	            parser.cdata += ']' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.CDATA_ENDING_2:
	          if (c === '>') {
	            if (parser.cdata) {
	              emitNode(parser, 'oncdata', parser.cdata)
	            }
	            emitNode(parser, 'onclosecdata')
	            parser.cdata = ''
	            parser.state = S.TEXT
	          } else if (c === ']') {
	            parser.cdata += ']'
	          } else {
	            parser.cdata += ']]' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.PROC_INST:
	          if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else if (is(whitespace, c)) {
	            parser.state = S.PROC_INST_BODY
	          } else {
	            parser.procInstName += c
	          }
	          continue

	        case S.PROC_INST_BODY:
	          if (!parser.procInstBody && is(whitespace, c)) {
	            continue
	          } else if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else {
	            parser.procInstBody += c
	          }
	          continue

	        case S.PROC_INST_ENDING:
	          if (c === '>') {
	            emitNode(parser, 'onprocessinginstruction', {
	              name: parser.procInstName,
	              body: parser.procInstBody
	            })
	            parser.procInstName = parser.procInstBody = ''
	            parser.state = S.TEXT
	          } else {
	            parser.procInstBody += '?' + c
	            parser.state = S.PROC_INST_BODY
	          }
	          continue

	        case S.OPEN_TAG:
	          if (is(nameBody, c)) {
	            parser.tagName += c
	          } else {
	            newTag(parser)
	            if (c === '>') {
	              openTag(parser)
	            } else if (c === '/') {
	              parser.state = S.OPEN_TAG_SLASH
	            } else {
	              if (not(whitespace, c)) {
	                strictFail(parser, 'Invalid character in tag name')
	              }
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.OPEN_TAG_SLASH:
	          if (c === '>') {
	            openTag(parser, true)
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Forward-slash in opening tag not followed by >')
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.ATTRIB:
	          // haven't read the attribute name yet.
	          if (is(whitespace, c)) {
	            continue
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (is(nameStart, c)) {
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (c === '>') {
	            strictFail(parser, 'Attribute without value')
	            parser.attribValue = parser.attribName
	            attrib(parser)
	            openTag(parser)
	          } else if (is(whitespace, c)) {
	            parser.state = S.ATTRIB_NAME_SAW_WHITE
	          } else if (is(nameBody, c)) {
	            parser.attribName += c
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME_SAW_WHITE:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (is(whitespace, c)) {
	            continue
	          } else {
	            strictFail(parser, 'Attribute without value')
	            parser.tag.attributes[parser.attribName] = ''
	            parser.attribValue = ''
	            emitNode(parser, 'onattribute', {
	              name: parser.attribName,
	              value: ''
	            })
	            parser.attribName = ''
	            if (c === '>') {
	              openTag(parser)
	            } else if (is(nameStart, c)) {
	              parser.attribName = c
	              parser.state = S.ATTRIB_NAME
	            } else {
	              strictFail(parser, 'Invalid attribute name')
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.ATTRIB_VALUE:
	          if (is(whitespace, c)) {
	            continue
	          } else if (is(quote, c)) {
	            parser.q = c
	            parser.state = S.ATTRIB_VALUE_QUOTED
	          } else {
	            strictFail(parser, 'Unquoted attribute value')
	            parser.state = S.ATTRIB_VALUE_UNQUOTED
	            parser.attribValue = c
	          }
	          continue

	        case S.ATTRIB_VALUE_QUOTED:
	          if (c !== parser.q) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_Q
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          parser.q = ''
	          parser.state = S.ATTRIB_VALUE_CLOSED
	          continue

	        case S.ATTRIB_VALUE_CLOSED:
	          if (is(whitespace, c)) {
	            parser.state = S.ATTRIB
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (is(nameStart, c)) {
	            strictFail(parser, 'No whitespace between attributes')
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_VALUE_UNQUOTED:
	          if (not(attribEnd, c)) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_U
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          if (c === '>') {
	            openTag(parser)
	          } else {
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.CLOSE_TAG:
	          if (!parser.tagName) {
	            if (is(whitespace, c)) {
	              continue
	            } else if (not(nameStart, c)) {
	              if (parser.script) {
	                parser.script += '</' + c
	                parser.state = S.SCRIPT
	              } else {
	                strictFail(parser, 'Invalid tagname in closing tag.')
	              }
	            } else {
	              parser.tagName = c
	            }
	          } else if (c === '>') {
	            closeTag(parser)
	          } else if (is(nameBody, c)) {
	            parser.tagName += c
	          } else if (parser.script) {
	            parser.script += '</' + parser.tagName
	            parser.tagName = ''
	            parser.state = S.SCRIPT
	          } else {
	            if (not(whitespace, c)) {
	              strictFail(parser, 'Invalid tagname in closing tag')
	            }
	            parser.state = S.CLOSE_TAG_SAW_WHITE
	          }
	          continue

	        case S.CLOSE_TAG_SAW_WHITE:
	          if (is(whitespace, c)) {
	            continue
	          }
	          if (c === '>') {
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Invalid characters in closing tag')
	          }
	          continue

	        case S.TEXT_ENTITY:
	        case S.ATTRIB_VALUE_ENTITY_Q:
	        case S.ATTRIB_VALUE_ENTITY_U:
	          var returnState
	          var buffer
	          switch (parser.state) {
	            case S.TEXT_ENTITY:
	              returnState = S.TEXT
	              buffer = 'textNode'
	              break

	            case S.ATTRIB_VALUE_ENTITY_Q:
	              returnState = S.ATTRIB_VALUE_QUOTED
	              buffer = 'attribValue'
	              break

	            case S.ATTRIB_VALUE_ENTITY_U:
	              returnState = S.ATTRIB_VALUE_UNQUOTED
	              buffer = 'attribValue'
	              break
	          }

	          if (c === ';') {
	            parser[buffer] += parseEntity(parser)
	            parser.entity = ''
	            parser.state = returnState
	          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
	            parser.entity += c
	          } else {
	            strictFail(parser, 'Invalid character in entity name')
	            parser[buffer] += '&' + parser.entity + c
	            parser.entity = ''
	            parser.state = returnState
	          }

	          continue

	        default:
	          throw new Error(parser, 'Unknown state: ' + parser.state)
	      }
	    } // while

	    if (parser.position >= parser.bufferCheckPosition) {
	      checkBufferLength(parser)
	    }
	    return parser
	  }

	  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
	  if (!String.fromCodePoint) {
	    (function () {
	      var stringFromCharCode = String.fromCharCode
	      var floor = Math.floor
	      var fromCodePoint = function () {
	        var MAX_SIZE = 0x4000
	        var codeUnits = []
	        var highSurrogate
	        var lowSurrogate
	        var index = -1
	        var length = arguments.length
	        if (!length) {
	          return ''
	        }
	        var result = ''
	        while (++index < length) {
	          var codePoint = Number(arguments[index])
	          if (
	            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
	            codePoint < 0 || // not a valid Unicode code point
	            codePoint > 0x10FFFF || // not a valid Unicode code point
	            floor(codePoint) !== codePoint // not an integer
	          ) {
	            throw RangeError('Invalid code point: ' + codePoint)
	          }
	          if (codePoint <= 0xFFFF) { // BMP code point
	            codeUnits.push(codePoint)
	          } else { // Astral code point; split in surrogate halves
	            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	            codePoint -= 0x10000
	            highSurrogate = (codePoint >> 10) + 0xD800
	            lowSurrogate = (codePoint % 0x400) + 0xDC00
	            codeUnits.push(highSurrogate, lowSurrogate)
	          }
	          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
	            result += stringFromCharCode.apply(null, codeUnits)
	            codeUnits.length = 0
	          }
	        }
	        return result
	      }
	      if (Object.defineProperty) {
	        Object.defineProperty(String, 'fromCodePoint', {
	          value: fromCodePoint,
	          configurable: true,
	          writable: true
	        })
	      } else {
	        String.fromCodePoint = fromCodePoint
	      }
	    }())
	  }
	})( false ? this.sax = {} : exports)


/***/ }),
/* 277 */
/***/ (function(module, exports) {

	module.exports = require("string_decoder");

/***/ }),
/* 278 */
/***/ (function(module, exports) {

	module.exports = require("events");

/***/ }),
/* 279 */
/***/ (function(module, exports) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  "use strict";
	  exports.stripBOM = function(str) {
	    if (str[0] === '\uFEFF') {
	      return str.substring(1);
	    } else {
	      return str;
	    }
	  };

	}).call(this);


/***/ }),
/* 280 */
/***/ (function(module, exports) {

	// Generated by CoffeeScript 1.12.7
	(function() {
	  "use strict";
	  var prefixMatch;

	  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

	  exports.normalize = function(str) {
	    return str.toLowerCase();
	  };

	  exports.firstCharLowerCase = function(str) {
	    return str.charAt(0).toLowerCase() + str.slice(1);
	  };

	  exports.stripPrefix = function(str) {
	    return str.replace(prefixMatch, '');
	  };

	  exports.parseNumbers = function(str) {
	    if (!isNaN(str)) {
	      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
	    }
	    return str;
	  };

	  exports.parseBooleans = function(str) {
	    if (/^(?:true|false)$/i.test(str)) {
	      str = str.toLowerCase() === 'true';
	    }
	    return str;
	  };

	}).call(this);


/***/ }),
/* 281 */
/***/ (function(module, exports) {

	module.exports = require("timers");

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var Stream = AWS.util.stream.Stream;
	var TransformStream = AWS.util.stream.Transform;
	var ReadableStream = AWS.util.stream.Readable;
	__webpack_require__(188);

	/**
	 * @api private
	 */
	AWS.NodeHttpClient = AWS.util.inherit({
	  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
	    var self = this;
	    var endpoint = httpRequest.endpoint;
	    var pathPrefix = '';
	    if (!httpOptions) httpOptions = {};
	    if (httpOptions.proxy) {
	      pathPrefix = endpoint.protocol + '//' + endpoint.hostname;
	      if (endpoint.port !== 80 && endpoint.port !== 443) {
	        pathPrefix += ':' + endpoint.port;
	      }
	      endpoint = new AWS.Endpoint(httpOptions.proxy);
	    }

	    var useSSL = endpoint.protocol === 'https:';
	    var http = useSSL ? __webpack_require__(283) : __webpack_require__(284);
	    var options = {
	      host: endpoint.hostname,
	      port: endpoint.port,
	      method: httpRequest.method,
	      headers: httpRequest.headers,
	      path: pathPrefix + httpRequest.path
	    };

	    if (useSSL && !httpOptions.agent) {
	      options.agent = this.sslAgent();
	    }

	    AWS.util.update(options, httpOptions);
	    delete options.proxy; // proxy isn't an HTTP option
	    delete options.timeout; // timeout isn't an HTTP option

	    var stream = http.request(options, function (httpResp) {
	      if (stream.didCallback) return;

	      callback(httpResp);
	      httpResp.emit(
	        'headers',
	        httpResp.statusCode,
	        httpResp.headers,
	        httpResp.statusMessage
	      );
	    });
	    httpRequest.stream = stream; // attach stream to httpRequest
	    stream.didCallback = false;

	    // connection timeout support
	    if (httpOptions.connectTimeout) {
	      stream.on('socket', function(socket) {
	        if (socket.connecting) {
	          var timeoutId = setTimeout(function connectTimeout() {
	            if (stream.didCallback) return; stream.didCallback = true;

	            stream.abort();
	            errCallback(AWS.util.error(
	              new Error('Socket timed out without establishing a connection'),
	              {code: 'TimeoutError'}
	            ));
	          }, httpOptions.connectTimeout);
	          socket.on('connect', (function(tId) {
	            return function () {
	              clearTimeout(tId);
	            };
	          })(timeoutId));
	        }
	      });
	    }

	    // timeout support
	    stream.setTimeout(httpOptions.timeout || 0, function() {
	      if (stream.didCallback) return; stream.didCallback = true;

	      var msg = 'Connection timed out after ' + httpOptions.timeout + 'ms';
	      errCallback(AWS.util.error(new Error(msg), {code: 'TimeoutError'}));
	      stream.abort();
	    });

	    stream.on('error', function() {
	      if (stream.didCallback) return; stream.didCallback = true;
	      errCallback.apply(stream, arguments);
	    });

	    var expect = httpRequest.headers.Expect || httpRequest.headers.expect;
	    if (expect === '100-continue') {
	      stream.on('continue', function() {
	        self.writeBody(stream, httpRequest);
	      });
	    } else {
	      this.writeBody(stream, httpRequest);
	    }

	    return stream;
	  },

	  writeBody: function writeBody(stream, httpRequest) {
	    var body = httpRequest.body;
	    var totalBytes = parseInt(httpRequest.headers['Content-Length'], 10);

	    if (body instanceof Stream) {
	      // For progress support of streaming content -
	      // pipe the data through a transform stream to emit 'sendProgress' events
	      var progressStream = this.progressStream(stream, totalBytes);
	      if (progressStream) {
	        body.pipe(progressStream).pipe(stream);
	      } else {
	        body.pipe(stream);
	      }
	    } else if (body) {
	      // The provided body is a buffer/string and is already fully available in memory -
	      // For performance it's best to send it as a whole by calling stream.end(body),
	      // Callers expect a 'sendProgress' event which is best emitted once
	      // the http request stream has been fully written and all data flushed.
	      // The use of totalBytes is important over body.length for strings where
	      // length is char length and not byte length.
	      stream.once('finish', function() {
	        stream.emit('sendProgress', {
	          loaded: totalBytes,
	          total: totalBytes
	        });
	      });
	      stream.end(body);
	    } else {
	      // no request body
	      stream.end();
	    }
	  },

	  sslAgent: function sslAgent() {
	    var https = __webpack_require__(283);

	    if (!AWS.NodeHttpClient.sslAgent) {
	      AWS.NodeHttpClient.sslAgent = new https.Agent({rejectUnauthorized: true});
	      AWS.NodeHttpClient.sslAgent.setMaxListeners(0);

	      // delegate maxSockets to globalAgent, set a default limit of 50 if current value is Infinity.
	      // Users can bypass this default by supplying their own Agent as part of SDK configuration.
	      Object.defineProperty(AWS.NodeHttpClient.sslAgent, 'maxSockets', {
	        enumerable: true,
	        get: function() {
	          var defaultMaxSockets = 50;
	          var globalAgent = https.globalAgent;
	          if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === 'number') {
	            return globalAgent.maxSockets;
	          }
	          return defaultMaxSockets;
	        }
	      });
	    }
	    return AWS.NodeHttpClient.sslAgent;
	  },

	  progressStream: function progressStream(stream, totalBytes) {
	    if (typeof TransformStream === 'undefined') {
	      // for node 0.8 there is no streaming progress
	      return;
	    }
	    var loadedBytes = 0;
	    var reporter = new TransformStream();
	    reporter._transform = function(chunk, encoding, callback) {
	      if (chunk) {
	        loadedBytes += chunk.length;
	        stream.emit('sendProgress', {
	          loaded: loadedBytes,
	          total: totalBytes
	        });
	      }
	      callback(null, chunk);
	    };
	    return reporter;
	  },

	  emitter: null
	});

	/**
	 * @!ignore
	 */

	/**
	 * @api private
	 */
	AWS.HttpClient.prototype = AWS.NodeHttpClient.prototype;

	/**
	 * @api private
	 */
	AWS.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;


/***/ }),
/* 283 */
/***/ (function(module, exports) {

	module.exports = require("https");

/***/ }),
/* 284 */
/***/ (function(module, exports) {

	module.exports = require("http");

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	__webpack_require__(286);

	/**
	 * Represents credentials received from the metadata service on an EC2 instance.
	 *
	 * By default, this class will connect to the metadata service using
	 * {AWS.MetadataService} and attempt to load any available credentials. If it
	 * can connect, and credentials are available, these will be used with zero
	 * configuration.
	 *
	 * This credentials class will by default timeout after 1 second of inactivity
	 * and retry 3 times.
	 * If your requests to the EC2 metadata service are timing out, you can increase
	 * these values by configuring them directly:
	 *
	 * ```javascript
	 * AWS.config.credentials = new AWS.EC2MetadataCredentials({
	 *   httpOptions: { timeout: 5000 }, // 5 second timeout
	 *   maxRetries: 10, // retry 10 times
	 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
	 * });
	 * ```
	 *
	 * @see AWS.Config.retryDelayOptions
	 *
	 * @!macro nobrowser
	 */
	AWS.EC2MetadataCredentials = AWS.util.inherit(AWS.Credentials, {
	  constructor: function EC2MetadataCredentials(options) {
	    AWS.Credentials.call(this);

	    options = options ? AWS.util.copy(options) : {};
	    options = AWS.util.merge(
	      {maxRetries: this.defaultMaxRetries}, options);
	    if (!options.httpOptions) options.httpOptions = {};
	    options.httpOptions = AWS.util.merge(
	      {timeout: this.defaultTimeout}, options.httpOptions);

	    this.metadataService = new AWS.MetadataService(options);
	    this.metadata = {};
	  },

	  /**
	   * @api private
	   */
	  defaultTimeout: 1000,

	  /**
	   * @api private
	   */
	  defaultMaxRetries: 3,

	  /**
	   * Loads the credentials from the instance metadata service
	   *
	   * @callback callback function(err)
	   *   Called when the instance metadata service responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    if (!callback) callback = function(err) { if (err) throw err; };

	    self.metadataService.loadCredentials(function (err, creds) {
	      if (!err) {
	        self.expired = false;
	        self.metadata = creds;
	        self.accessKeyId = creds.AccessKeyId;
	        self.secretAccessKey = creds.SecretAccessKey;
	        self.sessionToken = creds.Token;
	        self.expireTime = new Date(creds.Expiration);
	      }
	      callback(err);
	    });
	  }
	});


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	__webpack_require__(188);
	var inherit = AWS.util.inherit;

	/**
	 * Represents a metadata service available on EC2 instances. Using the
	 * {request} method, you can receieve metadata about any available resource
	 * on the metadata service.
	 *
	 * You can disable the use of the IMDS by setting the AWS_EC2_METADATA_DISABLED
	 * environment variable to a truthy value.
	 *
	 * @!attribute [r] httpOptions
	 *   @return [map] a map of options to pass to the underlying HTTP request:
	 *
	 *     * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
	 *       before aborting the connection. Set to 0 for no timeout.
	 *
	 * @!macro nobrowser
	 */
	AWS.MetadataService = inherit({
	  /**
	   * @return [String] the hostname of the instance metadata service
	   */
	  host: '169.254.169.254',

	  /**
	   * @!ignore
	   */

	  /**
	   * Default HTTP options. By default, the metadata service is set to not
	   * timeout on long requests. This means that on non-EC2 machines, this
	   * request will never return. If you are calling this operation from an
	   * environment that may not always run on EC2, set a `timeout` value so
	   * the SDK will abort the request after a given number of milliseconds.
	   */
	  httpOptions: { timeout: 0 },

	  /**
	   * Creates a new MetadataService object with a given set of options.
	   *
	   * @option options host [String] the hostname of the instance metadata
	   *   service
	   * @option options httpOptions [map] a map of options to pass to the
	   *   underlying HTTP request:
	   *
	   *   * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
	   *     before aborting the connection. Set to 0 for no timeout.
	   * @option options maxRetries [Integer] the maximum number of retries to
	   *   perform for timeout errors
	   * @option options retryDelayOptions [map] A set of options to configure the
	   *   retry delay on retryable errors. See AWS.Config for details.
	   */
	  constructor: function MetadataService(options) {
	    AWS.util.update(this, options);
	  },

	  /**
	   * Sends a request to the instance metadata service for a given resource.
	   *
	   * @param path [String] the path of the resource to get
	   * @callback callback function(err, data)
	   *   Called when a response is available from the service.
	   *   @param err [Error, null] if an error occurred, this value will be set
	   *   @param data [String, null] if the request was successful, the body of
	   *     the response
	   */
	  request: function request(path, callback) {
	    if (process.env[AWS.util.imdsDisabledEnv]) {
	      callback(new Error('EC2 Instance Metadata Service access disabled'));
	      return;
	    }

	    path = path || '/';
	    var httpRequest = new AWS.HttpRequest('http://' + this.host + path);
	    httpRequest.method = 'GET';
	    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
	  },

	  /**
	  * @api private
	  */
	  loadCredentialsCallbacks: [],

	  /**
	   * Loads a set of credentials stored in the instance metadata service
	   *
	   * @api private
	   * @callback callback function(err, credentials)
	   *   Called when credentials are loaded from the resource
	   *   @param err [Error] if an error occurred, this value will be set
	   *   @param credentials [Object] the raw JSON object containing all
	   *     metadata from the credentials resource
	   */
	  loadCredentials: function loadCredentials(callback) {
	    var self = this;
	    var basePath = '/latest/meta-data/iam/security-credentials/';
	    self.loadCredentialsCallbacks.push(callback);
	    if (self.loadCredentialsCallbacks.length > 1) { return; }

	    function callbacks(err, creds) {
	      var cb;
	      while ((cb = self.loadCredentialsCallbacks.shift()) !== undefined) {
	        cb(err, creds);
	      }
	    }

	    self.request(basePath, function (err, roleName) {
	      if (err) callbacks(err);
	      else {
	        roleName = roleName.split('\n')[0]; // grab first (and only) role
	        self.request(basePath + roleName, function (credErr, credData) {
	          if (credErr) callbacks(credErr);
	          else {
	            try {
	              var credentials = JSON.parse(credData);
	              callbacks(null, credentials);
	            } catch (parseError) {
	              callbacks(parseError);
	            }
	          }
	        });
	      }
	    });
	  }
	});

	/**
	 * @api private
	 */
	module.exports = AWS.MetadataService;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160),
	  ENV_RELATIVE_URI = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI',
	  ENV_FULL_URI = 'AWS_CONTAINER_CREDENTIALS_FULL_URI',
	  ENV_AUTH_TOKEN = 'AWS_CONTAINER_AUTHORIZATION_TOKEN',
	  FULL_URI_UNRESTRICTED_PROTOCOLS = ['https:'],
	  FULL_URI_ALLOWED_PROTOCOLS = ['http:', 'https:'],
	  FULL_URI_ALLOWED_HOSTNAMES = ['localhost', '127.0.0.1'],
	  RELATIVE_URI_HOST = '169.254.170.2';

	/**
	 * Represents credentials received from specified URI.
	 *
	 * This class will request refreshable credentials from the relative URI
	 * specified by the AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or the
	 * AWS_CONTAINER_CREDENTIALS_FULL_URI environment variable. If valid credentials
	 * are returned in the response, these will be used with zero configuration.
	 *
	 * This credentials class will by default timeout after 1 second of inactivity
	 * and retry 3 times.
	 * If your requests to the relative URI are timing out, you can increase
	 * the value by configuring them directly:
	 *
	 * ```javascript
	 * AWS.config.credentials = new AWS.RemoteCredentials({
	 *   httpOptions: { timeout: 5000 }, // 5 second timeout
	 *   maxRetries: 10, // retry 10 times
	 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
	 * });
	 * ```
	 *
	 * @see AWS.Config.retryDelayOptions
	 *
	 * @!macro nobrowser
	 */
	AWS.RemoteCredentials = AWS.util.inherit(AWS.Credentials, {
	  constructor: function RemoteCredentials(options) {
	    AWS.Credentials.call(this);
	    options = options ? AWS.util.copy(options) : {};
	    if (!options.httpOptions) options.httpOptions = {};
	    options.httpOptions = AWS.util.merge(
	      this.httpOptions, options.httpOptions);
	    AWS.util.update(this, options);
	  },

	  /**
	   * @api private
	   */
	  httpOptions: { timeout: 1000 },

	  /**
	   * @api private
	   */
	  maxRetries: 3,

	  /**
	   * @api private
	   */
	  isConfiguredForEcsCredentials: function isConfiguredForEcsCredentials() {
	    return Boolean(
	        process &&
	        process.env &&
	        (process.env[ENV_RELATIVE_URI] || process.env[ENV_FULL_URI])
	    );
	  },

	  /**
	   * @api private
	   */
	  getECSFullUri: function getECSFullUri() {
	    if (process && process.env) {
	      var relative = process.env[ENV_RELATIVE_URI],
	          full = process.env[ENV_FULL_URI];
	      if (relative) {
	        return 'http://' + RELATIVE_URI_HOST + relative;
	      } else if (full) {
	        var parsed = AWS.util.urlParse(full);
	        if (FULL_URI_ALLOWED_PROTOCOLS.indexOf(parsed.protocol) < 0) {
	          throw AWS.util.error(
	            new Error('Unsupported protocol:  AWS.RemoteCredentials supports '
	              + FULL_URI_ALLOWED_PROTOCOLS.join(',') + ' only; '
	              + parsed.protocol + ' requested.'),
	            { code: 'ECSCredentialsProviderFailure' }
	          );
	        }

	        if (FULL_URI_UNRESTRICTED_PROTOCOLS.indexOf(parsed.protocol) < 0 &&
	            FULL_URI_ALLOWED_HOSTNAMES.indexOf(parsed.hostname) < 0) {
	          throw AWS.util.error(
	            new Error('Unsupported hostname: AWS.RemoteCredentials only supports '
	              + FULL_URI_ALLOWED_HOSTNAMES.join(',') + ' for ' + parsed.protocol + '; '
	              + parsed.protocol + '//' + parsed.hostname + ' requested.'),
	            { code: 'ECSCredentialsProviderFailure' }
	          );
	        }

	        return full;
	      }
	    }
	  },

	  /**
	   * @api private
	   */
	  getECSAuthToken: function getECSAuthToken() {
	    if (process && process.env && process.env[ENV_FULL_URI]) {
	      return process.env[ENV_AUTH_TOKEN];
	    }
	  },

	  /**
	   * @api private
	   */
	  credsFormatIsValid: function credsFormatIsValid(credData) {
	    return (!!credData.accessKeyId && !!credData.secretAccessKey &&
	      !!credData.sessionToken && !!credData.expireTime);
	  },

	  /**
	   * @api private
	   */
	  formatCreds: function formatCreds(credData) {
	    if (!!credData.credentials) {
	      credData = credData.credentials;
	    }

	    return {
	      expired: false,
	      accessKeyId: credData.accessKeyId || credData.AccessKeyId,
	      secretAccessKey: credData.secretAccessKey || credData.SecretAccessKey,
	      sessionToken: credData.sessionToken || credData.Token,
	      expireTime: new Date(credData.expiration || credData.Expiration)
	    };
	  },

	  /**
	   * @api private
	   */
	  request: function request(url, callback) {
	    var httpRequest = new AWS.HttpRequest(url);
	    httpRequest.method = 'GET';
	    httpRequest.headers.Accept = 'application/json';
	    var token = this.getECSAuthToken();
	    if (token) {
	      httpRequest.headers.Authorization = token;
	    }
	    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
	  },

	  /**
	   * @api private
	   */
	  refreshQueue: [],

	  /**
	   * Loads the credentials from the relative URI specified by container
	   *
	   * @callback callback function(err)
	   *   Called when the request to the relative URI responds (or fails). When
	   *   this callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, `sessionToken`, and `expireTime` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    var self = this;
	    var refreshQueue = self.refreshQueue;
	    if (!callback) callback = function(err) { if (err) throw err; };
	    refreshQueue.push({
	      provider: self,
	      errCallback: callback
	    });
	    if (refreshQueue.length > 1) { return; }

	    function callbacks(err, creds) {
	      var call, cb;
	      while ((call = refreshQueue.shift()) !== undefined) {
	        cb = call.errCallback;
	        if (!err) AWS.util.update(call.provider, creds);
	        cb(err);
	      }
	    }

	    if (process === undefined) {
	      callbacks(AWS.util.error(
	        new Error('No process info available'),
	        { code: 'ECSCredentialsProviderFailure' }
	      ));
	      return;
	    }
	    var fullUri = this.getECSFullUri();
	    if (fullUri === undefined) {
	      callbacks(AWS.util.error(
	        new Error('Variable ' + ENV_RELATIVE_URI + ' or ' + ENV_FULL_URI +
	          ' must be set to use AWS.RemoteCredentials.'),
	        { code: 'ECSCredentialsProviderFailure' }
	      ));
	      return;
	    }

	    this.request(fullUri, function(err, data) {
	      if (!err) {
	        try {
	          data = JSON.parse(data);
	          var creds = self.formatCreds(data);
	          if (!self.credsFormatIsValid(creds)) {
	            throw AWS.util.error(
	              new Error('Response data is not in valid format'),
	              { code: 'ECSCredentialsProviderFailure' }
	            );
	          }
	        } catch (dataError) {
	          err = dataError;
	        }
	      }
	      callbacks(err, creds);
	    });
	  }
	});


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * Represents credentials received from relative URI specified in the ECS container.
	 *
	 * This class will request refreshable credentials from the relative URI
	 * specified by the AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or the
	 * AWS_CONTAINER_CREDENTIALS_FULL_URI environment variable. If valid credentials
	 * are returned in the response, these will be used with zero configuration.
	 *
	 * This credentials class will by default timeout after 1 second of inactivity
	 * and retry 3 times.
	 * If your requests to the relative URI are timing out, you can increase
	 * the value by configuring them directly:
	 *
	 * ```javascript
	 * AWS.config.credentials = new AWS.ECSCredentials({
	 *   httpOptions: { timeout: 5000 }, // 5 second timeout
	 *   maxRetries: 10, // retry 10 times
	 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
	 * });
	 * ```
	 *
	 * @see AWS.Config.retryDelayOptions
	 *
	 * @!macro nobrowser
	 */
	AWS.ECSCredentials = AWS.RemoteCredentials;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * Represents credentials from the environment.
	 *
	 * By default, this class will look for the matching environment variables
	 * prefixed by a given {envPrefix}. The un-prefixed environment variable names
	 * for each credential value is listed below:
	 *
	 * ```javascript
	 * accessKeyId: ACCESS_KEY_ID
	 * secretAccessKey: SECRET_ACCESS_KEY
	 * sessionToken: SESSION_TOKEN
	 * ```
	 *
	 * With the default prefix of 'AWS', the environment variables would be:
	 *
	 *     AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
	 *
	 * @!attribute envPrefix
	 *   @readonly
	 *   @return [String] the prefix for the environment variable names excluding
	 *     the separating underscore ('_').
	 */
	AWS.EnvironmentCredentials = AWS.util.inherit(AWS.Credentials, {

	  /**
	   * Creates a new EnvironmentCredentials class with a given variable
	   * prefix {envPrefix}. For example, to load credentials using the 'AWS'
	   * prefix:
	   *
	   * ```javascript
	   * var creds = new AWS.EnvironmentCredentials('AWS');
	   * creds.accessKeyId == 'AKID' // from AWS_ACCESS_KEY_ID env var
	   * ```
	   *
	   * @param envPrefix [String] the prefix to use (e.g., 'AWS') for environment
	   *   variables. Do not include the separating underscore.
	   */
	  constructor: function EnvironmentCredentials(envPrefix) {
	    AWS.Credentials.call(this);
	    this.envPrefix = envPrefix;
	    this.get(function() {});
	  },

	  /**
	   * Loads credentials from the environment using the prefixed
	   * environment variables.
	   *
	   * @callback callback function(err)
	   *   Called after the (prefixed) ACCESS_KEY_ID, SECRET_ACCESS_KEY, and
	   *   SESSION_TOKEN environment variables are read. When this callback is
	   *   called with no error, it means that the credentials information has
	   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
	   *   and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    if (!callback) callback = function(err) { if (err) throw err; };

	    if (!process || !process.env) {
	      callback(AWS.util.error(
	        new Error('No process info or environment variables available'),
	        { code: 'EnvironmentCredentialsProviderFailure' }
	      ));
	      return;
	    }

	    var keys = ['ACCESS_KEY_ID', 'SECRET_ACCESS_KEY', 'SESSION_TOKEN'];
	    var values = [];

	    for (var i = 0; i < keys.length; i++) {
	      var prefix = '';
	      if (this.envPrefix) prefix = this.envPrefix + '_';
	      values[i] = process.env[prefix + keys[i]];
	      if (!values[i] && keys[i] !== 'SESSION_TOKEN') {
	        callback(AWS.util.error(
	          new Error('Variable ' + prefix + keys[i] + ' not set.'),
	        { code: 'EnvironmentCredentialsProviderFailure' }
	        ));
	        return;
	      }
	    }

	    this.expired = false;
	    AWS.Credentials.apply(this, values);
	    callback();
	  }

	});


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);

	/**
	 * Represents credentials from a JSON file on disk.
	 * If the credentials expire, the SDK can {refresh} the credentials
	 * from the file.
	 *
	 * The format of the file should be similar to the options passed to
	 * {AWS.Config}:
	 *
	 * ```javascript
	 * {accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'optional'}
	 * ```
	 *
	 * @example Loading credentials from disk
	 *   var creds = new AWS.FileSystemCredentials('./configuration.json');
	 *   creds.accessKeyId == 'AKID'
	 *
	 * @!attribute filename
	 *   @readonly
	 *   @return [String] the path to the JSON file on disk containing the
	 *     credentials.
	 * @!macro nobrowser
	 */
	AWS.FileSystemCredentials = AWS.util.inherit(AWS.Credentials, {

	  /**
	   * @overload AWS.FileSystemCredentials(filename)
	   *   Creates a new FileSystemCredentials object from a filename
	   *
	   *   @param filename [String] the path on disk to the JSON file to load.
	   */
	  constructor: function FileSystemCredentials(filename) {
	    AWS.Credentials.call(this);
	    this.filename = filename;
	    this.get(function() {});
	  },

	  /**
	   * Loads the credentials from the {filename} on disk.
	   *
	   * @callback callback function(err)
	   *   Called after the JSON file on disk is read and parsed. When this callback
	   *   is called with no error, it means that the credentials information
	   *   has been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
	   *   and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    if (!callback) callback = function(err) { if (err) throw err; };
	    try {
	      var creds = JSON.parse(AWS.util.readFileSync(this.filename));
	      AWS.Credentials.call(this, creds);
	      if (!this.accessKeyId || !this.secretAccessKey) {
	        throw AWS.util.error(
	          new Error('Credentials not set in ' + this.filename),
	        { code: 'FileSystemCredentialsProviderFailure' }
	        );
	      }
	      this.expired = false;
	      callback();
	    } catch (err) {
	      callback(err);
	    }
	  }

	});


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var path = __webpack_require__(236);
	var SharedIniFile = __webpack_require__(234);
	var STS = __webpack_require__(238);

	/**
	 * Represents credentials loaded from shared credentials file
	 * (defaulting to ~/.aws/credentials or defined by the
	 * `AWS_SHARED_CREDENTIALS_FILE` environment variable).
	 *
	 * ## Using the shared credentials file
	 *
	 * This provider is checked by default in the Node.js environment. To use the
	 * credentials file provider, simply add your access and secret keys to the
	 * ~/.aws/credentials file in the following format:
	 *
	 *     [default]
	 *     aws_access_key_id = AKID...
	 *     aws_secret_access_key = YOUR_SECRET_KEY
	 *
	 * ## Using custom profiles
	 *
	 * The SDK supports loading credentials for separate profiles. This can be done
	 * in two ways:
	 *
	 * 1. Set the `AWS_PROFILE` environment variable in your process prior to
	 *    loading the SDK.
	 * 2. Directly load the AWS.SharedIniFileCredentials provider:
	 *
	 * ```javascript
	 * var creds = new AWS.SharedIniFileCredentials({profile: 'myprofile'});
	 * AWS.config.credentials = creds;
	 * ```
	 *
	 * @!macro nobrowser
	 */
	AWS.SharedIniFileCredentials = AWS.util.inherit(AWS.Credentials, {
	  /**
	   * Creates a new SharedIniFileCredentials object.
	   *
	   * @param options [map] a set of options
	   * @option options profile [String] (AWS_PROFILE env var or 'default')
	   *   the name of the profile to load.
	   * @option options filename [String] ('~/.aws/credentials' or defined by
	   *   AWS_SHARED_CREDENTIALS_FILE process env var)
	   *   the filename to use when loading credentials.
	   * @option options disableAssumeRole [Boolean] (false) True to disable
	   *   support for profiles that assume an IAM role. If true, and an assume
	   *   role profile is selected, an error is raised.
	   * @option options preferStaticCredentials [Boolean] (false) True to
	   *   prefer static credentials to role_arn if both are present.
	   * @option options tokenCodeFn [Function] (null) Function to provide
	   *   STS Assume Role TokenCode, if mfa_serial is provided for profile in ini
	   *   file. Function is called with value of mfa_serial and callback, and
	   *   should provide the TokenCode or an error to the callback in the format
	   *   callback(err, token)
	   */
	  constructor: function SharedIniFileCredentials(options) {
	    AWS.Credentials.call(this);

	    options = options || {};

	    this.refreshCallbacks = [];
	    this.filename = options.filename;
	    this.profile = options.profile || process.env.AWS_PROFILE || AWS.util.defaultProfile;
	    this.disableAssumeRole = Boolean(options.disableAssumeRole);
	    this.preferStaticCredentials = Boolean(options.preferStaticCredentials);
	    this.tokenCodeFn = options.tokenCodeFn || null;
	    this.get(function() {});
	  },

	  /**
	   * @api private
	   */
	  callRefreshCallbacks: function (err) {
	    var cb;
	    while ((cb = this.refreshCallbacks.shift()) !== undefined) {
	      cb(err);
	    }
	  },

	  /**
	   * Loads the credentials from the shared credentials file
	   *
	   * @callback callback function(err)
	   *   Called after the shared INI file on disk is read and parsed. When this
	   *   callback is called with no error, it means that the credentials
	   *   information has been loaded into the object (as the `accessKeyId`,
	   *   `secretAccessKey`, and `sessionToken` properties).
	   *   @param err [Error] if an error occurred, this value will be filled
	   * @see get
	   */
	  refresh: function refresh(callback) {
	    if (!callback) callback = function(err) { if (err) throw err; };
	    this.refreshCallbacks.push(callback);
	    if (this.refreshCallbacks.length > 1) { return; }

	    try {
	      var profiles = {};
	      var i, availableProfiles;
	      if (process.env[AWS.util.configOptInEnv]) {
	        var config = new SharedIniFile({
	          isConfig: true,
	          filename: process.env[AWS.util.sharedConfigFileEnv]
	        });
	        for (i = 0, availableProfiles = config.getProfiles(); i < availableProfiles.length; i++) {
	          profiles[availableProfiles[i]] = config.getProfile(availableProfiles[i]);
	        }
	      }
	      var creds = new SharedIniFile({
	        filename: this.filename ||
	          (process.env[AWS.util.configOptInEnv] && process.env[AWS.util.sharedCredentialsFileEnv])
	      });
	      for (i = 0, availableProfiles = creds.getProfiles(); i < availableProfiles.length; i++) {
	        profiles[availableProfiles[i]] = creds.getProfile(availableProfiles[i]);
	      }
	      var profile = profiles[this.profile] || {};

	      if (Object.keys(profile).length === 0) {
	        throw AWS.util.error(
	          new Error('Profile ' + this.profile + ' not found'),
	          { code: 'SharedIniFileCredentialsProviderFailure' }
	        );
	      }

	      /*
	      In the CLI, the presence of both a role_arn and static credentials have
	      different meanings depending on how many profiles have been visited. For
	      the first profile processed, role_arn takes precedence over any static
	      credentials, but for all subsequent profiles, static credentials are
	      used if present, and only in their absence will the profile's
	      source_profile and role_arn keys be used to load another set of
	      credentials. This var is intended to yield compatible behaviour in this
	      sdk.
	      */
	      var preferStaticCredentialsToRoleArn = Boolean(
	        this.preferStaticCredentials
	        && profile['aws_access_key_id']
	        && profile['aws_secret_access_key']
	      );

	      if (profile['role_arn'] && !preferStaticCredentialsToRoleArn) {
	        this.loadRoleProfile(profiles, profile);
	        return;
	      }

	      this.accessKeyId = profile['aws_access_key_id'];
	      this.secretAccessKey = profile['aws_secret_access_key'];
	      this.sessionToken = profile['aws_session_token'];

	      if (!this.accessKeyId || !this.secretAccessKey) {
	        throw AWS.util.error(
	          new Error('Credentials not set for profile ' + this.profile),
	          { code: 'SharedIniFileCredentialsProviderFailure' }
	        );
	      }
	      this.expired = false;
	      this.callRefreshCallbacks();
	    } catch (err) {
	      this.callRefreshCallbacks(err);
	    }
	  },

	  /**
	   * @api private
	   */
	  loadRoleProfile: function loadRoleProfile(creds, roleProfile) {
	    if (this.disableAssumeRole) {
	      throw AWS.util.error(
	        new Error('Role assumption profiles are disabled. ' +
	                  'Failed to load profile ' + this.profile +
	                  ' from ' + creds.filename),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    var self = this;
	    var roleArn = roleProfile['role_arn'];
	    var roleSessionName = roleProfile['role_session_name'];
	    var externalId = roleProfile['external_id'];
	    var mfaSerial = roleProfile['mfa_serial'];
	    var sourceProfileName = roleProfile['source_profile'];

	    if (!sourceProfileName) {
	      throw AWS.util.error(
	        new Error('source_profile is not set using profile ' + this.profile),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    var sourceProfileExistanceTest = creds[sourceProfileName];

	    if (typeof sourceProfileExistanceTest !== 'object') {
	      throw AWS.util.error(
	        new Error('source_profile ' + sourceProfileName + ' using profile '
	          + this.profile + ' does not exist'),
	        { code: 'SharedIniFileCredentialsProviderFailure' }
	      );
	    }

	    var sourceCredentials = new AWS.SharedIniFileCredentials(
	      AWS.util.merge(this.options || {}, {
	        profile: sourceProfileName,
	        preferStaticCredentials: true
	      })
	    );

	    this.roleArn = roleArn;
	    var sts = new STS({
	      credentials: sourceCredentials
	    });

	    var roleParams = {
	      RoleArn: roleArn,
	      RoleSessionName: roleSessionName || 'aws-sdk-js-' + Date.now()
	    };

	    if (externalId) {
	      roleParams.ExternalId = externalId;
	    }

	    if (mfaSerial && self.tokenCodeFn) {
	      roleParams.SerialNumber = mfaSerial;
	      self.tokenCodeFn(mfaSerial, function(err, token) {
	        if (err) {
	          var message;
	          if (err instanceof Error) {
	            message = err.message;
	          } else {
	            message = err;
	          }
	          self.callRefreshCallbacks(
	            AWS.util.error(
	              new Error('Error fetching MFA token: ' + message),
	              { code: 'SharedIniFileCredentialsProviderFailure' }
	            ));
	          return;
	        }

	        roleParams.TokenCode = token;
	        self.assumeRole(sts, roleParams);
	      });
	      return;
	    }

	    self.assumeRole(sts, roleParams);
	  },

	  /**
	   * @api private
	   */
	  assumeRole: function(sts, roleParams) {
	    var self = this;
	    sts.assumeRole(roleParams, function (err, data) {
	      if (err) {
	        self.callRefreshCallbacks(err);
	        return;
	      }

	      self.accessKeyId = data.Credentials.AccessKeyId;
	      self.secretAccessKey = data.Credentials.SecretAccessKey;
	      self.sessionToken = data.Credentials.SessionToken;
	      self.expireTime = data.Credentials.Expiration;
	      self.callRefreshCallbacks();
	    });
	  }

	});


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	__webpack_require__(293);

	AWS.util.update(AWS.DynamoDB.prototype, {
	  /**
	   * @api private
	   */
	  setupRequestListeners: function setupRequestListeners(request) {
	    if (request.service.config.dynamoDbCrc32) {
	      request.removeListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
	      request.addListener('extractData', this.checkCrc32);
	      request.addListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
	    }
	  },

	  /**
	   * @api private
	   */
	  checkCrc32: function checkCrc32(resp) {
	    if (!resp.httpResponse.streaming && !resp.request.service.crc32IsValid(resp)) {
	      resp.data = null;
	      resp.error = AWS.util.error(new Error(), {
	        code: 'CRC32CheckFailed',
	        message: 'CRC32 integrity check failed',
	        retryable: true
	      });
	      resp.request.haltHandlersOnError();
	      throw (resp.error);
	    }
	  },

	  /**
	   * @api private
	   */
	  crc32IsValid: function crc32IsValid(resp) {
	    var crc = resp.httpResponse.headers['x-amz-crc32'];
	    if (!crc) return true; // no (valid) CRC32 header
	    return parseInt(crc, 10) === AWS.util.crypto.crc32(resp.httpResponse.body);
	  },

	  /**
	   * @api private
	   */
	  defaultRetryCount: 10,

	  /**
	   * @api private
	   */
	  retryDelays: function retryDelays(retryCount) {
	    var retryDelayOptions = AWS.util.copy(this.config.retryDelayOptions);

	    if (typeof retryDelayOptions.base !== 'number') {
	        retryDelayOptions.base = 50; // default for dynamodb
	    }
	    var delay = AWS.util.calculateRetryDelay(retryCount, retryDelayOptions);
	    return delay;
	  }
	});


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var Translator = __webpack_require__(294);
	var DynamoDBSet = __webpack_require__(297);

	/**
	 * The document client simplifies working with items in Amazon DynamoDB
	 * by abstracting away the notion of attribute values. This abstraction
	 * annotates native JavaScript types supplied as input parameters, as well
	 * as converts annotated response data to native JavaScript types.
	 *
	 * ## Marshalling Input and Unmarshalling Response Data
	 *
	 * The document client affords developers the use of native JavaScript types
	 * instead of `AttributeValue`s to simplify the JavaScript development
	 * experience with Amazon DynamoDB. JavaScript objects passed in as parameters
	 * are marshalled into `AttributeValue` shapes required by Amazon DynamoDB.
	 * Responses from DynamoDB are unmarshalled into plain JavaScript objects
	 * by the `DocumentClient`. The `DocumentClient`, does not accept
	 * `AttributeValue`s in favor of native JavaScript types.
	 *
	 * |                             JavaScript Type                            | DynamoDB AttributeValue |
	 * |:----------------------------------------------------------------------:|-------------------------|
	 * | String                                                                 | S                       |
	 * | Number                                                                 | N                       |
	 * | Boolean                                                                | BOOL                    |
	 * | null                                                                   | NULL                    |
	 * | Array                                                                  | L                       |
	 * | Object                                                                 | M                       |
	 * | Buffer, File, Blob, ArrayBuffer, DataView, and JavaScript typed arrays | B                       |
	 *
	 * ## Support for Sets
	 *
	 * The `DocumentClient` offers a convenient way to create sets from
	 * JavaScript Arrays. The type of set is inferred from the first element
	 * in the array. DynamoDB supports string, number, and binary sets. To
	 * learn more about supported types see the
	 * [Amazon DynamoDB Data Model Documentation](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html)
	 * For more information see {AWS.DynamoDB.DocumentClient.createSet}
	 *
	 */
	AWS.DynamoDB.DocumentClient = AWS.util.inherit({

	  /**
	   * @api private
	   */
	  operations: {
	    batchGetItem: 'batchGet',
	    batchWriteItem: 'batchWrite',
	    putItem: 'put',
	    getItem: 'get',
	    deleteItem: 'delete',
	    updateItem: 'update',
	    scan: 'scan',
	    query: 'query'
	  },

	  /**
	   * Creates a DynamoDB document client with a set of configuration options.
	   *
	   * @option options params [map] An optional map of parameters to bind to every
	   *   request sent by this service object.
	   * @option options service [AWS.DynamoDB] An optional pre-configured instance
	   *  of the AWS.DynamoDB service object to use for requests. The object may
	   *  bound parameters used by the document client.
	   * @option options convertEmptyValues [Boolean] set to true if you would like
	   *  the document client to convert empty values (0-length strings, binary
	   *  buffers, and sets) to be converted to NULL types when persisting to
	   *  DynamoDB.
	   * @see AWS.DynamoDB.constructor
	   *
	   */
	  constructor: function DocumentClient(options) {
	    var self = this;
	    self.options = options || {};
	    self.configure(self.options);
	  },

	  /**
	   * @api private
	   */
	  configure: function configure(options) {
	    var self = this;
	    self.service = options.service;
	    self.bindServiceObject(options);
	    self.attrValue = options.attrValue =
	      self.service.api.operations.putItem.input.members.Item.value.shape;
	  },

	  /**
	   * @api private
	   */
	  bindServiceObject: function bindServiceObject(options) {
	    var self = this;
	    options = options || {};

	    if (!self.service) {
	      self.service = new AWS.DynamoDB(options);
	    } else {
	      var config = AWS.util.copy(self.service.config);
	      self.service = new self.service.constructor.__super__(config);
	      self.service.config.params =
	        AWS.util.merge(self.service.config.params || {}, options.params);
	    }
	  },

	  /**
	   * Returns the attributes of one or more items from one or more tables
	   * by delegating to `AWS.DynamoDB.batchGetItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.batchGetItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.batchGetItem
	   * @example Get items from multiple tables
	   *  var params = {
	   *    RequestItems: {
	   *      'Table-1': {
	   *        Keys: [
	   *          {
	   *             HashKey: 'haskey',
	   *             NumberRangeKey: 1
	   *          }
	   *        ]
	   *      },
	   *      'Table-2': {
	   *        Keys: [
	   *          { foo: 'bar' },
	   *        ]
	   *      }
	   *    }
	   *  };
	   *
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  documentClient.batchGet(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  batchGet: function(params, callback) {
	    var self = this;
	    var request = self.service.batchGetItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Puts or deletes multiple items in one or more tables by delegating
	   * to `AWS.DynamoDB.batchWriteItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.batchWriteItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.batchWriteItem
	   * @example Write to and delete from a table
	   *  var params = {
	   *    RequestItems: {
	   *      'Table-1': [
	   *        {
	   *          DeleteRequest: {
	   *            Key: { HashKey: 'someKey' }
	   *          }
	   *        },
	   *        {
	   *          PutRequest: {
	   *            Item: {
	   *              HashKey: 'anotherKey',
	   *              NumAttribute: 1,
	   *              BoolAttribute: true,
	   *              ListAttribute: [1, 'two', false],
	   *              MapAttribute: { foo: 'bar' }
	   *            }
	   *          }
	   *        }
	   *      ]
	   *    }
	   *  };
	   *
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  documentClient.batchWrite(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  batchWrite: function(params, callback) {
	    var self = this;
	    var request = self.service.batchWriteItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Deletes a single item in a table by primary key by delegating to
	   * `AWS.DynamoDB.deleteItem()`
	   *
	   * Supply the same parameters as {AWS.DynamoDB.deleteItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.deleteItem
	   * @example Delete an item from a table
	   *  var params = {
	   *    TableName : 'Table',
	   *    Key: {
	   *      HashKey: 'hashkey',
	   *      NumberRangeKey: 1
	   *    }
	   *  };
	   *
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  documentClient.delete(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  delete: function(params, callback) {
	    var self = this;
	    var request = self.service.deleteItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Returns a set of attributes for the item with the given primary key
	   * by delegating to `AWS.DynamoDB.getItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.getItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.getItem
	   * @example Get an item from a table
	   *  var params = {
	   *    TableName : 'Table',
	   *    Key: {
	   *      HashKey: 'hashkey'
	   *    }
	   *  };
	   *
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  documentClient.get(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  get: function(params, callback) {
	    var self = this;
	    var request = self.service.getItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Creates a new item, or replaces an old item with a new item by
	   * delegating to `AWS.DynamoDB.putItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.putItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.putItem
	   * @example Create a new item in a table
	   *  var params = {
	   *    TableName : 'Table',
	   *    Item: {
	   *       HashKey: 'haskey',
	   *       NumAttribute: 1,
	   *       BoolAttribute: true,
	   *       ListAttribute: [1, 'two', false],
	   *       MapAttribute: { foo: 'bar'},
	   *       NullAttribute: null
	   *    }
	   *  };
	   *
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  documentClient.put(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  put: function put(params, callback) {
	    var self = this;
	    var request = self.service.putItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Edits an existing item's attributes, or adds a new item to the table if
	   * it does not already exist by delegating to `AWS.DynamoDB.updateItem()`.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.updateItem} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.updateItem
	   * @example Update an item with expressions
	   *  var params = {
	   *    TableName: 'Table',
	   *    Key: { HashKey : 'hashkey' },
	   *    UpdateExpression: 'set #a = :x + :y',
	   *    ConditionExpression: '#a < :MAX',
	   *    ExpressionAttributeNames: {'#a' : 'Sum'},
	   *    ExpressionAttributeValues: {
	   *      ':x' : 20,
	   *      ':y' : 45,
	   *      ':MAX' : 100,
	   *    }
	   *  };
	   *
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  documentClient.update(params, function(err, data) {
	   *     if (err) console.log(err);
	   *     else console.log(data);
	   *  });
	   *
	   */
	  update: function(params, callback) {
	    var self = this;
	    var request = self.service.updateItem(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Returns one or more items and item attributes by accessing every item
	   * in a table or a secondary index.
	   *
	   * Supply the same parameters as {AWS.DynamoDB.scan} with
	   * `AttributeValue`s substituted by native JavaScript types.
	   *
	   * @see AWS.DynamoDB.scan
	   * @example Scan the table with a filter expression
	   *  var params = {
	   *    TableName : 'Table',
	   *    FilterExpression : 'Year = :this_year',
	   *    ExpressionAttributeValues : {':this_year' : 2015}
	   *  };
	   *
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  documentClient.scan(params, function(err, data) {
	   *     if (err) console.log(err);
	   *     else console.log(data);
	   *  });
	   *
	   */
	  scan: function(params, callback) {
	    var self = this;
	    var request = self.service.scan(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	   /**
	    * Directly access items from a table by primary key or a secondary index.
	    *
	    * Supply the same parameters as {AWS.DynamoDB.query} with
	    * `AttributeValue`s substituted by native JavaScript types.
	    *
	    * @see AWS.DynamoDB.query
	    * @example Query an index
	    *  var params = {
	    *    TableName: 'Table',
	    *    IndexName: 'Index',
	    *    KeyConditionExpression: 'HashKey = :hkey and RangeKey > :rkey',
	    *    ExpressionAttributeValues: {
	    *      ':hkey': 'key',
	    *      ':rkey': 2015
	    *    }
	    *  };
	    *
	    *  var documentClient = new AWS.DynamoDB.DocumentClient();
	    *
	    *  documentClient.query(params, function(err, data) {
	    *     if (err) console.log(err);
	    *     else console.log(data);
	    *  });
	    *
	    */
	  query: function(params, callback) {
	    var self = this;
	    var request = self.service.query(params);
	    self.setupRequest(request);
	    self.setupResponse(request);
	    if (typeof callback === 'function') {
	      request.send(callback);
	    }
	    return request;
	  },

	  /**
	   * Creates a set of elements inferring the type of set from
	   * the type of the first element. Amazon DynamoDB currently supports
	   * the number sets, string sets, and binary sets. For more information
	   * about DynamoDB data types see the documentation on the
	   * [Amazon DynamoDB Data Model](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModel.DataTypes).
	   *
	   * @param list [Array] Collection to represent your DynamoDB Set
	   * @param options [map]
	   *  * **validate** [Boolean] set to true if you want to validate the type
	   *    of each element in the set. Defaults to `false`.
	   * @example Creating a number set
	   *  var documentClient = new AWS.DynamoDB.DocumentClient();
	   *
	   *  var params = {
	   *    Item: {
	   *      hashkey: 'hashkey'
	   *      numbers: documentClient.createSet([1, 2, 3]);
	   *    }
	   *  };
	   *
	   *  documentClient.put(params, function(err, data) {
	   *    if (err) console.log(err);
	   *    else console.log(data);
	   *  });
	   *
	   */
	  createSet: function(list, options) {
	    options = options || {};
	    return new DynamoDBSet(list, options);
	  },

	  /**
	   * @api private
	   */
	  getTranslator: function() {
	    return new Translator(this.options);
	  },

	  /**
	   * @api private
	   */
	  setupRequest: function setupRequest(request) {
	    var self = this;
	    var translator = self.getTranslator();
	    var operation = request.operation;
	    var inputShape = request.service.api.operations[operation].input;
	    request._events.validate.unshift(function(req) {
	      req.rawParams = AWS.util.copy(req.params);
	      req.params = translator.translateInput(req.rawParams, inputShape);
	    });
	  },

	  /**
	   * @api private
	   */
	  setupResponse: function setupResponse(request) {
	    var self = this;
	    var translator = self.getTranslator();
	    var outputShape = self.service.api.operations[request.operation].output;
	    request.on('extractData', function(response) {
	      response.data = translator.translateOutput(response.data, outputShape);
	    });

	    var response = request.response;
	    response.nextPage = function(cb) {
	      var resp = this;
	      var req = resp.request;
	      var config;
	      var service = req.service;
	      var operation = req.operation;
	      try {
	        config = service.paginationConfig(operation, true);
	      } catch (e) { resp.error = e; }

	      if (!resp.hasNextPage()) {
	        if (cb) cb(resp.error, null);
	        else if (resp.error) throw resp.error;
	        return null;
	      }

	      var params = AWS.util.copy(req.rawParams);
	      if (!resp.nextPageTokens) {
	        return cb ? cb(null, null) : null;
	      } else {
	        var inputTokens = config.inputToken;
	        if (typeof inputTokens === 'string') inputTokens = [inputTokens];
	        for (var i = 0; i < inputTokens.length; i++) {
	          params[inputTokens[i]] = resp.nextPageTokens[i];
	        }
	        return self[operation](params, cb);
	      }
	    };
	  }

	});

	/**
	 * @api private
	 */
	module.exports = AWS.DynamoDB.DocumentClient;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(160).util;
	var convert = __webpack_require__(295);

	var Translator = function(options) {
	  options = options || {};
	  this.attrValue = options.attrValue;
	  this.convertEmptyValues = Boolean(options.convertEmptyValues);
	  this.wrapNumbers = Boolean(options.wrapNumbers);
	};

	Translator.prototype.translateInput = function(value, shape) {
	  this.mode = 'input';
	  return this.translate(value, shape);
	};

	Translator.prototype.translateOutput = function(value, shape) {
	  this.mode = 'output';
	  return this.translate(value, shape);
	};

	Translator.prototype.translate = function(value, shape) {
	  var self = this;
	  if (!shape || value === undefined) return undefined;

	  if (shape.shape === self.attrValue) {
	    return convert[self.mode](value, {
	      convertEmptyValues: self.convertEmptyValues,
	      wrapNumbers: self.wrapNumbers,
	    });
	  }
	  switch (shape.type) {
	    case 'structure': return self.translateStructure(value, shape);
	    case 'map': return self.translateMap(value, shape);
	    case 'list': return self.translateList(value, shape);
	    default: return self.translateScalar(value, shape);
	  }
	};

	Translator.prototype.translateStructure = function(structure, shape) {
	  var self = this;
	  if (structure == null) return undefined;

	  var struct = {};
	  util.each(structure, function(name, value) {
	    var memberShape = shape.members[name];
	    if (memberShape) {
	      var result = self.translate(value, memberShape);
	      if (result !== undefined) struct[name] = result;
	    }
	  });
	  return struct;
	};

	Translator.prototype.translateList = function(list, shape) {
	  var self = this;
	  if (list == null) return undefined;

	  var out = [];
	  util.arrayEach(list, function(value) {
	    var result = self.translate(value, shape.member);
	    if (result === undefined) out.push(null);
	    else out.push(result);
	  });
	  return out;
	};

	Translator.prototype.translateMap = function(map, shape) {
	  var self = this;
	  if (map == null) return undefined;

	  var out = {};
	  util.each(map, function(key, value) {
	    var result = self.translate(value, shape.value);
	    if (result === undefined) out[key] = null;
	    else out[key] = result;
	  });
	  return out;
	};

	Translator.prototype.translateScalar = function(value, shape) {
	  return shape.toType(value);
	};

	/**
	 * @api private
	 */
	module.exports = Translator;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(160);
	var util = AWS.util;
	var typeOf = __webpack_require__(296).typeOf;
	var DynamoDBSet = __webpack_require__(297);
	var NumberValue = __webpack_require__(298);

	AWS.DynamoDB.Converter = {
	  /**
	   * Convert a JavaScript value to its equivalent DynamoDB AttributeValue type
	   *
	   * @param data [any] The data to convert to a DynamoDB AttributeValue
	   * @param options [map]
	   * @option options convertEmptyValues [Boolean] Whether to automatically
	   *                                              convert empty strings, blobs,
	   *                                              and sets to `null`
	   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
	   *                                        NumberValue object instead of
	   *                                        converting them to native JavaScript
	   *                                        numbers. This allows for the safe
	   *                                        round-trip transport of numbers of
	   *                                        arbitrary size.
	   * @return [map] An object in the Amazon DynamoDB AttributeValue format
	   *
	   * @see AWS.DynamoDB.Converter.marshall AWS.DynamoDB.Converter.marshall to
	   *    convert entire records (rather than individual attributes)
	   */
	  input: function convertInput(data, options) {
	    options = options || {};
	    var type = typeOf(data);
	    if (type === 'Object') {
	      return formatMap(data, options);
	    } else if (type === 'Array') {
	      return formatList(data, options);
	    } else if (type === 'Set') {
	      return formatSet(data, options);
	    } else if (type === 'String') {
	      if (data.length === 0 && options.convertEmptyValues) {
	        return convertInput(null);
	      }
	      return { S: data };
	    } else if (type === 'Number' || type === 'NumberValue') {
	      return { N: data.toString() };
	    } else if (type === 'Binary') {
	      if (data.length === 0 && options.convertEmptyValues) {
	        return convertInput(null);
	      }
	      return { B: data };
	    } else if (type === 'Boolean') {
	      return { BOOL: data };
	    } else if (type === 'null') {
	      return { NULL: true };
	    } else if (type !== 'undefined' && type !== 'Function') {
	      // this value has a custom constructor
	      return formatMap(data, options);
	    }
	  },

	  /**
	   * Convert a JavaScript object into a DynamoDB record.
	   *
	   * @param data [any] The data to convert to a DynamoDB record
	   * @param options [map]
	   * @option options convertEmptyValues [Boolean] Whether to automatically
	   *                                              convert empty strings, blobs,
	   *                                              and sets to `null`
	   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
	   *                                        NumberValue object instead of
	   *                                        converting them to native JavaScript
	   *                                        numbers. This allows for the safe
	   *                                        round-trip transport of numbers of
	   *                                        arbitrary size.
	   *
	   * @return [map] An object in the DynamoDB record format.
	   *
	   * @example Convert a JavaScript object into a DynamoDB record
	   *  var marshalled = AWS.DynamoDB.Converter.marshall({
	   *    string: 'foo',
	   *    list: ['fizz', 'buzz', 'pop'],
	   *    map: {
	   *      nestedMap: {
	   *        key: 'value',
	   *      }
	   *    },
	   *    number: 123,
	   *    nullValue: null,
	   *    boolValue: true,
	   *    stringSet: new DynamoDBSet(['foo', 'bar', 'baz'])
	   *  });
	   */
	  marshall: function marshallItem(data, options) {
	    return AWS.DynamoDB.Converter.input(data, options).M;
	  },

	  /**
	   * Convert a DynamoDB AttributeValue object to its equivalent JavaScript type.
	   *
	   * @param data [map] An object in the Amazon DynamoDB AttributeValue format
	   * @param options [map]
	   * @option options convertEmptyValues [Boolean] Whether to automatically
	   *                                              convert empty strings, blobs,
	   *                                              and sets to `null`
	   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
	   *                                        NumberValue object instead of
	   *                                        converting them to native JavaScript
	   *                                        numbers. This allows for the safe
	   *                                        round-trip transport of numbers of
	   *                                        arbitrary size.
	   *
	   * @return [Object|Array|String|Number|Boolean|null]
	   *
	   * @see AWS.DynamoDB.Converter.unmarshall AWS.DynamoDB.Converter.unmarshall to
	   *    convert entire records (rather than individual attributes)
	   */
	  output: function convertOutput(data, options) {
	    options = options || {};
	    var list, map, i;
	    for (var type in data) {
	      var values = data[type];
	      if (type === 'M') {
	        map = {};
	        for (var key in values) {
	          map[key] = convertOutput(values[key], options);
	        }
	        return map;
	      } else if (type === 'L') {
	        list = [];
	        for (i = 0; i < values.length; i++) {
	          list.push(convertOutput(values[i], options));
	        }
	        return list;
	      } else if (type === 'SS') {
	        list = [];
	        for (i = 0; i < values.length; i++) {
	          list.push(values[i] + '');
	        }
	        return new DynamoDBSet(list);
	      } else if (type === 'NS') {
	        list = [];
	        for (i = 0; i < values.length; i++) {
	          list.push(convertNumber(values[i], options.wrapNumbers));
	        }
	        return new DynamoDBSet(list);
	      } else if (type === 'BS') {
	        list = [];
	        for (i = 0; i < values.length; i++) {
	          list.push(new util.Buffer(values[i]));
	        }
	        return new DynamoDBSet(list);
	      } else if (type === 'S') {
	        return values + '';
	      } else if (type === 'N') {
	        return convertNumber(values, options.wrapNumbers);
	      } else if (type === 'B') {
	        return new util.Buffer(values);
	      } else if (type === 'BOOL') {
	        return (values === 'true' || values === 'TRUE' || values === true);
	      } else if (type === 'NULL') {
	        return null;
	      }
	    }
	  },

	  /**
	   * Convert a DynamoDB record into a JavaScript object.
	   *
	   * @param data [any] The DynamoDB record
	   * @param options [map]
	   * @option options convertEmptyValues [Boolean] Whether to automatically
	   *                                              convert empty strings, blobs,
	   *                                              and sets to `null`
	   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
	   *                                        NumberValue object instead of
	   *                                        converting them to native JavaScript
	   *                                        numbers. This allows for the safe
	   *                                        round-trip transport of numbers of
	   *                                        arbitrary size.
	   *
	   * @return [map] An object whose properties have been converted from
	   *    DynamoDB's AttributeValue format into their corresponding native
	   *    JavaScript types.
	   *
	   * @example Convert a record received from a DynamoDB stream
	   *  var unmarshalled = AWS.DynamoDB.Converter.unmarshall({
	   *    string: {S: 'foo'},
	   *    list: {L: [{S: 'fizz'}, {S: 'buzz'}, {S: 'pop'}]},
	   *    map: {
	   *      M: {
	   *        nestedMap: {
	   *          M: {
	   *            key: {S: 'value'}
	   *          }
	   *        }
	   *      }
	   *    },
	   *    number: {N: '123'},
	   *    nullValue: {NULL: true},
	   *    boolValue: {BOOL: true}
	   *  });
	   */
	  unmarshall: function unmarshall(data, options) {
	    return AWS.DynamoDB.Converter.output({M: data}, options);
	  }
	};

	/**
	 * @api private
	 * @param data [Array]
	 * @param options [map]
	 */
	function formatList(data, options) {
	  var list = {L: []};
	  for (var i = 0; i < data.length; i++) {
	    list['L'].push(AWS.DynamoDB.Converter.input(data[i], options));
	  }
	  return list;
	}

	/**
	 * @api private
	 * @param value [String]
	 * @param wrapNumbers [Boolean]
	 */
	function convertNumber(value, wrapNumbers) {
	  return wrapNumbers ? new NumberValue(value) : Number(value);
	}

	/**
	 * @api private
	 * @param data [map]
	 * @param options [map]
	 */
	function formatMap(data, options) {
	  var map = {M: {}};
	  for (var key in data) {
	    var formatted = AWS.DynamoDB.Converter.input(data[key], options);
	    if (formatted !== void 0) {
	      map['M'][key] = formatted;
	    }
	  }
	  return map;
	}

	/**
	 * @api private
	 */
	function formatSet(data, options) {
	  options = options || {};
	  var values = data.values;
	  if (options.convertEmptyValues) {
	    values = filterEmptySetValues(data);
	    if (values.length === 0) {
	      return AWS.DynamoDB.Converter.input(null);
	    }
	  }

	  var map = {};
	  switch (data.type) {
	    case 'String': map['SS'] = values; break;
	    case 'Binary': map['BS'] = values; break;
	    case 'Number': map['NS'] = values.map(function (value) {
	      return value.toString();
	    });
	  }
	  return map;
	}

	/**
	 * @api private
	 */
	function filterEmptySetValues(set) {
	    var nonEmptyValues = [];
	    var potentiallyEmptyTypes = {
	        String: true,
	        Binary: true,
	        Number: false
	    };
	    if (potentiallyEmptyTypes[set.type]) {
	        for (var i = 0; i < set.values.length; i++) {
	            if (set.values[i].length === 0) {
	                continue;
	            }
	            nonEmptyValues.push(set.values[i]);
	        }

	        return nonEmptyValues;
	    }

	    return set.values;
	}

	/**
	 * @api private
	 */
	module.exports = AWS.DynamoDB.Converter;


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(160).util;

	function typeOf(data) {
	  if (data === null && typeof data === 'object') {
	    return 'null';
	  } else if (data !== undefined && isBinary(data)) {
	    return 'Binary';
	  } else if (data !== undefined && data.constructor) {
	    return data.wrapperName || util.typeName(data.constructor);
	  } else if (data !== undefined && typeof data === 'object') {
	    // this object is the result of Object.create(null), hence the absence of a
	    // defined constructor
	    return 'Object';
	  } else {
	    return 'undefined';
	  }
	}

	function isBinary(data) {
	  var types = [
	    'Buffer', 'File', 'Blob', 'ArrayBuffer', 'DataView',
	    'Int8Array', 'Uint8Array', 'Uint8ClampedArray',
	    'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array',
	    'Float32Array', 'Float64Array'
	  ];
	  if (util.isNode()) {
	    var Stream = util.stream.Stream;
	    if (util.Buffer.isBuffer(data) || data instanceof Stream) {
	      return true;
	    }
	  }

	  for (var i = 0; i < types.length; i++) {
	    if (data !== undefined && data.constructor) {
	      if (util.isType(data, types[i])) return true;
	      if (util.typeName(data.constructor) === types[i]) return true;
	    }
	  }

	  return false;
	}

	/**
	 * @api private
	 */
	module.exports = {
	  typeOf: typeOf,
	  isBinary: isBinary
	};


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(160).util;
	var typeOf = __webpack_require__(296).typeOf;

	/**
	 * @api private
	 */
	var memberTypeToSetType = {
	  'String': 'String',
	  'Number': 'Number',
	  'NumberValue': 'Number',
	  'Binary': 'Binary'
	};

	/**
	 * @api private
	 */
	var DynamoDBSet = util.inherit({

	  constructor: function Set(list, options) {
	    options = options || {};
	    this.wrapperName = 'Set';
	    this.initialize(list, options.validate);
	  },

	  initialize: function(list, validate) {
	    var self = this;
	    self.values = [].concat(list);
	    self.detectType();
	    if (validate) {
	      self.validate();
	    }
	  },

	  detectType: function() {
	    this.type = memberTypeToSetType[typeOf(this.values[0])];
	    if (!this.type) {
	      throw util.error(new Error(), {
	        code: 'InvalidSetType',
	        message: 'Sets can contain string, number, or binary values'
	      });
	    }
	  },

	  validate: function() {
	    var self = this;
	    var length = self.values.length;
	    var values = self.values;
	    for (var i = 0; i < length; i++) {
	      if (memberTypeToSetType[typeOf(values[i])] !== self.type) {
	        throw util.error(new Error(), {
	          code: 'InvalidType',
	          message: self.type + ' Set contains ' + typeOf(values[i]) + ' value'
	        });
	      }
	    }
	  }

	});

	/**
	 * @api private
	 */
	module.exports = DynamoDBSet;


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(160).util;

	/**
	 * An object recognizable as a numeric value that stores the underlying number
	 * as a string.
	 *
	 * Intended to be a deserialization target for the DynamoDB Document Client when
	 * the `wrapNumbers` flag is set. This allows for numeric values that lose
	 * precision when converted to JavaScript's `number` type.
	 */
	var DynamoDBNumberValue = util.inherit({
	  constructor: function NumberValue(value) {
	    this.wrapperName = 'NumberValue';
	    this.value = value.toString();
	  },

	  /**
	   * Render the underlying value as a number when converting to JSON.
	   */
	  toJSON: function () {
	    return this.toNumber();
	  },

	  /**
	   * Convert the underlying value to a JavaScript number.
	   */
	  toNumber: function () {
	    return Number(this.value);
	  },

	  /**
	   * Return a string representing the unaltered value provided to the
	   * constructor.
	   */
	  toString: function () {
	    return this.value;
	  }
	});

	/**
	 * @api private
	 */
	module.exports = DynamoDBNumberValue;

/***/ }),
/* 299 */
/***/ (function(module, exports) {

	module.exports = {"version":"2.0","metadata":{"apiVersion":"2011-12-05","endpointPrefix":"dynamodb","jsonVersion":"1.0","protocol":"json","serviceAbbreviation":"DynamoDB","serviceFullName":"Amazon DynamoDB","serviceId":"DynamoDB","signatureVersion":"v4","targetPrefix":"DynamoDB_20111205","uid":"dynamodb-2011-12-05"},"operations":{"BatchGetItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"S2"}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"type":"structure","members":{"Items":{"shape":"Sk"},"ConsumedCapacityUnits":{"type":"double"}}}},"UnprocessedKeys":{"shape":"S2"}}}},"BatchWriteItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"So"}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"type":"structure","members":{"ConsumedCapacityUnits":{"type":"double"}}}},"UnprocessedItems":{"shape":"So"}}}},"CreateTable":{"input":{"type":"structure","required":["TableName","KeySchema","ProvisionedThroughput"],"members":{"TableName":{},"KeySchema":{"shape":"Sy"},"ProvisionedThroughput":{"shape":"S12"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}},"DeleteItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"DeleteTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}},"DescribeTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"Table":{"shape":"S15"}}}},"GetItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributesToGet":{"shape":"Se"},"ConsistentRead":{"type":"boolean"}}},"output":{"type":"structure","members":{"Item":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"ListTables":{"input":{"type":"structure","members":{"ExclusiveStartTableName":{},"Limit":{"type":"integer"}}},"output":{"type":"structure","members":{"TableNames":{"type":"list","member":{}},"LastEvaluatedTableName":{}}}},"PutItem":{"input":{"type":"structure","required":["TableName","Item"],"members":{"TableName":{},"Item":{"shape":"Ss"},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"Query":{"input":{"type":"structure","required":["TableName","HashKeyValue"],"members":{"TableName":{},"AttributesToGet":{"shape":"Se"},"Limit":{"type":"integer"},"ConsistentRead":{"type":"boolean"},"Count":{"type":"boolean"},"HashKeyValue":{"shape":"S7"},"RangeKeyCondition":{"shape":"S1u"},"ScanIndexForward":{"type":"boolean"},"ExclusiveStartKey":{"shape":"S6"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sk"},"Count":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacityUnits":{"type":"double"}}}},"Scan":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"AttributesToGet":{"shape":"Se"},"Limit":{"type":"integer"},"Count":{"type":"boolean"},"ScanFilter":{"type":"map","key":{},"value":{"shape":"S1u"}},"ExclusiveStartKey":{"shape":"S6"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sk"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacityUnits":{"type":"double"}}}},"UpdateItem":{"input":{"type":"structure","required":["TableName","Key","AttributeUpdates"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributeUpdates":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S7"},"Action":{}}}},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"UpdateTable":{"input":{"type":"structure","required":["TableName","ProvisionedThroughput"],"members":{"TableName":{},"ProvisionedThroughput":{"shape":"S12"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}}},"shapes":{"S2":{"type":"map","key":{},"value":{"type":"structure","required":["Keys"],"members":{"Keys":{"type":"list","member":{"shape":"S6"}},"AttributesToGet":{"shape":"Se"},"ConsistentRead":{"type":"boolean"}}}},"S6":{"type":"structure","required":["HashKeyElement"],"members":{"HashKeyElement":{"shape":"S7"},"RangeKeyElement":{"shape":"S7"}}},"S7":{"type":"structure","members":{"S":{},"N":{},"B":{"type":"blob"},"SS":{"type":"list","member":{}},"NS":{"type":"list","member":{}},"BS":{"type":"list","member":{"type":"blob"}}}},"Se":{"type":"list","member":{}},"Sk":{"type":"list","member":{"shape":"Sl"}},"Sl":{"type":"map","key":{},"value":{"shape":"S7"}},"So":{"type":"map","key":{},"value":{"type":"list","member":{"type":"structure","members":{"PutRequest":{"type":"structure","required":["Item"],"members":{"Item":{"shape":"Ss"}}},"DeleteRequest":{"type":"structure","required":["Key"],"members":{"Key":{"shape":"S6"}}}}}}},"Ss":{"type":"map","key":{},"value":{"shape":"S7"}},"Sy":{"type":"structure","required":["HashKeyElement"],"members":{"HashKeyElement":{"shape":"Sz"},"RangeKeyElement":{"shape":"Sz"}}},"Sz":{"type":"structure","required":["AttributeName","AttributeType"],"members":{"AttributeName":{},"AttributeType":{}}},"S12":{"type":"structure","required":["ReadCapacityUnits","WriteCapacityUnits"],"members":{"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S15":{"type":"structure","members":{"TableName":{},"KeySchema":{"shape":"Sy"},"TableStatus":{},"CreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"type":"structure","members":{"LastIncreaseDateTime":{"type":"timestamp"},"LastDecreaseDateTime":{"type":"timestamp"},"NumberOfDecreasesToday":{"type":"long"},"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"TableSizeBytes":{"type":"long"},"ItemCount":{"type":"long"}}},"S1b":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S7"},"Exists":{"type":"boolean"}}}},"S1u":{"type":"structure","required":["ComparisonOperator"],"members":{"AttributeValueList":{"type":"list","member":{"shape":"S7"}},"ComparisonOperator":{}}}}}

/***/ }),
/* 300 */
/***/ (function(module, exports) {

	module.exports = {"pagination":{"BatchGetItem":{"input_token":"RequestItems","output_token":"UnprocessedKeys"},"ListTables":{"input_token":"ExclusiveStartTableName","limit_key":"Limit","output_token":"LastEvaluatedTableName","result_key":"TableNames"},"Query":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"},"Scan":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"}}}

/***/ }),
/* 301 */
/***/ (function(module, exports) {

	module.exports = {"version":2,"waiters":{"TableExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ACTIVE","matcher":"path","state":"success","argument":"Table.TableStatus"},{"expected":"ResourceNotFoundException","matcher":"error","state":"retry"}]},"TableNotExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ResourceNotFoundException","matcher":"error","state":"success"}]}}}

/***/ }),
/* 302 */
/***/ (function(module, exports) {

	module.exports = {"version":"2.0","metadata":{"apiVersion":"2012-08-10","endpointPrefix":"dynamodb","jsonVersion":"1.0","protocol":"json","serviceAbbreviation":"DynamoDB","serviceFullName":"Amazon DynamoDB","serviceId":"DynamoDB","signatureVersion":"v4","targetPrefix":"DynamoDB_20120810","uid":"dynamodb-2012-08-10"},"operations":{"BatchGetItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"S2"},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"shape":"Sr"}},"UnprocessedKeys":{"shape":"S2"},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"BatchWriteItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"S10"},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{}}},"output":{"type":"structure","members":{"UnprocessedItems":{"shape":"S10"},"ItemCollectionMetrics":{"type":"map","key":{},"value":{"type":"list","member":{"shape":"S1a"}}},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"CreateBackup":{"input":{"type":"structure","required":["TableName","BackupName"],"members":{"TableName":{},"BackupName":{}}},"output":{"type":"structure","members":{"BackupDetails":{"shape":"S1h"}}},"endpointdiscovery":{}},"CreateGlobalTable":{"input":{"type":"structure","required":["GlobalTableName","ReplicationGroup"],"members":{"GlobalTableName":{},"ReplicationGroup":{"shape":"S1p"}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S1t"}}},"endpointdiscovery":{}},"CreateTable":{"input":{"type":"structure","required":["AttributeDefinitions","TableName","KeySchema","ProvisionedThroughput"],"members":{"AttributeDefinitions":{"shape":"S1z"},"TableName":{},"KeySchema":{"shape":"S23"},"LocalSecondaryIndexes":{"type":"list","member":{"type":"structure","required":["IndexName","KeySchema","Projection"],"members":{"IndexName":{},"KeySchema":{"shape":"S23"},"Projection":{"shape":"S28"}}}},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","required":["IndexName","KeySchema","Projection","ProvisionedThroughput"],"members":{"IndexName":{},"KeySchema":{"shape":"S23"},"Projection":{"shape":"S28"},"ProvisionedThroughput":{"shape":"S2e"}}}},"ProvisionedThroughput":{"shape":"S2e"},"StreamSpecification":{"shape":"S2g"},"SSESpecification":{"shape":"S2j"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S2o"}}},"endpointdiscovery":{}},"DeleteBackup":{"input":{"type":"structure","required":["BackupArn"],"members":{"BackupArn":{}}},"output":{"type":"structure","members":{"BackupDescription":{"shape":"S39"}}},"endpointdiscovery":{}},"DeleteItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"Expected":{"shape":"S3m"},"ConditionalOperator":{},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"Sm"},"ExpressionAttributeValues":{"shape":"S3u"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Ss"},"ConsumedCapacity":{"shape":"Su"},"ItemCollectionMetrics":{"shape":"S1a"}}},"endpointdiscovery":{}},"DeleteTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S2o"}}},"endpointdiscovery":{}},"DescribeBackup":{"input":{"type":"structure","required":["BackupArn"],"members":{"BackupArn":{}}},"output":{"type":"structure","members":{"BackupDescription":{"shape":"S39"}}},"endpointdiscovery":{}},"DescribeContinuousBackups":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"ContinuousBackupsDescription":{"shape":"S43"}}},"endpointdiscovery":{}},"DescribeEndpoints":{"input":{"type":"structure","members":{}},"output":{"type":"structure","required":["Endpoints"],"members":{"Endpoints":{"type":"list","member":{"type":"structure","required":["Address","CachePeriodInMinutes"],"members":{"Address":{},"CachePeriodInMinutes":{"type":"long"}}}}}},"endpointoperation":true},"DescribeGlobalTable":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S1t"}}},"endpointdiscovery":{}},"DescribeGlobalTableSettings":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{}}},"output":{"type":"structure","members":{"GlobalTableName":{},"ReplicaSettings":{"shape":"S4f"}}},"endpointdiscovery":{}},"DescribeLimits":{"input":{"type":"structure","members":{}},"output":{"type":"structure","members":{"AccountMaxReadCapacityUnits":{"type":"long"},"AccountMaxWriteCapacityUnits":{"type":"long"},"TableMaxReadCapacityUnits":{"type":"long"},"TableMaxWriteCapacityUnits":{"type":"long"}}},"endpointdiscovery":{}},"DescribeTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"Table":{"shape":"S2o"}}},"endpointdiscovery":{}},"DescribeTimeToLive":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TimeToLiveDescription":{"shape":"S3i"}}},"endpointdiscovery":{}},"GetItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributesToGet":{"shape":"Sj"},"ConsistentRead":{"type":"boolean"},"ReturnConsumedCapacity":{},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"Sm"}}},"output":{"type":"structure","members":{"Item":{"shape":"Ss"},"ConsumedCapacity":{"shape":"Su"}}},"endpointdiscovery":{}},"ListBackups":{"input":{"type":"structure","members":{"TableName":{},"Limit":{"type":"integer"},"TimeRangeLowerBound":{"type":"timestamp"},"TimeRangeUpperBound":{"type":"timestamp"},"ExclusiveStartBackupArn":{},"BackupType":{}}},"output":{"type":"structure","members":{"BackupSummaries":{"type":"list","member":{"type":"structure","members":{"TableName":{},"TableId":{},"TableArn":{},"BackupArn":{},"BackupName":{},"BackupCreationDateTime":{"type":"timestamp"},"BackupExpiryDateTime":{"type":"timestamp"},"BackupStatus":{},"BackupType":{},"BackupSizeBytes":{"type":"long"}}}},"LastEvaluatedBackupArn":{}}},"endpointdiscovery":{}},"ListGlobalTables":{"input":{"type":"structure","members":{"ExclusiveStartGlobalTableName":{},"Limit":{"type":"integer"},"RegionName":{}}},"output":{"type":"structure","members":{"GlobalTables":{"type":"list","member":{"type":"structure","members":{"GlobalTableName":{},"ReplicationGroup":{"shape":"S1p"}}}},"LastEvaluatedGlobalTableName":{}}},"endpointdiscovery":{}},"ListTables":{"input":{"type":"structure","members":{"ExclusiveStartTableName":{},"Limit":{"type":"integer"}}},"output":{"type":"structure","members":{"TableNames":{"type":"list","member":{}},"LastEvaluatedTableName":{}}},"endpointdiscovery":{}},"ListTagsOfResource":{"input":{"type":"structure","required":["ResourceArn"],"members":{"ResourceArn":{},"NextToken":{}}},"output":{"type":"structure","members":{"Tags":{"shape":"S5k"},"NextToken":{}}},"endpointdiscovery":{}},"PutItem":{"input":{"type":"structure","required":["TableName","Item"],"members":{"TableName":{},"Item":{"shape":"S14"},"Expected":{"shape":"S3m"},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ConditionalOperator":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"Sm"},"ExpressionAttributeValues":{"shape":"S3u"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Ss"},"ConsumedCapacity":{"shape":"Su"},"ItemCollectionMetrics":{"shape":"S1a"}}},"endpointdiscovery":{}},"Query":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{},"Select":{},"AttributesToGet":{"shape":"Sj"},"Limit":{"type":"integer"},"ConsistentRead":{"type":"boolean"},"KeyConditions":{"type":"map","key":{},"value":{"shape":"S5t"}},"QueryFilter":{"shape":"S5u"},"ConditionalOperator":{},"ScanIndexForward":{"type":"boolean"},"ExclusiveStartKey":{"shape":"S6"},"ReturnConsumedCapacity":{},"ProjectionExpression":{},"FilterExpression":{},"KeyConditionExpression":{},"ExpressionAttributeNames":{"shape":"Sm"},"ExpressionAttributeValues":{"shape":"S3u"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sr"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacity":{"shape":"Su"}}},"endpointdiscovery":{}},"RestoreTableFromBackup":{"input":{"type":"structure","required":["TargetTableName","BackupArn"],"members":{"TargetTableName":{},"BackupArn":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S2o"}}},"endpointdiscovery":{}},"RestoreTableToPointInTime":{"input":{"type":"structure","required":["SourceTableName","TargetTableName"],"members":{"SourceTableName":{},"TargetTableName":{},"UseLatestRestorableTime":{"type":"boolean"},"RestoreDateTime":{"type":"timestamp"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S2o"}}},"endpointdiscovery":{}},"Scan":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{},"AttributesToGet":{"shape":"Sj"},"Limit":{"type":"integer"},"Select":{},"ScanFilter":{"shape":"S5u"},"ConditionalOperator":{},"ExclusiveStartKey":{"shape":"S6"},"ReturnConsumedCapacity":{},"TotalSegments":{"type":"integer"},"Segment":{"type":"integer"},"ProjectionExpression":{},"FilterExpression":{},"ExpressionAttributeNames":{"shape":"Sm"},"ExpressionAttributeValues":{"shape":"S3u"},"ConsistentRead":{"type":"boolean"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sr"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacity":{"shape":"Su"}}},"endpointdiscovery":{}},"TagResource":{"input":{"type":"structure","required":["ResourceArn","Tags"],"members":{"ResourceArn":{},"Tags":{"shape":"S5k"}}},"endpointdiscovery":{}},"UntagResource":{"input":{"type":"structure","required":["ResourceArn","TagKeys"],"members":{"ResourceArn":{},"TagKeys":{"type":"list","member":{}}}},"endpointdiscovery":{}},"UpdateContinuousBackups":{"input":{"type":"structure","required":["TableName","PointInTimeRecoverySpecification"],"members":{"TableName":{},"PointInTimeRecoverySpecification":{"type":"structure","required":["PointInTimeRecoveryEnabled"],"members":{"PointInTimeRecoveryEnabled":{"type":"boolean"}}}}},"output":{"type":"structure","members":{"ContinuousBackupsDescription":{"shape":"S43"}}},"endpointdiscovery":{}},"UpdateGlobalTable":{"input":{"type":"structure","required":["GlobalTableName","ReplicaUpdates"],"members":{"GlobalTableName":{},"ReplicaUpdates":{"type":"list","member":{"type":"structure","members":{"Create":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}},"Delete":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}}}}}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S1t"}}},"endpointdiscovery":{}},"UpdateGlobalTableSettings":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{},"GlobalTableProvisionedWriteCapacityUnits":{"type":"long"},"GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate":{"shape":"S6j"},"GlobalTableGlobalSecondaryIndexSettingsUpdate":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedWriteCapacityUnits":{"type":"long"},"ProvisionedWriteCapacityAutoScalingSettingsUpdate":{"shape":"S6j"}}}},"ReplicaSettingsUpdate":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaProvisionedReadCapacityUnits":{"type":"long"},"ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate":{"shape":"S6j"},"ReplicaGlobalSecondaryIndexSettingsUpdate":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedReadCapacityUnits":{"type":"long"},"ProvisionedReadCapacityAutoScalingSettingsUpdate":{"shape":"S6j"}}}}}}}}},"output":{"type":"structure","members":{"GlobalTableName":{},"ReplicaSettings":{"shape":"S4f"}}},"endpointdiscovery":{}},"UpdateItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributeUpdates":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S8"},"Action":{}}}},"Expected":{"shape":"S3m"},"ConditionalOperator":{},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"UpdateExpression":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"Sm"},"ExpressionAttributeValues":{"shape":"S3u"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Ss"},"ConsumedCapacity":{"shape":"Su"},"ItemCollectionMetrics":{"shape":"S1a"}}},"endpointdiscovery":{}},"UpdateTable":{"input":{"type":"structure","required":["TableName"],"members":{"AttributeDefinitions":{"shape":"S1z"},"TableName":{},"ProvisionedThroughput":{"shape":"S2e"},"GlobalSecondaryIndexUpdates":{"type":"list","member":{"type":"structure","members":{"Update":{"type":"structure","required":["IndexName","ProvisionedThroughput"],"members":{"IndexName":{},"ProvisionedThroughput":{"shape":"S2e"}}},"Create":{"type":"structure","required":["IndexName","KeySchema","Projection","ProvisionedThroughput"],"members":{"IndexName":{},"KeySchema":{"shape":"S23"},"Projection":{"shape":"S28"},"ProvisionedThroughput":{"shape":"S2e"}}},"Delete":{"type":"structure","required":["IndexName"],"members":{"IndexName":{}}}}}},"StreamSpecification":{"shape":"S2g"},"SSESpecification":{"shape":"S2j"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S2o"}}},"endpointdiscovery":{}},"UpdateTimeToLive":{"input":{"type":"structure","required":["TableName","TimeToLiveSpecification"],"members":{"TableName":{},"TimeToLiveSpecification":{"shape":"S78"}}},"output":{"type":"structure","members":{"TimeToLiveSpecification":{"shape":"S78"}}},"endpointdiscovery":{}}},"shapes":{"S2":{"type":"map","key":{},"value":{"type":"structure","required":["Keys"],"members":{"Keys":{"type":"list","member":{"shape":"S6"}},"AttributesToGet":{"shape":"Sj"},"ConsistentRead":{"type":"boolean"},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"Sm"}}}},"S6":{"type":"map","key":{},"value":{"shape":"S8"}},"S8":{"type":"structure","members":{"S":{},"N":{},"B":{"type":"blob"},"SS":{"type":"list","member":{}},"NS":{"type":"list","member":{}},"BS":{"type":"list","member":{"type":"blob"}},"M":{"type":"map","key":{},"value":{"shape":"S8"}},"L":{"type":"list","member":{"shape":"S8"}},"NULL":{"type":"boolean"},"BOOL":{"type":"boolean"}}},"Sj":{"type":"list","member":{}},"Sm":{"type":"map","key":{},"value":{}},"Sr":{"type":"list","member":{"shape":"Ss"}},"Ss":{"type":"map","key":{},"value":{"shape":"S8"}},"St":{"type":"list","member":{"shape":"Su"}},"Su":{"type":"structure","members":{"TableName":{},"CapacityUnits":{"type":"double"},"Table":{"shape":"Sw"},"LocalSecondaryIndexes":{"shape":"Sx"},"GlobalSecondaryIndexes":{"shape":"Sx"}}},"Sw":{"type":"structure","members":{"CapacityUnits":{"type":"double"}}},"Sx":{"type":"map","key":{},"value":{"shape":"Sw"}},"S10":{"type":"map","key":{},"value":{"type":"list","member":{"type":"structure","members":{"PutRequest":{"type":"structure","required":["Item"],"members":{"Item":{"shape":"S14"}}},"DeleteRequest":{"type":"structure","required":["Key"],"members":{"Key":{"shape":"S6"}}}}}}},"S14":{"type":"map","key":{},"value":{"shape":"S8"}},"S1a":{"type":"structure","members":{"ItemCollectionKey":{"type":"map","key":{},"value":{"shape":"S8"}},"SizeEstimateRangeGB":{"type":"list","member":{"type":"double"}}}},"S1h":{"type":"structure","required":["BackupArn","BackupName","BackupStatus","BackupType","BackupCreationDateTime"],"members":{"BackupArn":{},"BackupName":{},"BackupSizeBytes":{"type":"long"},"BackupStatus":{},"BackupType":{},"BackupCreationDateTime":{"type":"timestamp"},"BackupExpiryDateTime":{"type":"timestamp"}}},"S1p":{"type":"list","member":{"type":"structure","members":{"RegionName":{}}}},"S1t":{"type":"structure","members":{"ReplicationGroup":{"type":"list","member":{"type":"structure","members":{"RegionName":{}}}},"GlobalTableArn":{},"CreationDateTime":{"type":"timestamp"},"GlobalTableStatus":{},"GlobalTableName":{}}},"S1z":{"type":"list","member":{"type":"structure","required":["AttributeName","AttributeType"],"members":{"AttributeName":{},"AttributeType":{}}}},"S23":{"type":"list","member":{"type":"structure","required":["AttributeName","KeyType"],"members":{"AttributeName":{},"KeyType":{}}}},"S28":{"type":"structure","members":{"ProjectionType":{},"NonKeyAttributes":{"type":"list","member":{}}}},"S2e":{"type":"structure","required":["ReadCapacityUnits","WriteCapacityUnits"],"members":{"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S2g":{"type":"structure","members":{"StreamEnabled":{"type":"boolean"},"StreamViewType":{}}},"S2j":{"type":"structure","members":{"Enabled":{"type":"boolean"},"SSEType":{},"KMSMasterKeyId":{}}},"S2o":{"type":"structure","members":{"AttributeDefinitions":{"shape":"S1z"},"TableName":{},"KeySchema":{"shape":"S23"},"TableStatus":{},"CreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"shape":"S2q"},"TableSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"TableArn":{},"TableId":{},"LocalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S23"},"Projection":{"shape":"S28"},"IndexSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"IndexArn":{}}}},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S23"},"Projection":{"shape":"S28"},"IndexStatus":{},"Backfilling":{"type":"boolean"},"ProvisionedThroughput":{"shape":"S2q"},"IndexSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"IndexArn":{}}}},"StreamSpecification":{"shape":"S2g"},"LatestStreamLabel":{},"LatestStreamArn":{},"RestoreSummary":{"type":"structure","required":["RestoreDateTime","RestoreInProgress"],"members":{"SourceBackupArn":{},"SourceTableArn":{},"RestoreDateTime":{"type":"timestamp"},"RestoreInProgress":{"type":"boolean"}}},"SSEDescription":{"shape":"S34"}}},"S2q":{"type":"structure","members":{"LastIncreaseDateTime":{"type":"timestamp"},"LastDecreaseDateTime":{"type":"timestamp"},"NumberOfDecreasesToday":{"type":"long"},"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S34":{"type":"structure","members":{"Status":{},"SSEType":{},"KMSMasterKeyArn":{}}},"S39":{"type":"structure","members":{"BackupDetails":{"shape":"S1h"},"SourceTableDetails":{"type":"structure","required":["TableName","TableId","KeySchema","TableCreationDateTime","ProvisionedThroughput"],"members":{"TableName":{},"TableId":{},"TableArn":{},"TableSizeBytes":{"type":"long"},"KeySchema":{"shape":"S23"},"TableCreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"shape":"S2e"},"ItemCount":{"type":"long"}}},"SourceTableFeatureDetails":{"type":"structure","members":{"LocalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S23"},"Projection":{"shape":"S28"}}}},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S23"},"Projection":{"shape":"S28"},"ProvisionedThroughput":{"shape":"S2e"}}}},"StreamDescription":{"shape":"S2g"},"TimeToLiveDescription":{"shape":"S3i"},"SSEDescription":{"shape":"S34"}}}}},"S3i":{"type":"structure","members":{"TimeToLiveStatus":{},"AttributeName":{}}},"S3m":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S8"},"Exists":{"type":"boolean"},"ComparisonOperator":{},"AttributeValueList":{"shape":"S3q"}}}},"S3q":{"type":"list","member":{"shape":"S8"}},"S3u":{"type":"map","key":{},"value":{"shape":"S8"}},"S43":{"type":"structure","required":["ContinuousBackupsStatus"],"members":{"ContinuousBackupsStatus":{},"PointInTimeRecoveryDescription":{"type":"structure","members":{"PointInTimeRecoveryStatus":{},"EarliestRestorableDateTime":{"type":"timestamp"},"LatestRestorableDateTime":{"type":"timestamp"}}}}},"S4f":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaStatus":{},"ReplicaProvisionedReadCapacityUnits":{"type":"long"},"ReplicaProvisionedReadCapacityAutoScalingSettings":{"shape":"S4i"},"ReplicaProvisionedWriteCapacityUnits":{"type":"long"},"ReplicaProvisionedWriteCapacityAutoScalingSettings":{"shape":"S4i"},"ReplicaGlobalSecondaryIndexSettings":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"IndexStatus":{},"ProvisionedReadCapacityUnits":{"type":"long"},"ProvisionedReadCapacityAutoScalingSettings":{"shape":"S4i"},"ProvisionedWriteCapacityUnits":{"type":"long"},"ProvisionedWriteCapacityAutoScalingSettings":{"shape":"S4i"}}}}}}},"S4i":{"type":"structure","members":{"MinimumUnits":{"type":"long"},"MaximumUnits":{"type":"long"},"AutoScalingDisabled":{"type":"boolean"},"AutoScalingRoleArn":{},"ScalingPolicies":{"type":"list","member":{"type":"structure","members":{"PolicyName":{},"TargetTrackingScalingPolicyConfiguration":{"type":"structure","required":["TargetValue"],"members":{"DisableScaleIn":{"type":"boolean"},"ScaleInCooldown":{"type":"integer"},"ScaleOutCooldown":{"type":"integer"},"TargetValue":{"type":"double"}}}}}}}},"S5k":{"type":"list","member":{"type":"structure","required":["Key","Value"],"members":{"Key":{},"Value":{}}}},"S5t":{"type":"structure","required":["ComparisonOperator"],"members":{"AttributeValueList":{"shape":"S3q"},"ComparisonOperator":{}}},"S5u":{"type":"map","key":{},"value":{"shape":"S5t"}},"S6j":{"type":"structure","members":{"MinimumUnits":{"type":"long"},"MaximumUnits":{"type":"long"},"AutoScalingDisabled":{"type":"boolean"},"AutoScalingRoleArn":{},"ScalingPolicyUpdate":{"type":"structure","required":["TargetTrackingScalingPolicyConfiguration"],"members":{"PolicyName":{},"TargetTrackingScalingPolicyConfiguration":{"type":"structure","required":["TargetValue"],"members":{"DisableScaleIn":{"type":"boolean"},"ScaleInCooldown":{"type":"integer"},"ScaleOutCooldown":{"type":"integer"},"TargetValue":{"type":"double"}}}}}}},"S78":{"type":"structure","required":["Enabled","AttributeName"],"members":{"Enabled":{"type":"boolean"},"AttributeName":{}}}}}

/***/ }),
/* 303 */
/***/ (function(module, exports) {

	module.exports = {"pagination":{"BatchGetItem":{"input_token":"RequestItems","output_token":"UnprocessedKeys"},"ListTables":{"input_token":"ExclusiveStartTableName","limit_key":"Limit","output_token":"LastEvaluatedTableName","result_key":"TableNames"},"Query":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"},"Scan":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"}}}

/***/ }),
/* 304 */
/***/ (function(module, exports) {

	module.exports = {"version":2,"waiters":{"TableExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ACTIVE","matcher":"path","state":"success","argument":"Table.TableStatus"},{"expected":"ResourceNotFoundException","matcher":"error","state":"retry"}]},"TableNotExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ResourceNotFoundException","matcher":"error","state":"success"}]}}}

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.DynamoDBORMError = undefined;

	var _extends2 = __webpack_require__(2);

	var _extends3 = _interopRequireDefault(_extends2);

	var _classCallCheck2 = __webpack_require__(42);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(306);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(323);

	var _inherits3 = _interopRequireDefault(_inherits2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var DynamoDBORMError = exports.DynamoDBORMError = function (_Error) {
	    (0, _inherits3.default)(DynamoDBORMError, _Error);

	    function DynamoDBORMError(_ref, code, message) {
	        var error = _ref.error,
	            errors = _ref.errors,
	            args = _ref.args,
	            className = _ref.className,
	            method = _ref.method;
	        (0, _classCallCheck3.default)(this, DynamoDBORMError);

	        var _this = (0, _possibleConstructorReturn3.default)(this, (DynamoDBORMError.__proto__ || Object.getPrototypeOf(DynamoDBORMError)).call(this, message || code + ' has being catch in ' + className + ' on method ' + method));

	        _this.name = 'DynamoDBORMError';
	        _this.code = code;
	        if (error) {
	            _this.error = error;
	        }
	        if (errors) {
	            _this.errors = errors;
	        }
	        _this.fnData = {
	            args: args,
	            method: method,
	            className: className
	        };

	        Error.captureStackTrace(_this, _this.constructor);
	        return _this;
	    }

	    return DynamoDBORMError;
	}(Error);

	function mapErrors(errors) {
	    return errors.map(function (error) {
	        return (0, _extends3.default)({
	            identifier: error.code,
	            message: error.message
	        }, error);
	    });
	}

	DynamoDBORMError.fromArray = function (errors, kind, message) {
	    return new DynamoDBORMError((0, _extends3.default)({}, errors[0], {
	        error: undefined,
	        errors: mapErrors(errors)
	    }), kind, message);
	};

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(307);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _iterator = __webpack_require__(308);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _symbol = __webpack_require__(311);

	var _symbol2 = _interopRequireDefault(_symbol);

	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(309), __esModule: true };

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(53);
	__webpack_require__(76);
	module.exports = __webpack_require__(310).f('iterator');


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(63);


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(312), __esModule: true };

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(313);
	__webpack_require__(75);
	__webpack_require__(321);
	__webpack_require__(322);
	module.exports = __webpack_require__(8).Symbol;


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global = __webpack_require__(7);
	var has = __webpack_require__(21);
	var DESCRIPTORS = __webpack_require__(16);
	var $export = __webpack_require__(6);
	var redefine = __webpack_require__(56);
	var META = __webpack_require__(314).KEY;
	var $fails = __webpack_require__(17);
	var shared = __webpack_require__(34);
	var setToStringTag = __webpack_require__(62);
	var uid = __webpack_require__(36);
	var wks = __webpack_require__(63);
	var wksExt = __webpack_require__(310);
	var wksDefine = __webpack_require__(315);
	var enumKeys = __webpack_require__(316);
	var isArray = __webpack_require__(317);
	var anObject = __webpack_require__(13);
	var isObject = __webpack_require__(14);
	var toIObject = __webpack_require__(25);
	var toPrimitive = __webpack_require__(19);
	var createDesc = __webpack_require__(20);
	var _create = __webpack_require__(59);
	var gOPNExt = __webpack_require__(318);
	var $GOPD = __webpack_require__(320);
	var $DP = __webpack_require__(12);
	var $keys = __webpack_require__(23);
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function () { return dP(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(319).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(39).f = $propertyIsEnumerable;
	  __webpack_require__(38).f = $getOwnPropertySymbols;

	  if (DESCRIPTORS && !__webpack_require__(35)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	var META = __webpack_require__(36)('meta');
	var isObject = __webpack_require__(14);
	var has = __webpack_require__(21);
	var setDesc = __webpack_require__(12).f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(17)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7);
	var core = __webpack_require__(8);
	var LIBRARY = __webpack_require__(35);
	var wksExt = __webpack_require__(310);
	var defineProperty = __webpack_require__(12).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(23);
	var gOPS = __webpack_require__(38);
	var pIE = __webpack_require__(39);
	module.exports = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(27);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(25);
	var gOPN = __webpack_require__(319).f;
	var toString = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(24);
	var hiddenKeys = __webpack_require__(37).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE = __webpack_require__(39);
	var createDesc = __webpack_require__(20);
	var toIObject = __webpack_require__(25);
	var toPrimitive = __webpack_require__(19);
	var has = __webpack_require__(21);
	var IE8_DOM_DEFINE = __webpack_require__(15);
	var gOPD = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(315)('asyncIterator');


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(315)('observable');


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _setPrototypeOf = __webpack_require__(324);

	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

	var _create = __webpack_require__(328);

	var _create2 = _interopRequireDefault(_create);

	var _typeof2 = __webpack_require__(307);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }

	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(325), __esModule: true };

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(326);
	module.exports = __webpack_require__(8).Object.setPrototypeOf;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(327).set });


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14);
	var anObject = __webpack_require__(13);
	var check = function (O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = __webpack_require__(9)(Function.call, __webpack_require__(320).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(329), __esModule: true };

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(330);
	var $Object = __webpack_require__(8).Object;
	module.exports = function create(P, D) {
	  return $Object.create(P, D);
	};


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: __webpack_require__(59) });


/***/ }),
/* 331 */,
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Migration = undefined;

	var _toConsumableArray2 = __webpack_require__(50);

	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

	var _objectWithoutProperties2 = __webpack_require__(41);

	var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

	var _typeof2 = __webpack_require__(307);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _defineProperty2 = __webpack_require__(333);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends4 = __webpack_require__(2);

	var _extends5 = _interopRequireDefault(_extends4);

	var _regenerator = __webpack_require__(47);

	var _regenerator2 = _interopRequireDefault(_regenerator);

	var _asyncToGenerator2 = __webpack_require__(72);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _createClass2 = __webpack_require__(43);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _classCallCheck2 = __webpack_require__(42);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(306);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(323);

	var _inherits3 = _interopRequireDefault(_inherits2);

	exports.findDomainDeps = findDomainDeps;
	exports.getMigrationsFiles = getMigrationsFiles;

	var _fs = __webpack_require__(205);

	var _fs2 = _interopRequireDefault(_fs);

	var _path = __webpack_require__(236);

	var _path2 = _interopRequireDefault(_path);

	var _util = __webpack_require__(190);

	var _util2 = _interopRequireDefault(_util);

	var _Connection2 = __webpack_require__(1);

	var _Connection3 = _interopRequireDefault(_Connection2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var MigrationError = function (_Error) {
	    (0, _inherits3.default)(MigrationError, _Error);

	    function MigrationError(genericMessage, errorsList) {
	        var _ref;

	        (0, _classCallCheck3.default)(this, MigrationError);

	        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	            args[_key - 2] = arguments[_key];
	        }

	        var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = MigrationError.__proto__ || Object.getPrototypeOf(MigrationError)).call.apply(_ref, [this, genericMessage, errorsList].concat(args)));

	        _this.errors = errorsList;
	        return _this;
	    }

	    return MigrationError;
	}(Error);

	var Migration = exports.Migration = function (_Connection) {
	    (0, _inherits3.default)(Migration, _Connection);

	    function Migration(ChangeLogAggregator) {
	        var _ref2;

	        (0, _classCallCheck3.default)(this, Migration);

	        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	            args[_key2 - 1] = arguments[_key2];
	        }

	        var _this2 = (0, _possibleConstructorReturn3.default)(this, (_ref2 = Migration.__proto__ || Object.getPrototypeOf(Migration)).call.apply(_ref2, [this].concat(args)));

	        _this2.ChangeLogAggregator = ChangeLogAggregator;
	        return _this2;
	    }

	    (0, _createClass3.default)(Migration, [{
	        key: 'log',
	        value: function () {
	            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref4) {
	                var operation = _ref4.operation,
	                    completedAt = _ref4.completedAt,
	                    domain = _ref4.domain,
	                    migrationName = _ref4.migrationName,
	                    kind = _ref4.kind,
	                    status = _ref4.status,
	                    errorMessage = _ref4.errorMessage,
	                    label = _ref4.label,
	                    duration = _ref4.duration;
	                var ChangeLog, log;
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                ChangeLog = this.ChangeLogAggregator.ChangeLog;
	                                log = new ChangeLog({
	                                    status: status,
	                                    errorMessage: errorMessage,
	                                    label: label,
	                                    operation: operation,
	                                    completedAt: completedAt,
	                                    duration: duration,
	                                    domain: domain,
	                                    migrationName: migrationName,
	                                    kind: kind
	                                });
	                                _context.next = 4;
	                                return log.save();

	                            case 4:
	                                return _context.abrupt('return', this);

	                            case 5:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, this);
	            }));

	            function log(_x) {
	                return _ref3.apply(this, arguments);
	            }

	            return log;
	        }()
	    }, {
	        key: 'createTable',
	        value: function () {
	            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(Model) {
	                var _this3 = this;

	                return _regenerator2.default.wrap(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                return _context2.abrupt('return', this.mapper.ensureTableExists(Model, (0, _extends5.default)({
	                                    readCapacityUnits: Model.readCapacity,
	                                    writeCapacityUnits: Model.writeCapacity
	                                }, Model.indexes && Model.indexes.length ? { indexOptions: Model.indexes.reduce(function (options, index) {
	                                        return (0, _extends5.default)({}, options, (0, _defineProperty3.default)({}, index.name, {
	                                            readCapacityUnits: index.readCapacity,
	                                            writeCapacityUnits: index.writeCapacity,
	                                            projection: index.projection,
	                                            type: index.type

	                                        }));
	                                    }, {})
	                                } : {})).then(function () {
	                                    return _this3;
	                                }));

	                            case 1:
	                            case 'end':
	                                return _context2.stop();
	                        }
	                    }
	                }, _callee2, this);
	            }));

	            function createTable(_x2) {
	                return _ref5.apply(this, arguments);
	            }

	            return createTable;
	        }()
	    }, {
	        key: 'dropTable',
	        value: function () {
	            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(Model) {
	                var _this4 = this;

	                return _regenerator2.default.wrap(function _callee3$(_context3) {
	                    while (1) {
	                        switch (_context3.prev = _context3.next) {
	                            case 0:
	                                return _context3.abrupt('return', this.mapper.ensureTableNotExists(Model).then(function () {
	                                    return _this4;
	                                }));

	                            case 1:
	                            case 'end':
	                                return _context3.stop();
	                        }
	                    }
	                }, _callee3, this);
	            }));

	            function dropTable(_x3) {
	                return _ref6.apply(this, arguments);
	            }

	            return dropTable;
	        }()

	        // TODO: CHANGE
	        // https://github.com/awslabs/dynamodb-data-mapper-js/issues/58

	    }, {
	        key: 'updateItems',
	        value: function () {
	            var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(fn) {
	                return _regenerator2.default.wrap(function _callee4$(_context4) {
	                    while (1) {
	                        switch (_context4.prev = _context4.next) {
	                            case 0:
	                            case 'end':
	                                return _context4.stop();
	                        }
	                    }
	                }, _callee4, this);
	            }));

	            function updateItems(_x4) {
	                return _ref7.apply(this, arguments);
	            }

	            return updateItems;
	        }()
	    }, {
	        key: 'changeIndexes',

	        // https://github.com/awslabs/dynamodb-data-mapper-js/issues/113
	        value: function () {
	            var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(index) {
	                return _regenerator2.default.wrap(function _callee5$(_context5) {
	                    while (1) {
	                        switch (_context5.prev = _context5.next) {
	                            case 0:
	                            case 'end':
	                                return _context5.stop();
	                        }
	                    }
	                }, _callee5, this);
	            }));

	            function changeIndexes(_x5) {
	                return _ref8.apply(this, arguments);
	            }

	            return changeIndexes;
	        }()
	    }]);
	    return Migration;
	}(_Connection3.default);

	Migration.do = function (operation, fnList, migration, label) {
	    function isPromise(obj) {
	        return !!obj && ((typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
	    }
	    var validationErrors = [];
	    if (operation !== 'deploy' && operation !== 'rollback') {
	        validationErrors.push({
	            message: 'Not received a valid operation to perform',
	            identifier: '1st argument, operation'
	        });
	    }
	    if (!(fnList instanceof Array) && !(fnList.fn instanceof Function)) {
	        validationErrors.push({
	            message: 'Not received a valid task to perform',
	            identifier: '2nd argument, fnList'
	        });
	    }

	    if (!(migration instanceof Migration)) {
	        validationErrors.push({
	            message: 'Not received a valid migration instance',
	            identifier: '3rd argument, migration'
	        });
	    }

	    if (fnList instanceof Array) {
	        fnList.forEach(function (i, index) {
	            // console.log(util.inspect(i), typeof fn)
	            if (typeof i.fn !== 'function') {
	                validationErrors.push({
	                    message: 'A Task inside the list was not a valid function',
	                    identifier: '2nd argument, fnList item in position ' + index + ' [zeroBasedIndex]'
	                });
	            }
	        });
	    } else {
	        var fn = fnList.fn;

	        if (typeof fn !== 'function') {
	            validationErrors.push({
	                message: 'The Task sended is not a valid function',
	                identifier: '2nd argument, fnList as a unique item'
	            });
	        }
	    }

	    fnList instanceof Object;

	    if (validationErrors.length) {
	        return Promise.reject(new MigrationError('A validation error has being catch... operation not performed', validationErrors));
	    }

	    var labelToBeloged = label || operation + '.' + Date.now();

	    var lineupMigrations = function lineupMigrations(funcs) {
	        return funcs.reduce(function (promise, _ref9, index) {
	            var fn = _ref9.fn,
	                migrationName = _ref9.migrationName,
	                DomainAggregator = _ref9.DomainAggregator,
	                kind = _ref9.kind,
	                domain = _ref9.domain;

	            // log begin here
	            var start = Date.now();
	            return promise.then(function (lastFnCompleted) {
	                console.log(migrationName + ', ' + domain + ' is about to start');
	                if (isPromise(fn)) {
	                    return fn;
	                }

	                return function () {
	                    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	                        args[_key3] = arguments[_key3];
	                    }

	                    return new Promise(function (resolve, reject) {
	                        try {
	                            return resolve(fn.apply(undefined, args));
	                        } catch (err) {
	                            return reject(err);
	                        }
	                    });
	                };
	            }).then(function (fnPromissed) {
	                return fnPromissed(DomainAggregator).then(function (migrationHasCompleted) {
	                    var duration = Date.now() - start;
	                    console.log(migrationName + ', ' + domain + ' has completed: ' + duration + ' seconds');

	                    return migration.log({
	                        operation: operation,
	                        kind: kind,
	                        completedAt: new Date().toISOString(),
	                        duration: duration,
	                        domain: domain,
	                        label: labelToBeloged,
	                        migrationName: migrationName,
	                        status: 1 // 'success'
	                    });
	                }).catch(function (err) {
	                    var duration = Date.now() - start;
	                    console.log(migrationName + ', ' + domain + ' has throw: ' + duration + ' seconds');
	                    console.log('ERROR::::', err);
	                    return migration.log({
	                        operation: operation,
	                        completedAt: new Date().toISOString(),
	                        duration: duration,
	                        kind: kind,
	                        domain: domain,
	                        label: labelToBeloged,
	                        migrationName: migrationName,
	                        status: 0, // error 
	                        errorMessage: err
	                    }).then(function () {
	                        throw new Error('A error has being occured, check migration logs for more information');
	                    });
	                });
	            });
	        }, Promise.resolve([]));
	    };
	    var bindedFns = (fnList instanceof Array ? fnList : [fnList]).map(function (_ref10) {
	        var fn = _ref10.fn,
	            args = (0, _objectWithoutProperties3.default)(_ref10, ['fn']);
	        return (0, _extends5.default)({ fn: fn.bind(migration) }, args);
	    });

	    try {
	        console.log(operation + ' about to start');
	        var _start = Date.now();
	        return lineupMigrations(bindedFns).then(function (lastFnCompleted) {
	            return console.log(operation + ' has being completed, duration: ' + (Date.now() - _start) + ' seconds');
	        });
	    } catch (err) {
	        console.log('Error has being catch and has interrupted ' + operation + ', duration: ' + (Date.now() - start) + ' seconds');
	    }
	};

	function validateDomainName(name) {
	    var isDomain = !!name.match(/domain-/g);
	    return isDomain;
	}
	function checkValidDynamodbORMDomain(_package) {
	    var isDomain = validateDomainName(_package.name);
	    var hasDynamodbORM = !!_package.dependencies['@spark/dynamodborm'] || !!_package.dependencies['dynamodborm'];
	    return isDomain && hasDynamodbORM;
	}

	function findDomainDeps(_package) {
	    var deps = _package.dependencies;
	    var depsNames = Object.keys(deps);
	    var depsVersions = Object.values(deps);
	    var getDomains = function getDomains() {
	        var domains = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	        var this_iteration_domain = void 0;
	        if (depsNames[index].match(/domain-/g)) {
	            var atualized_domains = [].concat((0, _toConsumableArray3.default)(domains), [{
	                domain: depsNames[index],
	                reference: depsVersions[index]
	            }]);
	            this_iteration_domain = atualized_domains;
	        }
	        var atualized_index = index + 1;
	        if (atualized_index < depsNames.length) {
	            return getDomains(this_iteration_domain || domains, atualized_index);
	        }

	        return this_iteration_domain || domains;
	    };
	    return getDomains();
	}
	function getMigrationsFiles(domain) {
	    var comandDirPath = this.comandDirPath,
	        _package = this._package;


	    function getCustomOrDefaultList(domainName) {
	        if (domainName) {
	            if (!validateDomainName(domainName)) {
	                throw new Error('Not a valid domain name');
	            }
	        }
	        var fullpath = _path2.default.join.apply(_path2.default, [comandDirPath].concat((0, _toConsumableArray3.default)(domainName && domainName !== _package.name ? ['node_modules'].concat((0, _toConsumableArray3.default)(domainName.split('/')), ['src']) : ['src']), ['migrations']));

	        console.log(fullpath);

	        if (_fs2.default.existsSync(fullpath)) {
	            var migrationsfile = _fs2.default.readdirSync(fullpath);
	            if (migrationsfile.length) {
	                return migrationsfile.map(function (filepath) {
	                    return '' + _path2.default.join(fullpath, filepath);
	                });
	            }
	        }

	        var defaultPath = _path2.default.join(
	        // __dirname,
	        comandDirPath,
	        // ...(domainName ? domainName.split('/') : []),
	        'node_modules', '@spark', 'dynamodborm', 'migrate', 'default-migrations');
	        // default create-table
	        return _fs2.default.readdirSync(defaultPath).map(function (filepath) {
	            return '' + _path2.default.join(defaultPath, filepath);
	        });
	    }

	    if (!domain) {
	        if (checkValidDynamodbORMDomain(_package)) {
	            // procceed with reading on the actual package
	            return (0, _defineProperty3.default)({}, _package.name, getCustomOrDefaultList());
	        }

	        // look for domain packages in dependencies
	        var domains = findDomainDeps(_package);
	        if (domains.length) {
	            // go to domain packages
	            return domains.map(function (_ref12) {
	                var domain = _ref12.domain;
	                return getCustomOrDefaultList(domain);
	            }).reduce(function (finalList, list, i) {
	                return (0, _extends5.default)({}, finalList, (0, _defineProperty3.default)({}, domains[i].domain, list));
	            }, {});
	        }
	        throw new Error('Not found a valid dynamodborm domain');
	    }
	    return (0, _defineProperty3.default)({}, domain, getCustomOrDefaultList(domain));
	}

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(44);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

/***/ })
/******/ ]);